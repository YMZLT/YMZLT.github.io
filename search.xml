<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实现经典的EC算法</title>
    <url>/post/84dce0b4.html</url>
    <content><![CDATA[<p>本文记录中科大研究生课程——《存储与文件系统》的EC实验。使用Jerasure纠删码函数库实现经典的EC算法。</p>
<span id="more"></span>
<h1 id="实验介绍">实验介绍</h1>
<p>Jerasure是一个C/C++纠删码函数库，提供了编解码过程中可直接调用的工具函数。本次实验要求将多个经典的EC编码实现在Jerasure库中。</p>
<p>可使用函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">cauchy_good_general_coding_matrix</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> w)</span></span><br><span class="line"><span class="comment">//函数功能：生成编码矩阵（柯西矩阵）的函数，返回编码矩阵的最后m行</span></span><br><span class="line"><span class="comment">//k: 数据块个数</span></span><br><span class="line"><span class="comment">//m: 校验块个数</span></span><br><span class="line"><span class="comment">//w: word size</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jerasure_matrix_dotprod</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span> *matrix_row,<span class="type">int</span> *src_ids, <span class="type">int</span> dest_id,</span></span><br><span class="line"><span class="params"><span class="type">char</span> **data_ptrs, <span class="type">char</span> **coding_ptrs, <span class="type">int</span> size)</span></span><br><span class="line"><span class="comment">//函数功能：编解码矩阵的某一行与k个块进行乘法运算</span></span><br><span class="line"><span class="comment">//k: 数据块个数</span></span><br><span class="line"><span class="comment">//w: word size</span></span><br><span class="line"><span class="comment">//matrix_row：编解码矩阵的某一行</span></span><br><span class="line"><span class="comment">//src_ids: 计算所用的源块</span></span><br><span class="line"><span class="comment">//dest_id: 计算目标块号</span></span><br><span class="line"><span class="comment">//data_ptrs: 数据块指针</span></span><br><span class="line"><span class="comment">//coding_ptrs: 校验块指针</span></span><br><span class="line"><span class="comment">//size: 数据块大小</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">galois_w08_region_multiply</span><span class="params">(<span class="type">char</span> *region, <span class="type">int</span> multby, <span class="type">int</span> nbytes, <span class="type">char</span> *r2, <span class="type">int</span> add)</span></span><br><span class="line"><span class="comment">//函数功能：在有限域$GF(2^8)$下对region所有数据乘以常数multby，结果存在r2中</span></span><br><span class="line"><span class="comment">//region：进行乘法的数据</span></span><br><span class="line"><span class="comment">//multby：乘数</span></span><br><span class="line"><span class="comment">//nbytes：region大小</span></span><br><span class="line"><span class="comment">//r2：乘法结果</span></span><br><span class="line"><span class="comment">//add：目的块r2是否初始化，0表示未初始化，1表示已经初始化</span></span><br><span class="line"><span class="comment">//galois_w16_region_multiply() 和 galois_w32_region_multiply() 类似，分别表示在有限域和 下进行乘法运算:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">galois_region_xor</span><span class="params">(<span class="type">char</span> *src, <span class="type">char</span> *dest,<span class="type">int</span> nbytes)</span></span><br><span class="line"><span class="comment">//函数功能：src和dest指向的两个块进行异或运算，结果存在dest中</span></span><br><span class="line"><span class="comment">//src:源块</span></span><br><span class="line"><span class="comment">//dest：目标块</span></span><br><span class="line"><span class="comment">//nbytes：块大小</span></span><br></pre></td></tr></table></figure>
<h1 id="实验环境">实验环境</h1>
<table>
<thead>
<tr class="header">
<th>CPU</th>
<th>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>内存</td>
<td>4194304 kB</td>
</tr>
<tr class="even">
<td>操作系统</td>
<td>Ubuntu 20.04.3 (64位)</td>
</tr>
<tr class="odd">
<td>C/C++编译器</td>
<td>gcc version 9.4.0</td>
</tr>
</tbody>
</table>
<h1 id="任务三-实现raid-6编码">任务三 实现RAID-6编码</h1>
<h2 id="任务">任务</h2>
<ul>
<li>给定一个大小为1GB的文件的路径，生成由(4,2)
RAID-6编码得到的数据块和校验块文件（块大小：16MB），并计算编码吞吐量；</li>
<li>模拟当一个节点故障，修复该节点上的所有块，计算修复的吞吐量。</li>
</ul>
<h2 id="编码">编码</h2>
<p>RAID-6编码采用P+Q两冗余分块以容许任意两磁盘并发同时失效的存储级别。以(4,2)
RAID-6为例，一个条带的编码过程可以表示为：</p>
<p><img src="/post/84dce0b4/image-20221116135954702.png" style="zoom:80%;"></p>
<p>实现步骤：</p>
<ul>
<li>调用Jerasure提供的接口<code>cauchy_good_general_coding_matrix</code>生成一个m*k的基于有限域的柯西矩阵。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> RAID6:</span><br><span class="line">		matrix = cauchy_good_general_coding_matrix(k, m, w); <span class="comment">// 生成编码矩阵（柯西矩阵）的函数，返回编码矩阵的最后m行</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用接口<code>jerasure_matrix_dotprod</code>，将生成的柯西编码矩阵与k个数据块进行乘法运算，最后得到m个校验块。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raid6_encode</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> w, <span class="type">int</span> *matrix,</span></span><br><span class="line"><span class="params">				  <span class="type">char</span> **data_ptrs, <span class="type">char</span> **coding_ptrs, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// 编码矩阵(柯西矩阵)与k个数据块进行乘法运算 得到m个校验块</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		jerasure_matrix_dotprod(k, w, matrix + (i * k), <span class="literal">NULL</span>, k + i, data_ptrs, coding_ptrs, size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解码">解码</h2>
<p>当某一数据块不可用时，需要从剩余块中读取4个块，并解码恢复出数据块。例如，当<span class="math inline">\(D_{i,0}\)</span>不可用时，可以读取<span class="math inline">\(D_{i,1},D_{i,2},D_{i,3},P_i\)</span>进行解码，计算过程如下：</p>
<p><img src="/post/84dce0b4/image-20221116140037758.png" style="zoom:80%;"></p>
<p>RAID-6解码过程最核心的就是求出编码矩阵的逆矩阵，与剩余完好的盘块矩阵相乘即可恢复。这里参考了<code>jerasure_matrix_decode</code>接口函数的解码过程，使用lastdrive对数据盘和校验盘分开处理，只有在有坏块且坏块是数据盘才需要生成逆矩阵，对于损坏的校验盘直接重新生成。</p>
<p>实现步骤：</p>
<ul>
<li>根据erasures生成erased数组 记录每个磁盘的状态</li>
<li>生成解码矩阵（只有在有坏块且坏块是数据盘才需要生成逆矩阵）</li>
<li>根据生成的解码矩阵 解码数据磁盘块</li>
<li>重新生成所有剩下的坏磁盘块（此时应该只有校验盘块需要被修复）</li>
</ul>
<p>解码函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raid6_decode</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> w, <span class="type">int</span> *matrix, <span class="type">int</span> row_k_ones, <span class="type">int</span> *erasures,</span></span><br><span class="line"><span class="params">                 <span class="type">char</span> **data_ptrs, <span class="type">char</span> **coding_ptrs, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, edd, lastdrive;</span><br><span class="line">    <span class="type">int</span> *tmpids;</span><br><span class="line">    <span class="type">int</span> *erased, *decoding_matrix, *dm_ids;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="number">8</span> &amp;&amp; w != <span class="number">16</span> &amp;&amp; w != <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 根据erasures生成erased数组 记录每个磁盘的状态 */</span></span><br><span class="line">    erased = talloc(<span class="type">int</span>, (k + m));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m + k; i++)</span><br><span class="line">        erased[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (erased[erasures[i]] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            erased[erasures[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 记录被擦除的磁盘块数 */</span></span><br><span class="line">    edd = <span class="number">0</span>;</span><br><span class="line">    lastdrive = k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (erased[i])</span><br><span class="line">        &#123;</span><br><span class="line">            edd++;</span><br><span class="line">            lastdrive = i; <span class="comment">// 记录最后一个坏数据盘号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有数据盘被损坏或者第一个校验盘被损坏则将k记录最后要扫描的磁盘号</span></span><br><span class="line">    <span class="comment">// 因为校验盘不需要生成逆矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (!row_k_ones || erased[k]) </span><br><span class="line">        lastdrive = k; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 生成解码矩阵 只有在有坏块且坏块是数据盘才需要生成逆矩阵*/</span></span><br><span class="line"></span><br><span class="line">    dm_ids = <span class="literal">NULL</span>;</span><br><span class="line">    decoding_matrix = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edd &gt; <span class="number">1</span> || (edd &gt; <span class="number">0</span> &amp;&amp; (!row_k_ones || erased[k])))</span><br><span class="line">    &#123;</span><br><span class="line">        dm_ids = talloc(<span class="type">int</span>, k);</span><br><span class="line">        decoding_matrix = talloc(<span class="type">int</span>, k *k);</span><br><span class="line">        <span class="keyword">if</span> (jerasure_make_decoding_matrix(k, m, w, matrix, erased, decoding_matrix, dm_ids) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(erased);</span><br><span class="line">            <span class="built_in">free</span>(dm_ids);</span><br><span class="line">            <span class="built_in">free</span>(decoding_matrix);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 根据生成的解码矩阵 解码数据磁盘块 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; edd &gt; <span class="number">0</span> &amp;&amp; i &lt; lastdrive; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (erased[i])</span><br><span class="line">        &#123;</span><br><span class="line">            jerasure_matrix_dotprod(k, w, decoding_matrix + (i * k), dm_ids, i, data_ptrs, coding_ptrs, size);</span><br><span class="line">            edd--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果还有磁盘未被修复 则应该是包括最后的一个数据块 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edd &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpids = talloc(<span class="type">int</span>, k);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpids[i] = (i &lt; lastdrive) ? i : i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        jerasure_matrix_dotprod(k, w, matrix, tmpids, lastdrive, data_ptrs, coding_ptrs, size);</span><br><span class="line">        <span class="built_in">free</span>(tmpids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新生成所有剩下的坏磁盘块 此时应该只有校验盘块需要被修复 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (erased[k + i])</span><br><span class="line">        &#123;</span><br><span class="line">            jerasure_matrix_dotprod(k, w, matrix + (i * k), <span class="literal">NULL</span>, i + k, data_ptrs, coding_ptrs, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(erased);</span><br><span class="line">    <span class="keyword">if</span> (dm_ids != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(dm_ids);</span><br><span class="line">    <span class="keyword">if</span> (decoding_matrix != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(decoding_matrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<ul>
<li>使用随机生成的矩阵模拟磁盘数据，测试解码和编码，结果如下：</li>
</ul>
<p><img src="/post/84dce0b4/image-20221116153502309.png" style="zoom: 50%;"></p>
<ul>
<li>生成指定大小为1G的文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=./data/test.txt of=./data/test_1G.txt count=1 bs=1G</span><br></pre></td></tr></table></figure>
<p>查看生成文件大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./data</span><br><span class="line">ll -h</span><br></pre></td></tr></table></figure>
<p><img src="/post/84dce0b4/image-20221108140018794.png"></p>
<p>在Example文件夹下新建文件<code>a_my_encoder.c</code>和<code>a_my_decoder.c</code>，复制<code>encoder.c</code>和<code>decoder.c</code>中的内容到新建的文件中。修改文件输入算法列表，添加RAID-6的编码和解码算法。并将新建的文件添加到<code>Makefile.am</code>文件中，这样就可以生成可执行文件了。</p>
<p><img src="/post/84dce0b4/image-20221116142442339.png" style="zoom: 50%;"></p>
<p><img src="/post/84dce0b4/image-20221116142512703.png" style="zoom: 50%;"></p>
<ul>
<li><strong>编译：</strong>在项目根目录下使用make编译。</li>
<li><strong>编码：</strong>再进入Example文件夹下，使用RAID-6算法对之前生成的1G文件进行编码，在当前目录的Coding文件夹下生成4个数据块文件、2个校验块文件和1个元数据文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a_my_encoder &#x27;data/test_1G.txt&#x27; 4 2 &#x27;RAID6&#x27; 8 8 1024</span><br></pre></td></tr></table></figure>
<p><img src="/post/84dce0b4/image-20221108141346678.png"></p>
<p><img src="/post/84dce0b4/image-20221108141609282.png"></p>
<ul>
<li><strong>解码：</strong>删掉1个数据文件<code>test_1G_k1.txt</code>，解码出原始文件<code>test_1G_decoded.txt</code>。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a_my_decoder &#x27;data/test_1G.txt&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/post/84dce0b4/image-20221108141949443.png"></p>
<h1 id="任务四-实现rotated-rs编码">任务四 实现Rotated RS编码</h1>
<h2 id="任务-1">任务</h2>
<ul>
<li>给定一个大小为1.5GB的文件的路径，生成由(6,3) Rotated
RS编码得到的数据块和校验块文件（块大小：16MB），并计算编码吞吐量；<br>
</li>
<li>模拟当一个数据节点发生故障，修复该节点上的所有块，计算修复的吞吐量；<br>
</li>
<li>模拟当一个校验节点发生故障，修复该节点上的所有块，计算修复的吞吐量。</li>
</ul>
<h2 id="编码-1">编码</h2>
<p>Rotated RS和标准的RS码相比减少了降级读和修复时的磁盘IO。Rotated
RS编码原理如下：</p>
<p><img src="/post/84dce0b4/image-20221108155336005.png" style="zoom: 67%;"></p>
<p><img src="/post/84dce0b4/image-20221108160607974.png" style="zoom: 50%;"></p>
<p>实现思路：利用上述公式进行编码，将每块磁盘分成 r
块。根据参考论文的实验，(6,3) Rotated RS编码在r=4时效果比较好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotatedrs_encode</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> w, <span class="type">char</span> **data_ptrs, <span class="type">char</span> **coding_ptrs, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> ssize = size / r;  <span class="comment">// size : 一个磁盘块数据的大小</span></span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="type">char</span> *temp_data;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*首先计算第一个校验盘:C0*/</span></span><br><span class="line">  <span class="built_in">memcpy</span>(coding_ptrs[<span class="number">0</span>], data_ptrs[<span class="number">0</span>], size); <span class="comment">// C0 = D0</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++) <span class="comment">// C0 = D0^D1^D2^D3^D4^D5 k=6</span></span><br><span class="line">    galois_region_xor(data_ptrs[i], coding_ptrs[<span class="number">0</span>], size);</span><br><span class="line"></span><br><span class="line">  temp_data = talloc(<span class="type">char</span>, size);</span><br><span class="line">  <span class="comment">/* 按照系数计算剩余的校验盘*/</span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; m; j++)&#123;</span><br><span class="line">    <span class="type">int</span> mid = k * j / m; 						<span class="comment">// 分左右两边不同处理</span></span><br><span class="line">    <span class="built_in">memcpy</span>(coding_ptrs[j], data_ptrs[<span class="number">0</span>], size); <span class="comment">// 初始化校验盘C[j]</span></span><br><span class="line">    <span class="keyword">for</span> (i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; mid)&#123; 							<span class="comment">// 将左边的每个区间的数据按模r偏移</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; r; b++)</span><br><span class="line">        	<span class="built_in">memcpy</span>(temp_data + b * ssize, data_ptrs[i] + ssize * ((b + <span class="number">1</span>) % r), ssize);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> 										<span class="comment">// 右边区间数据保持顺序不变</span></span><br><span class="line">          <span class="built_in">memcpy</span>(temp_data, data_ptrs[i], size);</span><br><span class="line">      <span class="keyword">switch</span> (w) 								<span class="comment">// 将要进行异或的盘块乘以相应的系数 2^&#123;i*j&#125;</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        galois_w08_region_multiply(temp_data, <span class="number">1</span> &lt;&lt; (i * j), size, temp_data, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        galois_w16_region_multiply(temp_data, <span class="number">1</span> &lt;&lt; (i * j), size, temp_data, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">        galois_w32_region_multiply(temp_data, <span class="number">1</span> &lt;&lt; (i * j), size, temp_data, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      galois_region_xor(temp_data, coding_ptrs[j], size); <span class="comment">// 对处理好的盘块数据依次异或</span></span><br><span class="line">    &#125;</span><br><span class="line">    galois_region_xor(data_ptrs[<span class="number">0</span>], coding_ptrs[j], size); <span class="comment">// 异或将初始化的值去除</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="解码-1">解码</h2>
<p>当发生磁盘故障，需要对数据进行修复时，部分情况下Rotated
RS有着更低的IO开销。如下图所示，当Data Disk 0发生故障时，使用Rotated
RS只需要读取16个块，而使用RS需要读取24个块。</p>
<p><img src="/post/84dce0b4/image-20221116144049179.png" style="zoom: 50%;"></p>
<p>实现思路：分别考虑1个数据盘或1个校验盘损坏的情况。</p>
<ul>
<li>在校验盘损坏时，直接使用编码算法重新生成损坏的校验盘。</li>
<li>若数据盘损坏，使用上文提到的解码算法，用两个完好的校验盘恢复数据，减少IO开销。</li>
</ul>
<p>下面详细介绍数据盘的恢复：</p>
<p>因为r=4，需要分别恢复4个磁盘区间的数据，用b=0，1，2，3标记正在恢复的磁盘区间。</p>
<ul>
<li>b=0以及b=2区间，只需要通过第一个校验盘与其他数据盘块对应的区间异或即可恢复，以b=0为例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恢复 b=0 此时系数全为1 只要异或即可</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(data_ptrs[lastdrive], coding_ptrs[j], ssize); <span class="comment">// lastdrive为需要恢复的盘块号</span></span><br><span class="line">    <span class="keyword">for</span> (i = init_id; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == lastdrive) <span class="comment">// 跳过需要恢复的盘块区间</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      galois_region_xor(data_ptrs[i], data_ptrs[lastdrive], ssize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>b=1以及b=3区间，在异或时不仅需要考虑系数，还需要考虑不同盘块异或区间的改变，以b=1为例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恢复 b=1 此时系数为 2^&#123;i*j&#125;</span></span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    mid = k * j / m;</span><br><span class="line">    temp_data = talloc(<span class="type">char</span>, ssize);</span><br><span class="line">    <span class="built_in">memcpy</span>(data_ptrs[lastdrive] + ssize, coding_ptrs[j], ssize); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = init_id; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i == lastdrive) 	<span class="comment">// 跳过需要恢复的块</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; mid) 			<span class="comment">// 左边的使用与恢复区间相同的盘块</span></span><br><span class="line">        <span class="built_in">memcpy</span>(temp_data, data_ptrs[i] + ssize, ssize);</span><br><span class="line">      <span class="keyword">else</span> 					<span class="comment">// 右边的使用上一个盘块</span></span><br><span class="line">        <span class="built_in">memcpy</span>(temp_data, data_ptrs[i], ssize);</span><br><span class="line">      <span class="keyword">switch</span> (w)			<span class="comment">// 乘系数</span></span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        galois_w08_region_multiply(temp_data, <span class="number">1</span> &lt;&lt; (i * j), ssize, temp_data, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        galois_w16_region_multiply(temp_data, <span class="number">1</span> &lt;&lt; (i * j), ssize, temp_data, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">        galois_w32_region_multiply(temp_data, <span class="number">1</span> &lt;&lt; (i * j), ssize, temp_data, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      galois_region_xor(temp_data, data_ptrs[lastdrive] + ssize, ssize); <span class="comment">// 异或</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试-1">测试</h2>
<ul>
<li>使用随机生成的矩阵模拟磁盘数据，测试解码和编码，成功恢复了数据。</li>
</ul>
<p><img src="/post/84dce0b4/image-20221116154223175.png" style="zoom:50%;"></p>
<ul>
<li>编码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a_my_encoder &#x27;data/test_1G.txt&#x27; 6 3 &#x27;Rotate_RS&#x27; 8 8 1024</span><br></pre></td></tr></table></figure>
<p><img src="/post/84dce0b4/image-20221116152132002.png"></p>
<ul>
<li>解码（数据盘）</li>
</ul>
<p>删除文件<code>test_1G_k1.txt</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./a_my_decoder &#x27;data/test_1G.txt&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="/post/84dce0b4/image-20221116152529874.png"></p>
<ul>
<li>解码（校验盘）</li>
</ul>
<p>删除编码文件，重新生成后再删除文件<code>test_1G_m2.txt</code>，解码结果如下：</p>
<p><img src="/post/84dce0b4/image-20221116153016004.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>EC</tag>
        <tag>纠删码</tag>
      </tags>
  </entry>
  <entry>
    <title>2022中科大CS考研面试记录</title>
    <url>/post/7ad1122c.html</url>
    <content><![CDATA[<p>一开始保研失败，被列在候补名单中，只能去专项计划中的北京某高校，反复横跳了好久还是放弃了，然后才从零开始复习，慌得一批，考完觉得应该是陪跑了。寒假都没有复习直接去面试工作，没想到最后居然过了，果然不到最后一刻不能放弃。但是因为初试分比较低，最后踩线录取，感觉用光了半辈子的运气。。。现在记录一下中科大计算机考研复试的面试经历吧，希望对大家能有一点帮助，再给自己攒攒欧气。。。</p>
<span id="more"></span>
<p>因为疫情，今年还是线上面试，不过形式发生了一点点变化，面试前几天突然通知要PPT自我介绍（自我介绍中英文都是可以的，但是实际上面试的时候老师会要求英文的，不然老师怎么打分。。。）。因为原来看经验贴准备了英文自我介绍，所以我用中文做的PPT，然后用英文自我介绍（双保险）。</p>
<h1 id="关于自我介绍ppt">关于自我介绍PPT</h1>
<p>我从四个方面介绍的：学业表现、荣誉与奖项、项目与比赛、研究志向（感兴趣的方向、目标等）。</p>
<h1 id="面试流程">面试流程</h1>
<h2 id="英文提问">英文提问</h2>
<ul>
<li>介绍一下项目</li>
</ul>
<p>看我自我介绍里面提到的项目，就让我用英文介绍一下。这个问题我没怎么准备，就说了数据集，使用的模型等等，实在扯不下去就停了。</p>
<ul>
<li>最喜欢的课程</li>
</ul>
<p>问英文的老师离屏幕很远，没听清问题，就让老师重复了一边，然后终于反应过来是说的是course……那边老师都笑了，哎，尴尬。我终于反应过来以后，说了事先想好的回答：算法设计与分析。然后说了这门课讲了啥，我学到了啥。</p>
<h2 id="专业问题">专业问题</h2>
<p>我说了最喜欢的课是算法设计与分析，然后某个和蔼的老师（可能是面试组的组长）就问我这门课学了什么，我提到了贪心算法，然后继续问我举几个贪心算法的例子，我举了数据结构上最小生成树和哈夫曼编码的例子。继续问最小生成树有哪些算法，我说普利姆算法和克鲁斯卡尔算法，以及具体的原理。他问有向图能否用这个算法，没回答上来……老师语重心长地说要学深入一点，我就嗯嗯，笑笑，说确实。</p>
<p>另一个老师问了项目的细节，比如项目的应用背景，还有数据集来源等等。</p>
<p>最后组长说我回答的不错，还问我成绩这么好为什么没有免试，我就实话实说了，比赛结果出来的比较晚，错过了保研材料提交的时间，最后只在候补名单中，然后下定决定复习考研了。</p>
<h1 id="后记">后记</h1>
<p>祝大家成功上岸！</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>复试</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>高级数据库系统作业3</title>
    <url>/post/18ce3915.html</url>
    <content><![CDATA[<p>记录一下高级数据库系统课程中的作业，作业一般是课堂重点内容或者拓展，认真做的话感觉对课堂内容的理解非常有帮助。</p>
<span id="more"></span>
<h1 id="b树索引优化">B+树索引优化</h1>
<blockquote>
<p>1、假设我们在数据库中设计了如下基本表来存储文献：paper(id: int,
title: varchar(200), abstract:
varchar(1000))。最常见的文献查询可以描述为“查询 title
中同时包含给定关键词的文献”，关键词可以是一个，也可以是多个。请回答下面问题（假设所有文献都是英文文献）：</p>
<p>1）假如在 title 上创建了 B+-tree
索引，能不能提高此查询的效率（须解释理由）？</p>
<p>2）由于文献 title
的关键词中存在很多重复词语，因此上述文献查询可以借鉴我们课上讲述的支持重复键值的辅助索引技术来进一步优化。请基于此思想画出一种优化的索引结构，简要说明该索引上的记录插入过程以及文献查询过程。</p>
</blockquote>
<p><strong>解：</strong>1）如果查询字段上建有B+树索引，查询效率与模糊查询的方式有关。分两种情况：</p>
<p>LIKE
a%：若LIKE中的查询条件是由常量字符串开头的，则B+树索引有效。因为查询时可首先通过B+树的根节点确定字符串所在的子树，并且根据前缀字符串可以继续往下比较，缩小搜索范围。因此，与没有B+树索引时相比，有B+树索引时最后查询的范围可缩小到前缀字符串开头的键值集合，从而提高了查询效率。</p>
<p>LIKE
%a：若LIKE中的查询条件是由通配符开头的，则B+树索引无助于查询效率的提高。因为即使有B+树索引，查询时最坏情况下仍要搜索整个索引和整个记录集合，因为引入了索引查找的额外代价，所以与没有索引时相比，查询效率不但没有提高，反而下降了。</p>
<p>“查询 title 中同时包含给定关键词的文献”的sql语句可以表示为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> paper</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="operator">%</span>keyword1<span class="operator">%</span> <span class="keyword">and</span> title <span class="keyword">LIKE</span> <span class="operator">%</span>keyword2<span class="operator">%</span> <span class="keyword">and</span> ....</span><br></pre></td></tr></table></figure>
<p>除非查询的是开头的关键词，否则无法提高查询效率。</p>
<p>2）使用辅助索引中的间接桶进行优化。如图所示：</p>
<p><img src="/post/18ce3915/index.drawio.svg"></p>
<p><strong>记录插入过程：</strong>当插入一个新的paper记录时，
对其title字段分词，得到多个keyword，如果 keyword
已经存在则将其插入到相应的桶中，如果不存在则创建桶，并将paper的指针写入。</p>
<p><strong>文献查询过程：</strong>假设有n个关键词，先通过辅助索引找出所有关键词的指针集合（即间接桶中的所有元素），然后求指针集的交集，就可以得到包含所有关键词的文献指针，再根据得到的指针去访问外存。如图中所示，假设查询title同时包含keyword2和keyword3的文献，可以根据该方法直接定位到paper3。</p>
<h1 id="散列表">散列表</h1>
<blockquote>
<p><strong>2.</strong> 假设有如下的键值，现用 5
位二进制序列来表示每个键值的 hash 值。回答问题：</p>
<p><strong>A [11001] B [00111] C [00101] D [00110] E [10100] F [01000] G
[00011] </strong></p>
<p><strong>H [11110] I [10001] J [01101] K [10101] L [11100] M [01100] N
[11111]</strong></p>
<p>1） 如果将上述键值按 A 到 N
的顺序插入到可扩展散列索引中，若每个桶大小为一个磁盘块，每个磁盘块最多可容纳
3
个键值，且初始时散列索引为空，则全部键值插入完成后该散列索引中共有几个桶？并请写出键值
E 所在的桶中的全部键值。</p>
<p>2）
前一问题中，如果换成线性散列索引，其余假设不变，同时假设只有当插入新键值后空间利用率大于
80%时才增加新的桶，则全部键值按序插入完成后该散列索引中共有几个桶？并请写出键值
B 所在的桶中的全部键值（包括溢出块中的键值）。</p>
</blockquote>
<p><strong>解：</strong>1）<strong>可扩展散列索引：</strong>全部插入后共有6个桶，E所在桶中的全部键值为：E
[10100],I [10001],K [10101]</p>
<p>插入过程如下：</p>
<p>（1）插入A [11001] B [00111] C [00101] D [00110] E [10100]</p>
<p><img src="/post/18ce3915/h1.svg"></p>
<p>（2）插入F [01000]扩展</p>
<p><img src="/post/18ce3915/h2.svg"></p>
<p>（3）插入G [00011] 扩展</p>
<p><img src="/post/18ce3915/h3.svg"></p>
<p>（4）插入H [11110] I [10001]再扩展</p>
<p><img src="/post/18ce3915/h4.svg"></p>
<p>（5）插入J [01101] K [10101] L [11100] M [01100] N [11111]</p>
<p><img src="/post/18ce3915/h5.svg"></p>
<p>2）<strong>线性散列索引：</strong>插入完成后该散列索引中共有6个桶，B所在桶中全部键值：B
[00111] ，G [00011] ，N [11111]</p>
<p>插入过程如下：</p>
<p><img src="/post/18ce3915/line1.svg"></p>
<p><img src="/post/18ce3915/line2.svg"></p>
<p><img src="/post/18ce3915/line3.svg"></p>
<p>最后：</p>
<p><img src="/post/18ce3915/line4.svg"></p>
<h1 id="压缩b树">压缩B+树</h1>
<blockquote>
<p>3、对于 B+树，假设有以下的参数：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 8%">
<col style="width: 28%">
<col style="width: 8%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>N</em></td>
<td>记录数</td>
<td><em>S</em></td>
<td>读取一个磁盘块时的寻道时间</td>
</tr>
<tr class="even">
<td><em>n</em></td>
<td>B+树的阶，即节点能容纳的键数</td>
<td><em>T</em></td>
<td>读取一个磁盘块时的传输时间</td>
</tr>
<tr class="odd">
<td><em>R</em></td>
<td>读取一个磁盘块时的旋转延迟</td>
<td><em>m</em></td>
<td>在内存的 <em>m</em> 条记录中查找 1 条记录的时间 （线性查找）</td>
</tr>
</tbody>
</table>
<p>假设所有磁盘块都不在内存中。现在我们考虑一种压缩 B+树，即对
B+树的节点键值进行压缩存储。假设每个节点中的键值压缩 1
倍，即每个节点在满的情况下可压缩存储 2<em>n</em>个压缩前的键值和
2<em>n</em>+1
个指针。额外代价是记录读入内存后必须解压，设每个压缩键值的内存解压时间为
<em>c</em>。给定 N 条记录，现使用压缩 B+树进行索引，请问在一棵满的
<em>n</em> 阶压缩 B+
树中查找给定记录地址的时间是多少？（使用表格中的参数表示，<em>n</em>＋1
或 <em>n</em>-1 可近似表示为 <em>n</em>）？</p>
</blockquote>
<p><strong>解：</strong>满n阶B+树非叶节点n个子节点，所以N条记录的B+树深度为<span class="math inline">\(log_n{N}\)</span></p>
<p>未压缩时查找给定记录地址的时间：</p>
<ul>
<li><p>每次查找访问的节点数量 = B+树深度 = <span class="math inline">\(log_n{N}\)</span></p></li>
<li><p>读一个磁盘块的时间 = 寻道时间+旋转延迟+传输时间 = S+R+T</p></li>
<li><p>B+树的非叶子节点大小 = 页大小，读取一页需要一次IO</p></li>
<li><p>查找给定记录地址的IO次数 = 查找时访问的节点数量 =<span class="math inline">\(log_n{N}\)</span></p></li>
<li><p>查找给定记录地址的时间 =
查找时访问的节点数量*（节点内线性查找的时间+节点读入内存时间） = <span class="math inline">\((m+S+R+T)log_n{N}\)</span></p></li>
</ul>
<p>压缩后查找给定记录地址的时间：</p>
<ul>
<li><em>n</em> 阶B+树一个节点存储 <em>n</em> 个键值和 <em>n</em>+1
个指针</li>
<li>键值压缩 1
倍相当于一个节点存储之前的两个节点数据，所以查找时访问的节点数量减半</li>
<li>查找给定记录地址的IO次数 = 查找时访问的节点数量 =<span class="math inline">\(\frac{1}{2}log_n{N}\)</span></li>
<li>节点读入内存后键值解压时间 = 节点中键值数*单个键值的内存解压时间 =
<span class="math inline">\(2n*c\)</span></li>
<li><em>n</em> 阶压缩 B+ 树查找给定记录地址的时间 =
查找时访问的节点数量*（节点读入内存时间+压缩键值的内存解压时间+节点内线性查找的时间）
= <span class="math inline">\((S+R+T+2nc+m)/2*log_n{N}\)</span></li>
</ul>
<p><strong>补充：</strong>B+树的阶n是事先计算得到的，计算的依据是让键值和指针的大小正好等于页的大小。原因如下：</p>
<blockquote>
<p>B+
树在搜索过程中，需要从磁盘IO来读取节点的数据。我们知道磁盘IO一次读取的数据大小为一页。
如果非叶子节点的大小 &gt;
页大小，那么意味着搜索过程中，为了获取一个完整节点来查找数据，我们需要多次IO来获取这个节点，这显然非常消耗时间。所以非叶子节点的大小不能超过一页。
那如果非叶子节点的体积非常小呢？这就意味着B+树的分叉就少，B+树的总节点数会变多、深度变大。B+树利用指针构成的树形结构，意味着每个节点在磁盘上是不连续的，B+树的深度变大了，意味着搜索时访问的节点数量变多，IO次数也变多了。
因此，非叶子节点过大、过小，都会导致IO次数增加。所以最合适的非叶子节点大小
= 页大小。</p>
</blockquote>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://blog.csdn.net/weixin_45457983/article/details/103646162">数据库中可扩展散列索引</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/402951795">B+
树搜索时间复杂度到底是什么：mlogmN / logN？</a></li>
<li><a href="https://blog.csdn.net/wufeifan_learner/article/details/109724836">关于B+树的时间复杂度分析</a></li>
</ul>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>B+树</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>2022中科大CS考研面试问题整理</title>
    <url>/post/5d434990.html</url>
    <content><![CDATA[<p>整理了一些我准备复试中科大面试时的资料，包括自我介绍，英语问题，专业问题以及解答等。</p>
<span id="more"></span>
<h1 id="自我介绍">自我介绍</h1>
<p>一般要准备个3分钟的自我介绍，要有侧重点，比如介绍自己的项目，这样老师问问题就会围绕项目来问，不然老师就会自己问他自己准备的问题了。。。还有时间要控制好，不能太短，不然时间充裕的情况下，后面问的问题就会比较多了。。。当然太长了也不好，自己把握吧。</p>
<p>一般就是从自己的学业表现、荣誉与奖项、项目与比赛、研究志向（感兴趣的方向、目标等）来介绍。</p>
<h1 id="英语口语">英语口语</h1>
<h2 id="问题列表">问题列表</h2>
<ul>
<li><p>大学的课程最喜欢哪门？为什么?</p></li>
<li><p>介绍你的家乡</p></li>
<li><p>你在学DS（某门课程）过程中遇到什么阻碍?</p></li>
<li><p>你觉得最难的科目？</p></li>
<li><p>你说一下什么课程最重要？</p></li>
<li><p>本科什么专业?</p></li>
<li><p>你未来想做什么工作? 未来计划?</p></li>
<li><p>老师先后问从软件工程、操作系统、大数据这三门课程学到什么？</p></li>
<li><p>为什么考USTC?</p></li>
<li><p>你对USTC有什么了解?</p></li>
<li><p>研究生期间有什么计划吗</p></li>
<li><p>听英语翻译成中文：python是一门面向对象的语言</p></li>
<li><p>翻译一下句子 “C语言是一门面向过程的语言” C is a
procedure-oriented language.</p>
<p>C primer plus is an object-oriented language.</p></li>
<li><p>网络的质量有哪些指标评价（英语问的）</p></li>
<li><p>介绍一下自己的学校</p></li>
<li><p>介绍自己的本科城市</p></li>
<li><p>用英语介绍一下毕设</p></li>
<li><p>用英语介绍一下你的项目</p></li>
<li><p>你说一下你课程中做过的设计</p></li>
<li><p>介绍一下自己的获奖经历</p></li>
<li><p>说一下你参加过的比赛</p></li>
<li><p>你提到你获过一些荣誉，这些荣誉分别是什么级别的？</p></li>
<li><p>你的专业排名是多少？</p></li>
<li><p>你怎么理解团队精神?</p></li>
<li><p>如何描述自己?</p></li>
<li><p>喜欢读什么书?</p></li>
</ul>
<p>如果自我介绍中没有提到的或者没有讲清楚的，一般老师就会往这个方向问。</p>
<h2 id="部分回答">部分回答</h2>
<p>下面是我当时准备的一些回答：</p>
<h3 id="介绍家乡">介绍家乡</h3>
<ul>
<li>Could you give me a brief introduction about your hometown？</li>
</ul>
<blockquote>
<p>Hefei, the capital of Anhui Province, is an ancient city with a
history of more than 2,000 years and a new city that flourished after
the birth of New China.</p>
<p>In ancient times, Hefei is also known as Luzhou, which is the
hometown of Bao Zheng.</p>
<p>Nowadays, Hefei is a city where industry, science and education go
hand in hand.</p>
<p>It is also a nice place to live in, because has four distinct seasons
and a mild climate.</p>
</blockquote>
<h3 id="学习相关">学习相关</h3>
<ul>
<li>Which course do you like best? And why?</li>
</ul>
<blockquote>
<p>My favorite course is design and analysis of algorithms.</p>
<p>It introduces some advanced concepts and algorithms, such as dynamic
programming, Greedy algorithm. I become familiar with fundamental data
structures and the description of algorithms in both functional and
procedural styles. The teacher has a strong responsibility.Besides, it
stimulated my interest in programming, and helped me learn a lot of
practical skills.</p>
</blockquote>
<ul>
<li>What do you think is the hardest subject? Which subject do you think
is the most difficult?</li>
</ul>
<blockquote>
<p>The Principle of Computer Organization. It is difficult for me to
understand how hardware is running.</p>
</blockquote>
<ul>
<li>What course do you think is the most important?</li>
</ul>
<blockquote>
<p>I think the most important course is data structure. Just like a car
mechanic needs the right tool to fix a car and make it run properly, a
programmer needs the right tool (algorithm and data structure) to make
the software run properly.</p>
</blockquote>
<ul>
<li>Where did your grades rank in your major?</li>
</ul>
<blockquote>
<p>I exactly ranked 17th among 170 students of the same major.</p>
</blockquote>
<h3 id="考研目标">考研目标</h3>
<ul>
<li>Why did you choose our university/USTC?</li>
</ul>
<blockquote>
<p>The University of Science and Technology of China (USTC) is a
prominent university in China and enjoys an excellent reputation
worldwide.</p>
</blockquote>
<ul>
<li>What do you know about USTC?</li>
</ul>
<blockquote>
<p>I was initially attracted by your university’s high reputation. After
consulting with several friends who have studied at your university, I
was even more impressed by the university’s strong academic atmosphere
and the professors’ sense of responsibility, and all of which
strengthened my determination to continue my studies at your
university.</p>
</blockquote>
<ul>
<li>Why do you choose to further your study instead of going to work
after graduation?</li>
</ul>
<blockquote>
<p>During my undergraduate studies in the past there and half years, I
gradually realized that the knowledge and skills that acquired in
college would not enough to fulfill my personal goals in society.
Moreover, my desire for knowledge grew as I dug deeper into some fields,
such as machine learning. Therefore, I feel it’s necessary for me to
further my study instead of going to work after graduation.</p>
</blockquote>
<ul>
<li>What is your plan in the postgraduate study?</li>
</ul>
<blockquote>
<p>Firstly, I will work hard to learn theoretical knowledge,
constructing a solid foundation for my further study; Secondly, I would
like to do some practical work. Through this, I can get some skills that
cannot be acquired from the textbooks. I hope that in the next three
years, I can improve my ability of learning and independent thinking,
and have valuable academic outputs. If possible, I am also willing to
fight for a Doctor’s Degree.</p>
</blockquote>
<h3 id="本科院校">本科院校</h3>
<ul>
<li>Please introduce your university.</li>
</ul>
<blockquote>
<p>My university is XXXX University.</p>
<p>The school management is very student friendly; a range of campus
activities are available; The teachers there are also well qualified and
helpful. They adopt a teaching style of free exploration, and often
arrange seminar for us to broaden our knowledge and perspective. I think
the most distinctive rule is that every student must learn to swim or
they can’t get their diploma. I really appreciate the resources and
opportunities provided by our university.</p>
</blockquote>
<h3 id="实践经历">实践经历</h3>
<ul>
<li>What projects did you do at university?</li>
</ul>
<blockquote>
<p>My graduation project is XXXX. The purpose of this project is to
....</p>
</blockquote>
<h3 id="专业词汇">专业词汇</h3>
<ul>
<li>课程名称</li>
</ul>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 63%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th><strong>名称</strong></th>
<th><strong>英文</strong></th>
<th><strong>分数</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算法设计与分析</td>
<td><em>Design and Analysis of Algorithms</em></td>
<td>95</td>
</tr>
<tr class="even">
<td>数字图像处理</td>
<td><em>Digital Image Processing</em></td>
<td>81</td>
</tr>
<tr class="odd">
<td>模式识别</td>
<td><em>Pattern Recognition</em></td>
<td>91</td>
</tr>
<tr class="even">
<td>实用计算机英语</td>
<td><em>Practical Computer English</em></td>
<td>90</td>
</tr>
<tr class="odd">
<td>大数据技术基础</td>
<td><em>Big Data Techniques</em></td>
<td>90</td>
</tr>
<tr class="even">
<td>线性代数</td>
<td><em>Linear Algebra</em></td>
<td>89</td>
</tr>
<tr class="odd">
<td>离散数学</td>
<td><em>Discrete Mathematics</em></td>
<td>91 94</td>
</tr>
<tr class="even">
<td>数据结构</td>
<td><em>Data structure</em></td>
<td>90 77</td>
</tr>
<tr class="odd">
<td>编译原理</td>
<td><em>Compiler Principle</em></td>
<td>88</td>
</tr>
<tr class="even">
<td>操作系统</td>
<td><em>Operating System</em></td>
<td>88 88</td>
</tr>
<tr class="odd">
<td>数据库原理</td>
<td><em>The Principle of Database System</em></td>
<td>82 85</td>
</tr>
<tr class="even">
<td>软件工程</td>
<td><em>Software Engineering</em></td>
<td>85</td>
</tr>
<tr class="odd">
<td>计算机组成原理</td>
<td><em>The Principle of Computer Organization</em></td>
<td>69 85</td>
</tr>
<tr class="even">
<td>计算机网络</td>
<td><em>Computer Networks</em></td>
<td>88</td>
</tr>
<tr class="odd">
<td>面向对象程序设计</td>
<td><em>Object Oriented Programing</em></td>
<td>93</td>
</tr>
<tr class="even">
<td>计算机系统结构</td>
<td><em>Computer Architecture</em></td>
<td>88</td>
</tr>
</tbody>
</table>
<ul>
<li>热门研究方向</li>
</ul>
<table>
<thead>
<tr class="header">
<th>分布式计算</th>
<th><em>distributed computation</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>物联网</td>
<td><em>Internet of things</em></td>
</tr>
<tr class="even">
<td>大数据</td>
<td><em>Big data</em></td>
</tr>
<tr class="odd">
<td>人工智能</td>
<td><em>Artificial intelligence</em></td>
</tr>
<tr class="even">
<td>高性能计算</td>
<td><em>High performance computing</em></td>
</tr>
<tr class="odd">
<td>云计算</td>
<td><em>Cloud computing</em></td>
</tr>
<tr class="even">
<td>嵌入式计算</td>
<td><em>Embedded computing</em></td>
</tr>
<tr class="odd">
<td>并行</td>
<td><em>Parallel</em></td>
</tr>
<tr class="even">
<td>机器学习</td>
<td><em>Machine learning</em></td>
</tr>
<tr class="odd">
<td>数据挖掘</td>
<td><em>Data mining</em></td>
</tr>
<tr class="even">
<td>计算机视觉</td>
<td><em>Computer vision</em></td>
</tr>
<tr class="odd">
<td>网络安全</td>
<td><em>Cyber security</em></td>
</tr>
</tbody>
</table>
<ul>
<li>专业词汇</li>
</ul>
<table>
<thead>
<tr class="header">
<th>面向对象编程语言</th>
<th><em>Object-oriented programming language</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>编译器</td>
<td><em>Compiler</em></td>
</tr>
<tr class="even">
<td>关系型数据库</td>
<td><em>Relational Database</em></td>
</tr>
<tr class="odd">
<td>动态规划</td>
<td><em>Dynamic Programming</em></td>
</tr>
<tr class="even">
<td>贪婪算法</td>
<td><em>Greedy Algorithms</em></td>
</tr>
<tr class="odd">
<td>分治</td>
<td><em>Divide and conquer</em></td>
</tr>
</tbody>
</table>
<h1 id="专业问题">专业问题</h1>
<p>基本原则是：科大重视本科成绩单，重视对知识的应用理解，面试经验只作参考，请勿死记硬背。一般老师会先问你擅长哪些科目，然后会提问你擅长科目的一些问题。科班的话有的组还会问编译原理数据库离散数学啥的。我是根据自己本科学过的课程以及408准备的，结果就问了我数据结构里面排序和图的知识。</p>
<h2 id="程序设计">程序设计</h2>
<ul>
<li><p>C和C++的区别与联系?
联系：C++是C的超集，兼容大部分C的语法的结构。区别：C面向过程，C++面向对象。C和C++动态管理内存的方法不一样，C是使用malloc/free函数，而C++除此之外还有new/delete关键字。C++添加了类、函数重载、引用等新的语法。</p></li>
<li><p>面向对象与面向过程的区别？面向过程分析问题的解决步骤，然后用函数把这些步骤实现，在一步一步按顺序调用函数。面向对象将问题抽象成一个一个对象，每个对象都有各自的功能和属性，通过提供的功能接口解决问题。</p></li>
<li><p>面向对象的三大特性/三个基本特征：封装、继承、多态</p></li>
<li><p>跨平台性？即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。</p></li>
<li><p>C++多态是什么，有什么优点？多态以封装和继承为基础，静态多态（编译期）：函数重载、运算符重载、模板；动态多态（运行期）：虚函数。进行代码复用，提高了程序的可扩展性。</p></li>
<li><p>动态多态的三个条件是什么? 继承，方法重写，父类
引用指向子类的对象。</p></li>
<li><p>C++中的代码复用机制？<strong>继承</strong>：子类继承父类中的成员变量和函数；<strong>组合：</strong>一个类将另一个类的对象作为其成员<strong>；</strong>多态：<strong>模板</strong>（类模板和函数模板）<strong>。</strong></p></li>
<li><p>虚函数有什么用？用于多态的实现。</p></li>
<li><p>继承和组合的区别？一个类将另一个类的对象作为其成员称为组合；一个类将另一个类作为其父类称为继承。继承与组合都是面向对象中代码复用的方式。在继承中，父类的内部细节对子类可见，其代码属于<strong>白盒式的复用</strong>，而组合中，对象之间的内部细节不可见，其代码属于<strong>黑盒式复用</strong>。继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。继承强调的是<strong>is-a</strong>的关系，而组合强调的是<strong>has-a</strong>的关系。</p></li>
<li><p>重载和覆盖的区别？重载要求函数名相同，但是参数列表必须不同；覆盖要求函数名、参数列表、返回值必须相同。
重载描述的是同一个类中不同成员函数之间的关系；覆盖是子类和基类之间不同成员函数之间的关系。
重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。</p></li>
<li><p>C++头文件和命名空间？头文件用于预编译，命名空间是防止变量名重复。</p></li>
<li><p>extern？</p></li>
<li><p>inline?
声明内联函数，原地展开，不需要调用函数，以空间换时间。</p></li>
<li><p>struct 和class区别联系？struct
更适合看成是一个数据结构的实现体，class
更适合看成是一个对象的实现体。最本质的一个区别就是默认的访问控制，struct
是 public 的，class 是 private 的。</p></li>
<li><p>const的用法？修饰普通变量、成员函数、成员函数参数。</p></li>
<li><p>static的用法？static
修饰的<strong>静态全局变量</strong>的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问。static
修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static
修饰的<strong>静态局部变量</strong>只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。static
修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。未被初始化的变量自动初始化为
0。</p></li>
<li><p>C的union和struct的区别？一个 union
可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。节省空间。</p></li>
<li><p>C语言里面main函数有什么参数？int argc, char ** argv。
分别有什么作用？argc
是指命令行输入参数的个数，argv存储了所有的命令行参数。</p></li>
<li><p>编译的含义；C语言我写的十行代码只有1k，为啥编译之后目标文件有几百k?</p></li>
<li><p>传值和引用的区别，指针和引用的区别，那在作为函数形参的时候，两者有什么区别呢？</p></li>
<li><p>函数调用过程，传地址为什么实参会发生改变？还有哪些变量是可变的，哪些不可变，这些对编程有什么作用？</p></li>
<li><p>C++中的值传递和引用传递的区别，在汇编语言上是相同的吗？</p></li>
<li><p>值传递与地址传递？</p></li>
<li><p>C语言怎么统计一个函数被调用次数？<strong>全局变量</strong>或者<strong>函数内的静态局部变量</strong>作为计数器。</p></li>
<li><p>给你两个变量，要求在不使用第三个变量的情况下交换这两个变量的值？不用额外空间实现两个变量值互换？</p>
<blockquote>
<p>1：a = a + b ; b = a – b; a = a – b ；但可能会溢出</p>
<p>2：a = a ^ b ; b = a ^ b; a = a ^ b；三次异或</p>
</blockquote></li>
<li><p>内存泄漏和内存溢出是什么？内存溢出：存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用；而内存泄露：程序运行分配的对象回收不及时甚至于没有被回收。内存泄漏堆积后的后果就是内存溢出。</p></li>
<li><p>内存溢出原因?
代码中存在死循环或循环产生过多、未及时回收内存导致内存泄露，进而导致内存溢出、参数值设定过小（比如数组大小）；</p></li>
<li><p>内存泄露怎么解决？及时回收内存，申请与释放要成对出现。</p></li>
<li><p>解释下C语言中局部变量和全局变量?
在函数或块内部（循环体内等）的局部变量；在所有函数外部的全局变量。全局变量保存在内存的全局/静态存储区（保存静态变量和全局变量）；局部变量保存在栈区，只有在所在函数被调用时才动态地为变量分配存储单元。</p></li>
<li><p>C语言中局部变量以及其存储位置？保存在栈区。</p></li>
<li><p>C语言里面全局变量与静态变量？</p></li>
<li><p>C语言内存分配结构有哪几个区，静态变量在什么区，局部变量属于什么区？</p></li>
<li><p>C语言的内存相关操作处理，尤其是缓冲区异常操作处理？</p></li>
<li><p>C语言异常的关键字？try catch</p></li>
<li><p>递归函数的优缺点?</p></li>
<li><p>动态链接和静态链接?
静态链接是由链接器在链接时将库的内容<strong>加入</strong>到可执行程序中的做法（生成的可执行文件体积较大，包含相同的公共代码，造成浪费）。动态链接把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。这里的库指的是动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p></li>
<li><p>.h与
.cpp的区别？头文件和源文件。头文件声明，源文件定义。把声明放到头文件中方便引用。</p></li>
</ul>
<h2 id="数据结构">数据结构</h2>
<h3 id="线性表">线性表</h3>
<ul>
<li><p>如何快速找到一个单链表的三分之一处？</p></li>
<li><p>数组做增减不方便，还有其他数据结构吗？链表。</p></li>
<li><p>循环链表队列只设置一个指针，应该放在头还是尾？尾指针是指向终端结点的指针，用它来表示单循环链表可以使得查找链表的开始结点和终端结点都很方便；放在尾部，入队O(1)，出队O(1);
放在头部，入队O(n)，出队O(n)</p></li>
<li><p>线性表的顺序结构是什么存储方式?顺序存取的方式，存储在连续的物理空间中。</p></li>
</ul>
<h3 id="二叉树">二叉树</h3>
<ul>
<li><p>二叉树里面有多少个空指针？n个节点的话，每个节点都有两个指针，共2n个，出来根节点以外，n-1个节点都被指针指向，所以是n+1个空指针。</p></li>
<li><p>有什么方法可以加快二叉树的查询？线索二叉树.。</p></li>
<li><p>用数据建立一棵排序二叉树？</p></li>
<li><p>二叉排序树查找的时间复杂度，如果是平衡二叉树又是什么？</p>
<blockquote>
<p>答：平均查找长度为O(log n)，最坏情况下变成斜二叉树，O(n);
平衡二叉树左右子树高度差不超过1，平均查找长度为O(log n)</p>
</blockquote></li>
<li><p>二叉排序树是什么，删除一个节点怎么操作?</p>
<blockquote>
<p>答：左子树上所有值小于根节点值，右子树所有值大于根节点的值；删除：分三种情况，叶子节点；左子树为空，用右孩子节点填充；右子树为空，用左孩子填充；左右节点都存在，从右子树上找中序第一个孩子填充。</p>
</blockquote></li>
<li><p>二叉查找树，改进的AVL平衡树，怎么进行调整？答：四种旋转方式，LL,RR,LR,RL</p></li>
<li><p>哈夫曼编码以及应用?
答：哈夫曼编码得到总长度最短的二进制前缀编码；用于数据的压缩和解压。</p></li>
<li><p>什么树是哈夫曼树?答：带权路径长度最小的二叉树成为哈夫曼树。</p></li>
<li><p>哈夫曼树，哈夫曼编码，为什么哈夫曼树权值最小，属于什么算法？答：贪心算法。只要把权值小的叶子节点，放在更低的层次，就可以使总的带权路径长度最小。</p></li>
<li><p>可变长度编码：出现频率高的使用短编码，频率低的使用长编码。</p></li>
<li><p>前缀编码：需要保证长编码不与短编码冲突。</p></li>
<li><p>哈夫曼怎么保证编码不冲突？所有带有权值的节点都被构造为了叶子节点，从根节点开始走到叶子节点而得出的编码就不会出现一个编码是另一个编码的前缀的情况。</p></li>
<li><p>设计一种数据结构以及相关的操作来找出树叶子结点的个数？队列，层序遍历。</p></li>
<li><p>怎么统计二叉树有几个结点？遍历。</p></li>
<li><p>树的深度优先遍历和广度优先遍历分别用了什么数据结构？为什么要用栈跟队列？栈，队列。</p></li>
</ul>
<h3 id="图">图</h3>
<ul>
<li><p>最小生成树算法?答：普里姆、克鲁斯卡尔</p></li>
<li><p>对这两个算法做比较，以及这两个算法采用的数据结构是哪些？</p>
<blockquote>
<p>普里姆算法：选择一个与当前顶点集合距离最近的顶点加入集合。时间复杂度O(|v|^2),适用于边稠密图。数据结构：小顶堆</p>
<p>克鲁斯卡尔算法：选择最短的边，判断加入图中是否成环，如果不成环加入，否则判断下一个。时间复杂度O(|E|
log |E|)，适用于顶点稠密图。数据结构：并查集</p>
</blockquote></li>
<li><p>迪杰斯特拉除了迪杰斯特拉算法还有啥？</p>
<blockquote>
<p>迪杰斯特拉是荷兰人。</p>
<p>提出“goto有害论”;
与另外两个科学家合著的《结构化程序设计》影响了此后大部分程序设计语言，包括
C 和 Pascal。</p>
<p>提出信号量和PV原语; 首先定义了互斥和死锁的概念并提出了解法。</p>
<p>提出了银行家算法。他发表的关于并发程序控制的论文开创了分布式计算和并发计算的领域。</p>
<p>创造Dijkstra最短路径算法;</p>
</blockquote></li>
<li><p>权值都为1的图 怎样得到两个顶点的距离？广度优先遍历。</p></li>
<li><p>给你一个所有路径权值相等的图，你要怎么来求它的单源最短路径？广度优先遍历。</p></li>
<li><p>找无向无权图的两点之间最短路径有哪些方式？广度优先遍历，迪杰斯特拉算法。</p></li>
<li><p>N 顶点的完全图 用深度和广度优先遍历所得到的
生成树的度分别是多少？广度优先遍历: N-1; 深度优先遍历：2</p></li>
<li><p>完全图用DFS和BFS生成的生成树的高度差？DFS: N, BFS:2</p></li>
<li><p>怎么判断有向图有没有回路?</p>
<blockquote>
<p><strong>拓扑排序</strong>：能生成拓扑序列则说明无回路，否则有回路；</p>
<p><strong>深度优先遍历</strong>：一条深度遍历路线中如果有结点被第二次访问到，那么有环；并查集。</p>
</blockquote></li>
<li><p>DFS路径唯一吗？图的邻接矩阵表示唯一，但是图的邻接表表示不唯一；所以基于邻接矩阵遍历的DFS路径和BFS路径唯一，基于图的邻接表则不唯一。</p></li>
<li><p>无向连通图最多几条边，最少几条?最多：完全图，最少：n-1条。</p></li>
<li><p>图的存储方式有哪些?邻接矩阵和邻接表分别用于什么样的图?</p></li>
<li><p>说一下图的两种存储方式以及增删结点的过程。邻接矩阵：增加或者删除节点不方便，要修改整个数组。邻接表：增加删除节点方便。</p></li>
<li><p>无向图、有向图的组织结构是怎样的？（即是怎么存储的）</p></li>
<li><p>深度优先遍历的序列确定，如果确定好了存储方式，假如选定好具体的邻接矩阵和邻接表，遍历的序列还唯一吗，唯一。</p></li>
<li><p>讲讲强连通分量和强连通分量结点？强连通：在有向图G中，如果两个顶点v1,v2有一条从v1到v2的有向路径，同时还有一条从v1到v2的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。连通分量：有向图的极大强连通子图。</p></li>
<li><p>围棋棋盘可以用什么数据结构来实现？二维数组（？？？）</p></li>
</ul>
<h3 id="查找">查找</h3>
<ul>
<li><p>折半查找过程+复杂度？折半查找适用于有序的顺序表，O(log
n)</p></li>
<li><p>二分查找的时间复杂度和适用范围？必须是有序的顺序表。不适用于链式存储的数据。</p></li>
<li><p>二分查找的条件，链式结构要如何二分查找？必须是有序的顺序表。</p></li>
<li><p>什么是分块查找？复杂度?</p></li>
<li><p>哈希表的功能？根据关键字得到存储地址</p></li>
<li><p>哈希表存在的问题？关键字得到存储地址相同，冲突</p></li>
<li><p>哈希表
解决冲突的方法？开放地址法（线性探测，二次探测，再散列）；拉链法。</p></li>
<li><p>开放地址法如何删除关键字？做个标记逻辑删除，直到有下一个元素插入才能将其物理删除。</p></li>
<li><p>那之后再插入新的关键字遇到之前逻辑删除的那个空间如何处理？替换成新插入的元素。</p></li>
<li><p>最快的查找算法？二分查找（折半查找、二叉排序树）。</p></li>
</ul>
<h3 id="排序">排序</h3>
<ul>
<li><p><strong>快速排序</strong>的原理?
基于分治法，在排序表上任意取一个元素作为基准，通过一趟排序将排序表分为两个部分，左边部分小于这个基准，右边部分大于这个基准，将这个基准元素放在中间的位置，这个位置就是基准最终的位置，然后递归调用，分别对左边和右边的元素重复上述步骤，直到每个部分只有一个元素或者为空。</p></li>
<li><p>快速排序最好时间复杂度: O(n log n) 每次划分都能平衡划分</p></li>
<li><p>最坏情况时间复杂度？O(n2) 每次划分都分成0，n-1;</p></li>
<li><p>快排平均时间复杂度的系数：1.39。</p></li>
<li><p>为什么快排最后要退化成O（n²）还叫快排？
快排比较的基本都是邻近的元素，cache局部性较好。</p></li>
<li><p>为什么快排平均性能最好？快排比较的基本都是邻近的元素，cache局部性较好，所以是内部排序中平均性能最好的。堆排比较的几乎都不是相邻元素，对cache极不友好。归并排序空间复杂度O(n),
适用于外部排序。</p></li>
<li><p>有没有什么排序平均比快排要快的？基数排序。线性时间复杂度。</p></li>
<li><p>快排如何提高效率？https://blog.51cto.com/u_15127595/4213608</p>
<blockquote>
<p>a.主元的选取随机化，可以降低快排达到最坏时间复杂度的可能性。</p>
<ol start="2" type="a">
<li><p>三数取中。在a[l],a[( l + r
)/2],a[r]三个数中选取中间大的数作为主元，比主元的随机化更有优势。</p></li>
<li><p>减小递归的栈深度——小区间优化。在子区间的长度小于16时，进行插入排序，减小递归的栈深度。</p></li>
</ol>
</blockquote></li>
<li><p>最坏情况时间复杂度，什么情况是最坏的，那在这种最坏的情况怎么样做可以提高效率?主元随机化。三数取中。</p></li>
<li><p>标准库中的sort，是通过先快排，递归深度超过一个阀值就改成堆排，然后对最后的几个进行插入排序来实现的。</p></li>
<li><p>常用的排序有哪些？答：快速排序，堆排序，归并排序。</p></li>
<li><p>时间复杂度为O(n log n) 且与初始排列无关的排序有哪些？
堆排序，归并排序</p></li>
<li><p>基于比较的排序算法的下界？对于待排序的n个元素，其所有可能的排序种数为
n!。决策树 log n!，渐进下界 (n log n)。</p></li>
<li><p>堆排序过程？建堆：从序号为n/2的结点向0调整，自上向下调整。全部调整后，根节点的值即为最小/大值。</p></li>
<li><p>堆排序插入元素？插入到序列的最后，向上调整。</p></li>
<li><p>堆排序删除元素？将根节点与最后的结点交换，然后从根节点向下调整。</p></li>
<li><p>说一下堆排序复杂度？空间复杂度：O(1)；时间复杂度：主要在初始化堆过程和每次选取最大数后重新建堆的过程。建堆时间：O(n);
更改堆元素后重建堆时间O(n log n)。</p></li>
<li><p>稳定性排序算法和不稳定排序算法各举一例。稳定：归并排序，不稳定：快速排序、堆排序。</p></li>
<li><p>给你一堆无序的数据，如何才能高效的找到其中间值？找第k大的值，k=n/2。快速排序，堆排序。</p></li>
<li><p>既然基数排序是线性的，为什么很多数据的时候不选择基数排序?</p></li>
<li><p>如何评价快排和基数排序?</p></li>
</ul>
<ol type="a">
<li><p>基数排序的时间复杂度看似O(n)，但它每次排序都是对整个数组的处理，相对快排来讲，cache局部性不好。</p></li>
<li><p>基数排序一般需要额外的存储空间：顺序队列实现需要O(n)的元素空间，链队列实现需要O(n+2d)个指针空间，计数实现也需要O(n)的元素空间。</p></li>
<li><p>对于要排序的数据要求严格</p></li>
</ol>
<ul>
<li><p>B树在实际应用中为什么会设置很大的阶数，如1000阶？B树的应用：数据库和文件系统。它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少硬盘操作次数。B树算法设置很大的阶数，层数就会变少，减少磁盘读取次数，从而加快存取速度。</p></li>
<li><p>B+树的应用:
MySQL使用B+树作为索引。关键字和记录分开，非叶子节点不存储数据，节点小，磁盘I/O次数就少。可以顺序查找，也可以索引查找。</p></li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li><p>数据结构的逻辑结构有哪些？集合结构、线性结构、树状结构和网络结构</p></li>
<li><p>KMP算法相关，为何相比常规会有优化</p></li>
</ul>
<h2 id="计算机组成原理">计算机组成原理</h2>
<ul>
<li><p>组成原理与微机原理、计算机体系结构的区别?
组成原理是让你从整体上介绍计算机是怎么工作的，内容上侧重于计算机的几大组成；计算机体系结构是对组成原理的抽象化与进一步的理论化，考虑的是软硬件的功能分配。微机原理是计算机组成的具体实现，一般选择某个架构的计算机具体介绍，比如CPU的具体结构，引脚作用，寄存器每个位的作用，偏硬件。</p></li>
<li><p>计算机组成、计算机结构、计算机技术，谈谈你对这三者的理解？</p></li>
<li><p>什么是指令系统？指令系统是指计算机所能执行的全部指令的集合。</p></li>
<li><p>CISC和RISC是什么？两个的具体应用举个例子？8086是哪个？CISC: x86.
RISC: MIPS, ARM. X86架构于Intel 8086 中央处理器中首度出现,
成为了个人计算机的标准平台，成为了历来最成功的 CISC 架构.</p></li>
<li><p>说一下RISC是什么？以及RISC/CISC的区别？</p></li>
<li><p>说说指令流水线？指令流水线是为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式。</p></li>
<li><p>计算机最高几级流水线？？</p></li>
<li><p>超长指令字？编译程序挖掘并行性，将多条并行的指令组合成一条多个操作码字段的超长指令字，需要多个处理部件。</p></li>
<li><p>超标量流水线？一个时钟周期并行执行多条指令，需要多个功能部件。编译优化，提高指令并行度。</p></li>
<li><p>超流水线技术？一个时钟周期再分段，一个时钟周期内一个功能部件使用多次。</p></li>
<li><p>乱序发射 与乱序执行？</p></li>
<li><p>分支指令的CPU处理全过程，用到了CPU里哪些部件？PC记录下一条指令地址，IR,
MAR , ALU，ACC</p></li>
<li><p>怎么解决分支指令在流水线里的控制相关?对转移指令进行分支预测，尽早生成转移目标地址。两手准备（预取成功和不成功两种控制流方向上的目标指令）</p></li>
<li><p>流水线什么时候可以中断？</p></li>
<li><p>I/O阻塞和I/O非阻塞的区别？阻塞：需要等待I/O完成以后才能做别的事情。</p></li>
<li><p>通道？简化版CPU,
主机执行I/O命令时，启动相关通道，让通道去执行通道程序。</p></li>
<li><p>DMA和中断的区别是什么?中断是程序的切换，需要保护和恢复现场，DMA只有在处理前和处理后才需要CPU干预。中断只能在一条指令执行结束以后才能响应，DMA可以在每个机器周期结束时响应。中断传送过程中需要CPU响应，DMA传输过程中不需要CPU干预，可以快速传输大量数据。中断还有对异常事件的处理能力等，靠程序传送，DMA只是传送数据块，靠硬件传送。</p></li>
<li><p>DMA在预处理阶段的工作？I/O设备向DMA发送请求，DMA向CPU发送总线请求。</p></li>
<li><p>说说中断？【中断的过程】单级中断：中断源发出中断请求，中断判优，CPU响应中断（关中断，保存断点，引出中断服务程序），中断服务程序（保存现场和屏蔽字、执行、恢复现场），开中断，中断返回。</p></li>
<li><p>中断上下文内容保存在哪里？用户可见的工作寄存器内容，保存在栈中。</p></li>
<li><p>中断屏蔽字存放到哪里？中断屏蔽字被存储在CPU里面的中断屏蔽字寄存器中。</p></li>
<li><p>中断优先级如何处理？硬件实现：硬件排队器。软件实现：查询程序。</p></li>
<li><p>中断保护机制，进程死循环时怎么办？</p></li>
<li><p>计算机存储有哪些层次？</p></li>
<li><p>TLB，Cache的作用？</p></li>
<li><p>局部性是什么？什么时候存在时间局部性什么时候存在空间局部性，举例一下</p></li>
<li><p>之后就问那在设计计算机的指令集硬件什么的方面如何使用局部性</p></li>
<li><p>老师就问cache的映射算法有什么？全相联映射、直接映射、组相联映射</p></li>
<li><p>cache的读取写入策略有什么？写命中：写回法、写直通法；写不命中：写分配、非写分配。</p></li>
<li><p>cache命中率和什么有关？cache容量、cache块、映射方法、替换算法。</p></li>
<li><p>cache命中率和cache的容量有什么关系？容量越大，命中率越高。</p></li>
<li><p>cache命中率和cache块的大小有什么关系？对于给定的Cache容量，当块大小增加时，命中率开始时处于上升趋势，后来反而会下降。因为程序局部性原理，增加块大小增加了利用空间局部性的机会；另一方面，在容量一定情况下，增加块大小会减少总的块数目，会增加冲突失效。</p></li>
<li><p>cache里LRU怎么实现？</p></li>
<li><p>虚拟存储和高速缓存的结构和各自的作用?</p></li>
<li><p>Cache与虚拟存储器的不同？cache是为了解决系统速度问题，虚拟存储器是为了解决主存容量不够的问题。Cache有硬件实现，对所有程序员透明，虚拟存储器是由OS和硬件共同实现，对应用程序员透明。Cache不命中可直接访问内存，但是虚拟存储器不命中只能调入主存后再访问，对性能影响更大。</p></li>
<li><p>所谓的命中率是什么?访问cache有效的次数除以总次数。</p></li>
<li><p>指令执行的步骤有哪些?取指、译码、访存、执行、写回</p></li>
<li><p>微程序控制器的原理？一条指令分为多个执行步骤，每个步骤对应一段操作，把这个操作作为一段微程序存入控制存储器，这样执行的时候就可以通过查询控制存储器生成操作信号序列。</p></li>
<li><p>指令周期的阶段？取指周期，间指周期（取操作数），执行周期，中断周期。</p></li>
<li><p>每个阶段什么时候可以有中断？中断只能在一条指令执行结束（中断周期）以后才能响应。</p></li>
</ul>
<h2 id="操作系统">操作系统</h2>
<ul>
<li><p>操作系统有什么功能？对计算机资源管理。进程管理（处理机资源）、存储器管理、文件管理、设备管理。</p></li>
<li><p>系统调用？操作系统向用户提供的一系列接口，凡是与计算机资源有关的操作，用户必须通过系统调用向操作系统提出服务请求，让操作系统代为处理。</p></li>
<li><p>库函数？部分库函数是对系统调用的封装，部分库函数不使用系统调用。</p></li>
<li><p>系统调用和函数调用谁的开销大？普通的函数调用一般只需要几次寄存器操作，如果有参数的话，再进行几次用户栈操作，用户栈局部性较好，可能也不需要进行内存I/O。而系统调用要先从用户态切换到内核态，内核态的栈用的是内核的栈，所以还要进行栈的切换，一定程度上会破坏程序局部性，所以导致cache、TLB缓存命中率都可能下降。还有额外的权限校验、有效性检验等，导致系统调用开销更大。</p></li>
<li><p>系统调用和函数调用哪个速度快？上题。</p></li>
<li><p>操作系统里线程的类别，底层怎么实现的？用户级线程：线程的管理由应用程序完成；内核级线程：线程的管理由内核完成。组合形式。</p></li>
<li><p>实时系统和Windows的分时系统有什么区别，在硬件上呢？实时系统：保证高可靠性；分使系统：用户交互。</p></li>
<li><p>Linux虚拟地址空间？执行一个程序时，操作系统创建一个独立的虚拟地址空间，但是并不设置与物理内存的映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置；虚拟地址空间通常与操作系统的位数有关，比如32位系统就是4GB，其中一部分是内核区域不能被使用，还有被其他程序占用的部分，所以进程实际能使用的内存要比虚拟内存少，当发生缺页且无空闲物理块时，就需要发生替换。</p></li>
<li><p>死锁的定义？在多道程序系统中，程序并发执行，多个进程竞争资源造成相互等待，都无法继续进行下去。</p></li>
<li><p>死锁的4个条件？互斥条件、不可剥夺、循环等待、请求并保持。</p></li>
<li><p>win10里设置有死锁解决办法吗？猜测任务管理器，直接结束任务。</p></li>
<li><p>微内核、微服务？微内核：将内核中最基本的功能（如进程管理）保留在内核，其他不需要在核心态运行的功能移到用户态执行，降低内核设计的复杂性。其他作为服务程序，相互独立，通过内核进行通信。</p></li>
<li><p>什么是大内核和微内核？大内核：主要功能模块都运行在核心态，紧密联系，设计复杂。</p></li>
<li><p>Linux 用的是哪种内核？大内核。</p></li>
<li><p>PV操作、生产者消费者问题？</p></li>
<li><p>同步机制应该遵循的原则？空闲让进、忙则等待、有限等待、让权等待。</p></li>
<li><p>同一进程内的两线程对一个初值为0的共享变量分别进行10次加1操作，在不采取同步互斥措施的情况下，共享变量的最终值是多少？（老师说：2～20）</p></li>
<li><p>目录与文件的区别？</p></li>
<li><p>目录文件的内容？文件名+索引节点指针</p></li>
<li><p>信号量的作用? 同步与互斥</p></li>
<li><p>FAT，Ext2名词解释，磁盘分区 FAT：文件分配表</p></li>
<li><p>银行家算法的缺点？该算法要求请求资源的进程数数保持固定不变，这在多道程序系统中是难以做到的。开销大。</p></li>
<li><p>说一下缺页中断？CPU响应中断、从外存中找到页面，判断内存是否满，如果满的话执行替换算法，将其中一页换出，不满的话启动I/O将页面调入内存，修改页表，并将此页表项写入TLB。</p></li>
<li><p>如果让你设计一个操作系统你有什么思路？</p></li>
<li><p>工作集算法的缺点？</p></li>
<li><p>并发有哪些？</p></li>
<li><p>内存管理方法？连续分配方式：固定分区分配、动态分区分配。非连续分配方式：分页存储管理方式、分段存储管理方式。Linux用的是哪种？Linux采用段页式内存管理。</p></li>
<li><p>分页系统怎么将逻辑地址转化为物理地址?
将逻辑地址分为两个部分，页号和页内偏移量，通过查页表将逻辑页号转换成物理块号，与页内偏移拼接在一起就是物理地址。</p></li>
<li><p>快表、页表？</p></li>
<li><p>页表，多级页表？</p></li>
<li><p>段表和页表区别？段表项：段号、段长、段内偏移。页表只需要给出：页号和页内偏移。</p></li>
<li><p>反表？虚拟地址太长，页表太大。同时查找整个表，得到虚拟地址对应的物理帧。</p></li>
<li><p>页表会加速进程运行吗？在不分页的情况下，指令首先通过在主存取指令，从而访问内存一次，有了分页机制后，会因为要多次访问页表而引起更多次内存访问。</p></li>
<li><p>如果给进程分配分区的过程中，产生很多细小的外部碎片，怎么解决？紧凑技术</p></li>
<li><p>紧凑技术的具体原理是什么？操作系统对进程进行移动和整理，需要动态重定位寄存器的支持。</p></li>
<li><p>内存里的LRU怎么实现？使用CLOCK算法或其变体。</p></li>
<li><p>CLOCK置换算法？简单CLOCK置换算法：给每个物理块加一个使用位，首次装入主存，置为1。需要替换时，循环扫描所有的候选物理块，碰到使用位1将其置0，扫描下一帧，碰到0将其作为替换的块。</p></li>
<li><p>线程和进程区别？线程时独立调度的基本单位，进程时分配资源的基本单位，线程不拥有系统资源，但是可以共享其所属进程的资源。进程相互独立，进程中的线程对其他进程不可见。进程切换开销大，线程切换开销小。</p></li>
<li><p>进程间如何通信？管道通信、共享存储等。</p></li>
</ul>
<h2 id="计算机网络">计算机网络</h2>
<ul>
<li><p>计算机网络中的四种延迟分别是什么？发送时延、传播时延、处理时延、排队时延</p></li>
<li><p>拥塞控制和流量控制的区别？拥塞控制是作用于网络的，它是防止过多的数据注入到网络中出现网络负载过大的情况；流量控制时作用于发送者的，控制发送者的发送速度，使得接收者来得及接收。</p></li>
<li><p>网络层和传输层是干什么的？网络层：为不同网络上的主机提供通讯服务。传输层：负责主机间两个进程的通信。</p></li>
<li><p>计算机网络分为哪两个部分？边缘，核心。</p></li>
<li><p>TCP/IP模型?
从低到高分为网络接口层、网际层、传输层、应用层。TCP/IP模型可靠性是端到端的问题，所以网际层是无连接的，传输层支持无连接和面向连接两种方式。</p></li>
<li><p>OSI参考模型？七层模型。物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。在网络层支持无连接和面向连接的通信，传输层仅有面向连接。</p></li>
<li><p>TCP的网际接口层对应哪两层？数据链路层和物理层</p></li>
<li><p>802.11协议？无线局域网的协议，MAC层使用CSMA/CA协议。</p></li>
<li><p>CSMA/CA、CSMA/CD协议及其区别？CD：适用于以太网，CA适用于无线局域网。CSMA/CD：可以冲突检测但是无法避免。CSMA/CA发送数据时无法检测冲突，所以只能尽量避免。</p></li>
<li><p>数据链路层的可靠性？</p></li>
<li><p>网络中的集线器和网桥的区别？</p></li>
<li><p>路由器的作用？收集网络拓扑信息并动态形成路由表。根据路由表转发IP数据包。隔离广播域。</p></li>
<li><p>外部路由协议和内部路由协议有哪些？内部路由协议：RIP,OSPF。外部路由协议：BGP。</p></li>
<li><p>ICMP协议的作用？作为IP数据报的数据，让主机或路由器报告差错和异常情况，提高IP数据报交付成功的机率。</p></li>
<li><p>ICMP是从哪里发送给哪里的，需不需要发送给主机？目标主机或到目标主机路径上的路由器发送给源主机，报告差错和异常情况。</p></li>
<li><p>PING ：使用了ICMP的会送请求和回答报文。</p></li>
<li><p>IP数据报最小长度多少？IP数据报的最大长度？总长度格式：16位，以字节为单位。</p></li>
<li><p>实际中IP数据报可以达到这么大的长度吗？IP数据报的最大长度受数据链路层的最大传送数据单元制约。比如以太网1500字节。</p></li>
<li><p>ipv4用完解决方法？ipv6；NAT技术：小的局域网使用一个网段的私网地址，与外界连接再换成公网地址。CIDR：在变长子网掩码的基础上提出的一种消除传统ABC类网络的IP地址划分方法。</p></li>
<li><p>什么是CIDR，有什么功能？CIDR：在变长子网掩码的基础提出的一种消除传统ABC类网络的IP地址划分方法。使用网络前缀代替子网的概念，可以按照实际需要划分更加合理的IP地址空间，提高地址空间的利用率。将网络前缀相同的IP地址进行路由聚合，减少路由项，提高网络性能。</p></li>
<li><p>交换机和路由器的区别？交换机是数据链层设备，隔离冲突域，不能隔离广播域。路由器是网络层设备，隔离广播域。</p></li>
<li><p>ARP协议是什么？ARP协议及其应用？地址解析协议。解决同一个局域网下的主机或路由器IP地址和MAC地址的映射问题。</p></li>
<li><p>NAT？私网IP与公网IP转换。</p></li>
<li><p>流量控制的方法？停止-等待协议。滑动窗口协议。</p></li>
<li><p>停等协议的主要作用？发送窗口大小如何设置，发送窗口大小确定后发送方一次能够发送的数据量受什么限制</p></li>
<li><p><strong>滑动窗口原理？</strong>发送端维持一个发送窗口，接收方维持一个接受窗口。发送窗口用来进行流量控制，表示还未收到对方确认信息的情况下最多还可以发送的数据帧。接受窗口用于控制收到数据帧是否能接受，如果在此窗口内就可以接受，否则丢弃。</p></li>
<li><p><strong>滑动窗口的作用？</strong>流量控制。保证接受的顺序正确。</p></li>
<li><p>滑动窗口发送端怎么触发？收到确认则可以向前滑动。用数据结构怎么描述或者实现？链表？</p></li>
<li><p>拥塞控制？</p></li>
<li><p>介绍两个使用了广播技术的协议？IGMP：主机只发送一份，只在路径分叉时才复制转发。</p></li>
<li><p>组播与广播？组播：一对一组。广播：一对所有，会被局限在局域网内，因为路由不会转发。单播：一对一。</p></li>
<li><p>广播的实际应用？视频会议、直播等。</p></li>
<li><p>同步传输和异步传输？</p></li>
<li><p>串行并行传输优缺点？从原理上讲，在相同的工作频率下并行传输的传输速度远比串行传输大，但并行线路有一些难以克服的缺点，如：成本高、占用空间大、信号间干扰大。无法用于长距离通信，只适合于短距离、要求传输速度快的场合使用，如计算机内部的总线。</p></li>
<li><p>TCP和UDP中，为什么TCP是可靠的？使用了流量控制和拥塞避免。</p></li>
<li><p>发电子邮件的协议和过程？SMTP发送邮件，POP3拉取邮件。</p></li>
<li><p>DNS的过程?递归查询；递归与迭代相结合。</p></li>
<li><p>DNS功能? 域名转换成IP。</p></li>
<li><p>FTP端口号？21控制端口，20数据连接端口</p></li>
</ul>
<h2 id="离散数学">离散数学</h2>
<ul>
<li><p>问你个最简单的，为啥要叫离散数学？离散数学的研究对象不是连续变化的实数，而是整数、图和命题这样离散的不连续的对象。</p></li>
<li><p>离散数学的学习内容？集合论、代数系统、图论、数理逻辑等。</p></li>
<li><p>什么是集合？由离散个体构成的整体的称为集合，称这些个体为集合的元素。</p></li>
<li><p>集合元素的性质？无序性、相异性、确定性、任意性</p></li>
<li><p>什么是幂集？集合的全体子集构成的集合叫做幂集。</p></li>
<li><p>什么是<strong>笛卡尔积</strong>？设有两个集合 A与 B，用 A与
B中的元素组成有序偶，以 A的元素作为有序偶的第一个分量，以
B的元素作为有序偶的第二个分量，用这种方式所组成的有序偶的全体构成一个集合，称为
A与 B的笛卡尔乘积。</p></li>
<li><p><strong>二元关系</strong>的定义？集合中的元素都是有序对或者这个集合是空集；</p></li>
<li><p><strong>等价关系</strong>和等价类的定义？设 R为非空集合
A上的一个关系，如果 R是自反的、对称的和传递的，则称 R为
A上的等价关系。A中所有与x等价的全体元素构成的子集称为等价类。</p></li>
<li><p><strong>偏序关系</strong>与偏序集？自反的、反对称的和传递的。</p></li>
<li><p>集合、关系与函数之间的关系？在集合之上建立关系，关系建立集合与集合间的联系。函数是一种特殊的关系。</p></li>
<li><p>单射、满射和双射的概念？单射：不同的x对应不同的y。
满射：对任意一个y都有x与之对应。双射：单射+满射（一一对应）</p></li>
<li><p><strong>代数系统</strong>的定义？非空集合S加上
若干个集合S上的一元或二元运算构成一个代数系统。</p></li>
<li><p><strong>子代数系统</strong>？一个代数系统V=&lt;S,f1….&gt;
集合B是集合S的非空子集，B对这个代数系统的所有二元运算都是封闭的，那么称B加上这些运算是代数系统V的一个子代数系统。</p></li>
<li><p>典型的代数系统？半群、独异点与群、环与域、格与布尔代数。<strong>半群</strong>——代数系统由一个非空集合S加上一个二元运算，这个二元运算满足结合律。<strong>独异点</strong>——半群，且非空集合S中含有一个单位元。<strong>群</strong>——具有单位元与逆元的半群。<strong>交换群/阿贝尔群</strong>：结合律，分配律。</p></li>
<li><p><strong>平面图</strong>？可以画在平面上，任意两边都不相交。</p></li>
<li><p>什么是<strong>哈密顿图</strong>？能走出一条通过每个结点仅一次的回路。</p></li>
<li><p>什么是<strong>欧拉图</strong>？能走出一条通过每条边仅一次的回路。</p></li>
<li><p><strong>欧拉公式</strong>：n – m + r =
2，n：顶点个数。m:边个数。r:面个数。</p></li>
<li><p><strong>命题</strong>？能够判断真假的陈述句。原子（简单）命题——不能再分解为更简单命题的命题。复合命题——由原子命题通过命题联结词构成的命题。</p></li>
<li><p><strong>命题联结词</strong>？非、合取、析取、等价、蕴含</p></li>
<li><p><strong>析取范式、合取范式</strong>？析取范式——有限个简单合取式构成的析取式；合取范式——有限个简单析取范式构成的合取式；</p></li>
<li><p><strong>主合取范式与主析取范式</strong>？主合取范式——构成的简单析取式都是极大项；主析取范式——构成的简单合取式都是极小项。</p></li>
</ul>
<h2 id="数据库">数据库</h2>
<ul>
<li><p>怎么设计一个数据库？七个阶段：规划、需求分析、概念设计、逻辑设计、物理设计、实现、运行维护</p></li>
<li><p>对于目前的复试面试系统如何设计数据库？</p></li>
<li><p>数据库的发展阶段?
人工管理阶段、文件系统阶段、数据库系统阶段。</p></li>
<li><p>数据库的种类？按照数据的保存格式进行分类：层次、关系(MySQL,
Oracle Database、SQL Server)、面向对象、键值存储数据库（Redis）</p></li>
<li><p>Oracle是什么型数据库，Oracle数据库的特点?关系型数据库，多用户、数据完整性、安全性性能优越、支持分布式、跨平台。</p></li>
<li><p>试述数据库系统<strong>三级模式</strong>结构，这种结构的优点是什么？外模式（单个用户使用的数据视图）、概念模式（全局数据视图）、内模式（数据视图的物理存储）。优点：保证物理数据独立性、逻辑数据独立性。物理数据独立性：如果数据库内模式要修改，只要修改模式/内模式的映像，概念模式尽可能保持不变。如果数据库概念模式要修改，只要修改外模式/模式的映像，外模式尽可能保持不变。</p></li>
<li><p>数据库的<strong>两级映射</strong>？外模式/模式映像；模式/内模式映像。</p></li>
<li><p>数据库外模式可以有几种？一对一还是一对多？一个数据库可以有多个外模式，一对多。</p></li>
<li><p>常用的数据模型？概念数据模型：实体联系模型。结构数据模型：层次数据模型、网状数据模型、关系数据模型、面向对象模型、半结构化模型。</p></li>
<li><p>最早的数据模型？层次数据模型。</p></li>
<li><p>关系模型图灵奖获得者是谁？E. F. Codd (埃德加 • 科德)</p></li>
<li><p>内连接与外连接？内连接的特性是只显示符合连接条件的记录，外连接必然会返回其中一张表的全部数据，哪怕不匹配。</p></li>
<li><p>假如有上百个个人密码，数据库如何储存个人密码，不会泄露？</p></li>
<li><p>数据库规范化设计理论？</p>
<blockquote>
<p>三个内容：数据依赖、范式、模式设计方法。</p>
<p>目的：设计出合理的关系型数据库，解决关系模式数据冗余、异常、不一致问题。便于插入、删除和更新。</p>
</blockquote></li>
<li><p>范式的概念——关系数据库有多少范式，简述？关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</p></li>
<li><p>数据库的范式越来越高会产生什么影响？越高的范式数据库冗余越小。</p></li>
<li><p>什么是<strong>基本表</strong>？什么是<strong>视图</strong>？两者的区别和联系是什么？基本表：实际存储在数据库中的表。视图：从一个或者多个基本表导出的表。视图是一个定义，是不存储数据的虚表，所有对视图的操作都要转换到基本表上。视图可以和基本表一样被查询，但是更新（增、删、改）操作会受到一定限制。</p></li>
<li><p>视图不允许更新的几种情况？多个表连接操作导出的；导出时使用了分组和聚合操作；从单个基本表导出，但是不包含表的主键或者候选键。</p></li>
<li><p>试述视图的优点?数据安全性、查询简化、逻辑数据独立性（应用建立在视图上，只要修改视图定义中的子查询部分，相当于映射部分，其他可以保持不变）。</p></li>
<li><p>解释一下，数据库的索引?类似于字典的索引。</p></li>
<li><p>索引所属的模式范畴？内模式</p></li>
<li><p>存储过程？一组为了完成特定功能的SQL
语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来调用存储过程。（类似于一段编译好的脚本）</p></li>
<li><p>数据SQL语句底层执行？连接数据库、查询缓存、分析器（分析词法、语法）、优化器（使用哪个索引、多表关联时决定连接顺序）、执行器（验证是否有读写权限，有的话就调用存储引擎接口获取结果集合）</p></li>
<li><p>对比
非关系型系统与关系数据库系统？RDBMS关注一致性（ACID模型），而NoSQL系统则关注可用性。关系型数据库通常是以表格形式存储数据，而NoSQL系统有多种存储方式，包括key/value存储（Redis）、文档存储（MongoDB）以及图存储（Neo4j）等。当数据达到一定规模时，关系型数据库易出现死锁等并发问题，导致其读写速度下滑非常严重。而NoSQL数据库结构简单、集成缓存能力，读写性能非常好。举例：金融业一致性重要，选择关系型数据库。购物网站、社交网站等对可用性要求较高，选择非关系型数据库</p></li>
<li><p>数据库管理系统（DBMS）的主要功能有哪些？数据库定义（结构、约束）；数据库操纵、数据库的保护、数据库的维护。</p></li>
<li><p>数据库的保护：事务、恢复、并发控制、完整性控制、安全性控制</p></li>
<li><p>事务的四大特性？原子性、一致性、隔离性、持久性</p></li>
<li><p>完整性约束？域约束、基本表约束（候选键、外键、检查约束）、断言</p></li>
<li><p>事务并发操作带来的三个问题：丢失更新、读脏数据、不一致分析</p></li>
<li><p>处理并发问题的机制：封锁技术。排他性封锁（X锁），共享型封锁（S锁）</p></li>
<li><p>封锁技术产生的三个问题：活锁、饿死、死锁。活锁——一个事务
一直得不到封锁机会；饿死——一直有事务加S锁，加X锁的事务加不上；死锁——两个或以上事务互相等待，导致任何一个都无法继续执行。</p></li>
<li><p>数据库<strong>安全性控制</strong>的常用方法和技术？视图机制、授权子系统。</p></li>
</ul>
<h2 id="编译原理">编译原理</h2>
<ul>
<li><p>我看你学了编译原理，能跟我讲讲你们编译原理上了什么内容吗？</p></li>
<li><p>说一下编译的五大过程</p></li>
<li><p>语义分析的输入和输出是什么</p></li>
<li><p>对比C/Java中的程序起点是main()函数，汇编程序的起点标志是什么？</p></li>
<li><p>编译前端与编译后端</p></li>
<li><p>根据已有编译器，生成新编译器</p></li>
<li><p>上下文无关文法</p></li>
<li><p>文法的二义性</p></li>
<li><p>乔姆斯基四类文法</p></li>
<li><p>自动机</p></li>
<li><p>非确定有限(状态)自动机（NFA）与确定有限(状态)自动机（DFA）的区别</p></li>
<li><p>语法分析：自上而下分析与自下而上分析</p></li>
<li><p>编译过程5个阶段各自的任务</p></li>
</ul>
<h2 id="数字图像处理">数字图像处理</h2>
<ul>
<li><p>计算机视觉、图形学和图像处理，三者有什么联系？Computer
Vision，简称
CV。输入的是图像或图像序列，通常来自相机、摄像头或视频文件。输出的是对于图像序列对应的真实世界的理解，比如检测人脸、识别车牌、区分猫狗。Digital
Image Processing，简称 DIP。输入的是图像，输出的也是图像。Photoshop
中对一副图像应用滤镜就是典型的一种图像处理。常见操作有模糊、灰度化、增强对比度等。</p></li>
<li><p>图形学与数字图像处理？</p></li>
<li><p>模拟图像与数字图像？模拟图像：通过某种<strong>物理量（如光、电等）的强弱变化</strong>来记录图像亮度信息的图像，是<strong>连续</strong>的，肉眼可见的。数字图像：用<strong>存储数字的矩阵</strong>来表达客观物体的图像，是一个<strong>离散</strong>采样点的集合，肉眼不可见。</p></li>
<li><p>数字图像处理的主要研究内容？图像的获取和存储、压缩、去除噪声、增强、复原、分割、提取特征等。</p></li>
<li><p>灰度图像、二值图像与彩色图像？</p></li>
<li><p>对比度扩展？</p></li>
<li><p>如何进行二值化？</p></li>
<li><p>直方图均衡化？利用图像直方图对对比度进行调整。把一个已知灰度概率密度分布的图像经过一种变换，使之演变为一幅具有均匀灰度概率密度分布的新图像。</p></li>
<li><p>什么是中值滤波？消除图像中的噪声又保留细节。取奇数窗口所有像素的中间值，替换到中心位置的像素。</p></li>
<li><p>怎么消除噪声？滤波器。</p></li>
<li><p>图像分割？</p></li>
<li><p>数字图像说一个模型我问你</p></li>
</ul>
<h2 id="模式识别">模式识别</h2>
<ul>
<li><p>什么是模式识别？</p></li>
<li><p>模式识别的课程学过什么？特征降维、朴素贝叶斯算法、支持向量机、k均值算法、人脸识别、人脸检测等等。</p></li>
<li><p>模式识别与机器学习有什么区别？模式识别：人类主动去描述某些特征给机器，然后让机器做出分类、识别等。机器学习：机器从已知的经验数据（样本）中，通过某种特定的方法（算法），自己去寻找提炼（训练/学习）出一些规律（模型）；提炼出的规律就可以用来判断一些未知的事情（预测）。</p></li>
<li><p>聚类算法？聚类是无监督算法。举例：K均值算法。原理：初始化k个簇的质心，计算每个数据点与每个质心的距离，将数据点分配到与其最近的簇。对每个簇计算其所有点的均值作为新的质心。</p></li>
<li><p>无监督和有监督算法的区别？</p></li>
<li><p>过拟合、欠拟合？</p></li>
<li><p>人工智能里面的CPU和GPU有什么不同</p></li>
</ul>
<h2 id="大数据技术基础">大数据技术基础</h2>
<ul>
<li><p>学习内容？虚拟机、Linux、Python基础知识；大数据处理架构Hadoop；分布式文件系统HDFS；NoSQL数据库；MapReduce；Spark；大数据案例（数据可视化、推荐系统、自然语言处理等）</p></li>
<li><p>人工智能和大数据的关系？</p></li>
<li><p>什么是大数据？</p></li>
<li><p>机器学习，数据挖掘，大数据分析的区别？大数据侧重描述数据，数据挖掘侧重描述应用，机器学习侧重描述方法。机器学习方法在大型数据中的应用称为数据挖掘。</p></li>
</ul>
<h1 id="后记">后记</h1>
<p>上面的问题基本都是我一条一条从网上搜的资料以及自己翻阅教材的结果，部分没搜到答案的就只能自由发挥了，面试最主要就是心态，老师都挺好的，也没怎么为难人，我感觉全程老师都很和善的，面试完了还夸人，点赞！</p>
<p>另外其实复试当中笔试占比较大，难度也挺高的，面试大家基本都差不多，还是得看笔试，不提前准备真的就凉了。。。</p>
<p>祝考研上岸！</p>
<h1 id="参考">参考</h1>
<p>2021年上岸知乎大佬zdszero的分享：<a href="https://zhuanlan.zhihu.com/p/377692017">中科大计算机考研复试详解</a></p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>复试</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大概率算法作业</title>
    <url>/post/34884d63.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——《算法设计与分析》概率算法部分的习题作业。这门课我最喜欢的就是概率算法这部分，感觉提到的一些算法和例子都非常有趣。本文参考了网上一些前辈的资料，并结合自己的理解做出解答。</p>
<span id="more"></span>
<h1 id="分析与解答">分析与解答</h1>
<p><strong>Ex.1【P20】若将<span class="math inline">\(y\leftarrow
uniform(0,1)\)</span>改为<span class="math inline">\(y\leftarrow
x\)</span>，则上述的算法估计的值是什么？</strong></p>
<blockquote>
<p>求<span class="math inline">\(\pi\)</span>近似值的算法(右上<span class="math inline">\(\frac{1}{4}\)</span>象限为样本)</p>
<p>Darts (n) { k <span class="math inline">\(\leftarrow\)</span> 0; for
i <span class="math inline">\(\leftarrow\)</span> 1 to n do { x <span class="math inline">\(\leftarrow\)</span> uniform(0, 1); y <span class="math inline">\(\leftarrow\)</span> uniform(0, 1); //
随机产生点(x,y) if (<span class="math inline">\(x^2 + y^2 ≤ 1\)</span>)
then k++; // 圆内 } return 4k/n;<br>
}</p>
</blockquote>
<p><span class="math display">\[
4*\frac{k}{n}=4*\frac{\pi r^2}{4r^2}=\pi
\]</span></p>
<p><strong>解：</strong>如果将<span class="math inline">\(y\leftarrow
uniform(0,1)\)</span>改为<span class="math inline">\(y\leftarrow
x\)</span>，则算法变为</p>
<blockquote>
<p>Darts (n) { k <span class="math inline">\(\leftarrow\)</span> 0; for
i <span class="math inline">\(\leftarrow\)</span> 1 to n do { x <span class="math inline">\(\leftarrow\)</span> uniform(0, 1);<br>
y <span class="math inline">\(\leftarrow\)</span> x; // 随机产生点(x,y)
if (<span class="math inline">\(2x^2≤ 1\)</span>) then k++; // <span class="math inline">\(x^2&lt;=\frac{1}{2}\)</span> } return 4k/n;<br>
}</p>
</blockquote>
<p>当x=y时， 随机产生点(x,y)都位于<span class="math inline">\(y=x,0\le x
\le 1\)</span>的线段上，长度为1，而只有<span class="math inline">\(0\le
x \le \frac{\sqrt{2}}{2}\)</span>范围内的点落在圆内，长度为<span class="math inline">\(\frac{\sqrt{2}}{2}\)</span>,所以算法估计的值为：
<span class="math display">\[
4*\frac{k}{n}=4*\frac{\sqrt{2}}{2}=2\sqrt{2}
\]</span></p>
<ul>
<li>实验代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Darts</span>(<span class="params">n</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> x*x+y*y &lt;= <span class="number">1</span>:</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>*k/n</span><br><span class="line"></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n:&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(Darts(n))</span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果</li>
</ul>
<blockquote>
<p>n=1000000 2.828896</p>
</blockquote>
<p><strong>Ex.2【P23】在机器上用<span class="math inline">\(4\int_{0}^{1}\sqrt[]{1-x^2}dx\)</span>估计π值，给出不同的n值及精度。</strong></p>
<p><strong>解：</strong></p>
<ul>
<li>实验代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">HitorMisss</span>(<span class="params">func, n</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        y = random.uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> y &lt;= func(x):</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> k/n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> math.sqrt(<span class="number">1</span>-x*x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同n值下的pi估算值</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1000000</span>,<span class="number">10000000</span>,<span class="number">100000000</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n = &#123;:&lt;10d&#125; pi = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(n, <span class="number">4</span>*HitorMisss(func1, n)))</span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果： π=3.141592654</li>
</ul>
<blockquote>
<p>n = 1百万 pi = 3.142484（2位精确） n = 1千万 pi = 3.140752（2位精确）
n = 1亿 pi = 3.14163212（3位精确）</p>
</blockquote>
<p><strong>Ex.3【P23】 设a, b, c和d是实数，且<span class="math inline">\(a ≤ b, c ≤ d, f:[a, b] → [c,
d]\)</span>是一个连续函数，写一概率算法计算积分：</strong> <span class="math display">\[
\int_{a}^{b}f(x)dx
\]</span> 注意，函数的参数是a, b, c, d, n和f,
其中f用函数指针实现，请选一连续函数做实验，并给出实验结果。</p>
<p><strong>解：</strong>选取指数函数作为研究对象，<span class="math inline">\(f(x)=e^x,a=0,b=1,c=0,b=e\)</span>，计算<span class="math inline">\(\int_{0}^{1}e^xdx\)</span></p>
<ul>
<li><p>理论结果：</p>
<p>根据牛顿-莱布尼兹公式<span class="math inline">\(F(x)=e^x\)</span>
<span class="math display">\[
\int_{0}^{1}e^xdx=F(1)-F(0)=e-1
\]</span> e-1 = 1.718281828459045</p></li>
<li><p>实验代码</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 积分概率算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">func, n, a=<span class="number">0</span>, b=<span class="number">1</span>, c=<span class="number">0</span>, d=<span class="number">1</span></span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x = random.uniform(a, b)</span><br><span class="line">        y = random.uniform(c, d)  <span class="comment"># 随机生成矩形内的点(x,y)</span></span><br><span class="line">        <span class="keyword">if</span> y &lt;= func(x):</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">    S_1 = (b-a)*(d-c)  <span class="comment"># 计算矩形面积</span></span><br><span class="line">    <span class="keyword">return</span> S_1*k/n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> math.exp(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e-1 = &quot;</span>, math.exp(<span class="number">1</span>)-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n = &#123;:&lt;10d&#125; result = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, calculate(func2, n, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, math.exp(<span class="number">1</span>))))</span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果</li>
</ul>
<blockquote>
<p>e-1 = 1.718281828459045 n = 1000000（1百万） result =
1.7169592244369005 (2精确度) n = 10000000 （1千万） result =
1.7181025337739504 (3精确度) n = 100000000 （1亿） result =
1.718124551856761 (3精确度)</p>
</blockquote>
<p>**Ex.4【P24】 设$,<span class="math inline">\(是(0,1)之间的常数，证明：** **若\)</span>I<span class="math inline">\(是\)</span>_{0}^{1}f(x)dx<span class="math inline">\(的正确值，h是由HitorMiss算法返回的值，则当\)</span>n$时有：<strong>
<span class="math display">\[
Prob[|h-I|\le \varepsilon] ≥ 1-\delta
\]</span> </strong>上述的意义告诉我们：<span class="math inline">\(Prob[|h-I|\ge\varepsilon]\le\delta\)</span>,
即：当<span class="math inline">\(n\ge
\frac{I(1-I)}{\varepsilon^2\delta}\)</span>时，算法的计算结果的绝对误差超过<span class="math inline">\(\varepsilon\)</span>的概率不超过<span class="math inline">\(\delta\)</span>，因此我们根据给定<span class="math inline">\(\varepsilon\)</span>和<span class="math inline">\(\delta\)</span>可以确定算法迭代的次数<strong>
<span class="math display">\[
n=\frac{I(1-I)}{\varepsilon^{2} \delta} \leq\left[\frac{1}{4
\varepsilon^{2} \delta}\right] \quad\left(\because I(1-I) \leq
\frac{1}{4}\right)
\]</span> </strong>解此问题时可用切比雪夫不等式，将<span class="math inline">\(I\)</span>看作是数学期望。**</p>
<p><strong>解：</strong></p>
<p>h 是一个随机变量，记其期望和方差为<span class="math inline">\(E(h)\)</span>和<span class="math inline">\(D(h)\)</span>。根据切比雪夫不等式 <span class="math display">\[
Prob(|h-E(h)|\ge \varepsilon)\le \frac{D(h)}{\varepsilon^2}
\]</span> 显然 <span class="math inline">\(E(h)=I\)</span>。另一方面，在
HitorMiss 算法中，若随机取 n 个点，有 k 个点在积分范围内，则有 h=k /
n。因为 n 个点中每一个点，其要么在积分范围内，要么不在积分范围内，因此 k
服从于二项分布<span class="math inline">\(B(n, I)\)</span>，其中 <span class="math inline">\(I\)</span>为点落在积分范围内的概率， <span class="math inline">\(D(k)=n*I(1-I)\)</span>。又因为<span class="math inline">\(k=h*n\)</span>，所以 <span class="math inline">\(D(h)=I(1-I)/n\)</span></p>
<p>当<span class="math inline">\(n\ge
\frac{I(1-I)}{\varepsilon^2\delta}\)</span>时， <span class="math display">\[
Prob(|h-E(h)|\le \varepsilon)\ge 1-\frac{D(h)}{\varepsilon^2}
\]</span> 因为<span class="math inline">\(E(h)=I\)</span>且<span class="math inline">\(D(h)=I(1-I)/n\)</span>，所以： <span class="math display">\[
Prob(|h-I|\le \varepsilon)\ge 1-\frac{I(1-I)}{n\varepsilon^2}\ge1-\delta
\]</span></p>
<p><strong>Ex.5【P36】
用上述算法，估计整数子集1~n的大小，并分析n对估计值的影响。</strong></p>
<ul>
<li>实验代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用上述算法，估计整数子集1~n的大小，并分析n对估计值的影响。</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">REPEAT_COUNT = <span class="number">1000</span>  <span class="comment"># 重复次数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SetCount</span>(<span class="params">X</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    S = <span class="built_in">set</span>()</span><br><span class="line">    a = choice(X)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = k + <span class="number">1</span></span><br><span class="line">        S.add(a)</span><br><span class="line">        a = choice(X)</span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * k * k / math.pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">10</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">1000000</span>]:</span><br><span class="line">    X = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        X.append(i)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    Error_rate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(REPEAT_COUNT):</span><br><span class="line">        <span class="built_in">sum</span> += SetCount(X)</span><br><span class="line">        Error_rate += math.fabs(SetCount(X) - n) / n  <span class="comment"># 计算每次估计值的误差</span></span><br><span class="line">    Estimate_N = <span class="built_in">sum</span>/REPEAT_COUNT  <span class="comment"># 计算n的估计值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;n = &#123;:&lt;10d&#125; Estimate_N = &#123;:&lt;20.6f&#125; Error_rate = &#123;:.3%&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, Estimate_N, Error_rate/n))</span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果</li>
</ul>
<p>计算每次估计误差，重复1000次，求最后的平均误差，结果如下：</p>
<figure>
<img src="/post/34884d63/image-20221115133201303.png" alt="image-20221115133201303">
<figcaption aria-hidden="true">image-20221115133201303</figcaption>
</figure>
<p>n 越大，每次估计误差越小，估值越准确。</p>
<p><strong>Ex.6【P54】
分析dlogRH的工作原理，指出该算法相应的u和v</strong></p>
<p><strong>解：</strong> Sherwood 算法的一般过程：</p>
<ul>
<li><p>将被解的实例变换到一个随机实例。 //预处理函数 u</p></li>
<li><p>用确定算法解此随机实例，得到一个解。</p></li>
<li><p>将此解变换为对原实例的解。 //后处理函数 v</p></li>
</ul>
<p>dlogRH 对其中的 <span class="math inline">\(a=g^x \ mod \ p \
\)</span>作随机预处理，得到与其对应的随机实例 c=u(x, r)，并且对 c
使用确定性算法得到 y ，最后再把随机实例的结果 y 变换为输入实例 a 的解
x=v(y, r)。其中</p>
<p><span class="math display">\[
u: u(x, r) = log_{g,p} c = (r+x) mod (p-1) \\
v: v(y, r) = (y-r) mod (p-1)
\]</span></p>
<p><strong>Ex.7【P67】 写一Sherwood算法C，与算法A, B,
D比较，给出实验结果。</strong></p>
<p><strong>解：</strong></p>
<ul>
<li><p>算法 C :在 B 的基础上修改，不是取前<span class="math inline">\(\sqrt n\)</span>个元素作为基准，而是随机取<span class="math inline">\(\sqrt n\)</span>个元素作为基准。</p></li>
<li><p>实验代码</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">n = <span class="number">10000</span></span><br><span class="line">val = []  <span class="comment"># 记录值数组</span></span><br><span class="line">ptr = []  <span class="comment"># 指针数组</span></span><br><span class="line">head = <span class="number">0</span>  <span class="comment"># 链头</span></span><br><span class="line">sa = []</span><br><span class="line">sb = []</span><br><span class="line">sc = []</span><br><span class="line">sd = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化静态链表数组 （链中指向数组编号从1开始 0表示结尾）</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">    val.append(i)</span><br><span class="line">random.shuffle(val) <span class="comment"># 将序列的所有元素随机排序 该行注释表示基本有序的静态链表</span></span><br><span class="line"><span class="comment"># 将指针数组按照值从小到大链接</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> val:</span><br><span class="line">    <span class="keyword">if</span> i != n - <span class="number">1</span>:</span><br><span class="line">        ptr.append(val.index(i + <span class="number">1</span>)) <span class="comment"># val.index() 查找数组中元素的序号</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ptr.append(-<span class="number">1</span>)</span><br><span class="line">head = val.index(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">x, i</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从位置i开始查找x,返回x所在位置序号和查找长度&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &gt; val[i]:</span><br><span class="line">        i = ptr[i]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i, count </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>(<span class="params">x</span>):  <span class="comment"># o(n)</span></span><br><span class="line">    <span class="keyword">return</span> search(x, head)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">x</span>):  <span class="comment"># o(sqrt(n))</span></span><br><span class="line">    i = head</span><br><span class="line">    <span class="built_in">max</span> = val[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(sqrt(n))):</span><br><span class="line">        y = val[j]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span> &lt; y &lt;= x:</span><br><span class="line">            i = j</span><br><span class="line">            <span class="built_in">max</span> = y</span><br><span class="line">    <span class="keyword">return</span> search(x, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">C</span>(<span class="params">x</span>):  <span class="comment"># o(sqrt(n)) Sherwood</span></span><br><span class="line">    i = head</span><br><span class="line">    <span class="built_in">max</span> = val[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(sqrt(n))):</span><br><span class="line">        jj = random.randint(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        y = val[jj]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span> &lt; y &lt;= x:</span><br><span class="line">            i = jj</span><br><span class="line">            <span class="built_in">max</span> = y</span><br><span class="line">    <span class="keyword">return</span> search(x, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">D</span>(<span class="params">x</span>):  <span class="comment"># o(n)</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    i = random.randint(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    y = val[i]</span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="keyword">return</span> search(x, head)</span><br><span class="line">    <span class="keyword">elif</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> search(x, ptr[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> i, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">REPEAT_COUNT = <span class="number">10000</span> <span class="comment"># 重复查找次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(REPEAT_COUNT):</span><br><span class="line">    x = random.randint(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    sa.append(A(x)[<span class="number">1</span>])</span><br><span class="line">    sb.append(B(x)[<span class="number">1</span>])</span><br><span class="line">    sc.append(C(x)[<span class="number">1</span>])</span><br><span class="line">    sd.append(D(x)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Algo A: average &#123;:&lt;10.3f&#125; worst &#123;:&lt;10d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>(sa) / <span class="built_in">len</span>(sa),<span class="built_in">max</span>(sa)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Algo B: average &#123;:&lt;10.3f&#125; worst &#123;:&lt;10d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>(sb) / <span class="built_in">len</span>(sa),<span class="built_in">max</span>(sb)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Algo C: average &#123;:&lt;10.3f&#125; worst &#123;:&lt;10d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>(sc) / <span class="built_in">len</span>(sa),<span class="built_in">max</span>(sc)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Algo D: average &#123;:&lt;10.3f&#125; worst &#123;:&lt;10d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>(sd) / <span class="built_in">len</span>(sa),<span class="built_in">max</span>(sd)))</span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果</li>
</ul>
<p>n=10000
，随机生成静态有序链表，链表元素随机打乱，每次查询随机的元素，重复
10000次，计算平均查找次数和最坏查找次数，结果如下：</p>
<figure>
<img src="/post/34884d63/image-20221115154747641.png" alt="image-20221115154747641">
<figcaption aria-hidden="true">image-20221115154747641</figcaption>
</figure>
<p>n=10000
，随机生成静态有序链表，链表元素按顺序排列，每次查询随机的元素，重复
10000次，计算平均查找次数和最坏查找次数，结果如下：</p>
<figure>
<img src="/post/34884d63/image-20221115154955453.png" alt="image-20221115154955453">
<figcaption aria-hidden="true">image-20221115154955453</figcaption>
</figure>
<p>从上述实验结果可以看到，在随机打乱的静态链表中，算法B,C的平均查找次数以及最坏查找次数远小于算法A,D；如果链表基本有序，随机化的
Sherwood 算法 C 的表现与随机链表相同， 而未随机化的算法 B 退化成了 O(n)
的算法。</p>
<p><strong>Ex.8【P77】证明：当放置（k+1)th皇后时，若有多个位置是开放的,则算法QueensLV选中其中任一位置的概率相等。</strong></p>
<p><strong>证明：</strong>当放置第（ k+1） th 皇后时，如果有 n
个位置开放，依次记为{S1,S2,…,Sn}。当uniform(1,…,i)=1且对于所有
j&gt;i有<span class="math inline">\(uniform(1,…,j)\ne0\)</span>时，Si被选中。
uniform(1,…,i)=1的概率为 <span class="math inline">\(1/i\)</span>，<span class="math inline">\(uniform(1,…,j)\ne0\)</span>的概率为<span class="math inline">\(1-\frac{1}{j}=\frac{j-1}{j}\)</span>。所以Si被选中的概率为：
<span class="math display">\[
P_i=(\frac{1}{i}\times\frac{i}{i+1}\times...\times\frac{n-1}{n})=\frac{1}{n}
\]</span> 所以算法QueensLV选中其中任一位置的概率相等。</p>
<p><strong>Ex.9【P83】
写一算法，求n=12~20时最优的StepVegas值。</strong></p>
<ul>
<li><p>实验思路</p>
<p>迭代计算 p,s,e,求出每个stepVegas下的
t（搜索的平均节点数），取t最小的stepVegas作为最优StepVegas值。</p></li>
<li><p>实验代码</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写一算法，求n=12~20时最优的StepVegas值</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">try_count = []</span><br><span class="line">try_count.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">queensLV</span>(<span class="params">stepVegas, try_, n, try_count</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;贪心的LV算法(改进)&quot;&quot;&quot;</span></span><br><span class="line">    col = <span class="built_in">set</span>()</span><br><span class="line">    diag45 = <span class="built_in">set</span>()</span><br><span class="line">    diag135 = <span class="built_in">set</span>()</span><br><span class="line">    k = <span class="number">0</span>  <span class="comment"># 行号</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        <span class="keyword">if</span> k == stepVegas:  <span class="comment"># 完全使用回溯法</span></span><br><span class="line">            <span class="keyword">return</span> backtrace(k+<span class="number">1</span>, try_, col, diag45, diag135, try_count)</span><br><span class="line">        nb = <span class="number">0</span>  <span class="comment"># 计数器，nb值为（k+1)th皇后的open位置总数</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 记录随机摆放皇后的列位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):  <span class="comment"># i是列号, 试探（k+1,i）安全否</span></span><br><span class="line">            <span class="keyword">if</span> (i <span class="keyword">not</span> <span class="keyword">in</span> col) <span class="keyword">and</span> (i - k <span class="keyword">not</span> <span class="keyword">in</span> diag45) <span class="keyword">and</span> (i + k <span class="keyword">not</span> <span class="keyword">in</span> diag135):</span><br><span class="line">                <span class="comment"># 列i对（k+1）th皇后可用，但不一定马上将其放在第i列</span></span><br><span class="line">                nb += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 在nb个安全的位置上随机选择1个位置j放置之</span></span><br><span class="line">                <span class="keyword">if</span> randint(<span class="number">1</span>, nb) == <span class="number">1</span>:  <span class="comment"># 或许放在第i列</span></span><br><span class="line">                    j = i</span><br><span class="line">        <span class="comment"># nb=0时无安全位置，第k+1个皇后尚未放好</span></span><br><span class="line">        <span class="keyword">if</span> nb &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 在所有nb个安全位置上，(k+1)th皇后选择位置j的概率为1/nb</span></span><br><span class="line">            try_count[<span class="number">0</span>] += <span class="number">1</span>  <span class="comment"># 1个皇后放好算是搜索树上的1个结点</span></span><br><span class="line">            k += <span class="number">1</span>  <span class="comment"># try[1..k+1]是(k+1)-promising</span></span><br><span class="line">            try_[k] = j  <span class="comment"># 将选定的(k+1)th皇后放入</span></span><br><span class="line">            col.add(j)</span><br><span class="line">            diag45.add(j - k)</span><br><span class="line">            diag135.add(j + k)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 当前皇后找不到合适的位置</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">k, try_, col, diag45, diag135, try_count</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;传统的回溯法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; n:  <span class="comment"># k表示行号 行号大于n表示皇后放置结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):  <span class="comment"># 从当前列j起向后逐列试探 寻找安全列号</span></span><br><span class="line">        <span class="keyword">if</span> (j <span class="keyword">not</span> <span class="keyword">in</span> col) <span class="keyword">and</span> (j - k <span class="keyword">not</span> <span class="keyword">in</span> diag45) <span class="keyword">and</span> (j + k <span class="keyword">not</span> <span class="keyword">in</span> diag135):</span><br><span class="line">            <span class="comment"># 找到安全列j 放置(k+1)th皇后</span></span><br><span class="line">            try_[k] = j</span><br><span class="line">            col.add(j)</span><br><span class="line">            diag45.add(j - k)</span><br><span class="line">            diag135.add(j + k)</span><br><span class="line">            try_count[<span class="number">0</span>] += <span class="number">1</span>  <span class="comment"># 1个皇后放好算是搜索树上的1个结点</span></span><br><span class="line">            <span class="comment"># 探索下一行</span></span><br><span class="line">            <span class="keyword">if</span> backtrace(k+<span class="number">1</span>, try_, col, diag45, diag135, try_count):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 回溯 移去该行已放置的皇后</span></span><br><span class="line">                col.remove(j)</span><br><span class="line">                diag45.remove(j - k)</span><br><span class="line">                diag135.remove(j + k)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 探索完所有列仍然没有符合要求的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REPEAT_COUNT = <span class="number">100</span>  <span class="comment"># 运行次数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n\tbest_sv\ts\te\tp\tt\ttime(ms)&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>, <span class="number">21</span>):</span><br><span class="line">    best_sv = n</span><br><span class="line">    best_s = <span class="number">0</span></span><br><span class="line">    best_e = <span class="number">0</span></span><br><span class="line">    best_p = <span class="number">0</span></span><br><span class="line">    best_t = <span class="number">0</span></span><br><span class="line">    best_time= <span class="number">0</span></span><br><span class="line">    min_t = <span class="number">1000000</span></span><br><span class="line">    <span class="keyword">for</span> stepVegas <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n+<span class="number">1</span>):</span><br><span class="line">        p_count = <span class="number">0</span>  <span class="comment"># 成功次数</span></span><br><span class="line">        s_count = <span class="number">0</span></span><br><span class="line">        e_count = <span class="number">0</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(REPEAT_COUNT):</span><br><span class="line">            try_count[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            try_ = [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]  <span class="comment"># 序号1...k 初始化为-1</span></span><br><span class="line">            <span class="keyword">if</span> queensLV(stepVegas, try_, n, try_count):</span><br><span class="line">                p_count += <span class="number">1</span></span><br><span class="line">                s_count += try_count[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                e_count += try_count[<span class="number">0</span>]</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        total_time = (t2-t1)*<span class="number">1000</span></span><br><span class="line">        s = s_count/REPEAT_COUNT  <span class="comment"># 成功时搜索的结点的平均数</span></span><br><span class="line">        e = e_count/REPEAT_COUNT  <span class="comment"># 失败时搜索的结点的平均数</span></span><br><span class="line">        p = p_count/REPEAT_COUNT  <span class="comment"># 成功的概率（一次成功）</span></span><br><span class="line">        t = s+(<span class="number">1</span>-p)*e/(p+<span class="number">0.0001</span>)  <span class="comment"># 搜索的平均节点数</span></span><br><span class="line">        <span class="keyword">if</span> t &lt; min_t:</span><br><span class="line">            min_t = t</span><br><span class="line">            best_sv = stepVegas  <span class="comment"># 取最小化t的stepVegas</span></span><br><span class="line">            best_s = s</span><br><span class="line">            best_e = e</span><br><span class="line">            best_p = p</span><br><span class="line">            best_t = t</span><br><span class="line">            best_time = total_time</span><br><span class="line">        <span class="comment"># print(&quot;&#123;:&lt;10d&#125;&#123;:&lt;10d&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;15.6f&#125;&quot;.format(</span></span><br><span class="line">        <span class="comment">#     n, stepVegas, s, e, p, t, total_time))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:&lt;10d&#125;&#123;:&lt;10d&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;10.4f&#125;&#123;:&lt;15.6f&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        n, best_sv, best_s, best_e, best_p, best_t, best_time))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果</li>
</ul>
<figure>
<img src="/post/34884d63/image-20221115220055192.png" alt="image-20221115220055192">
<figcaption aria-hidden="true">image-20221115220055192</figcaption>
</figure>
<p><strong>Ex.10【147】</strong></p>
<blockquote>
<p>PrintPrimes{ //打印1万以内的素数 print 2，3； n ←5； repeat if
RepeatMillRab(n,$ _{}{n} $) then print n; n ←n+2; until n=10000; }</p>
</blockquote>
<p>与确定性算法相比较，并给出100~10000以内错误的比例。</p>
<ul>
<li>实验思路：分别在不同k值下对100~10000以内整数进行RepeatMillRab素性测试，得到的结果与确定性算法比较，记录错误个数，重复实验，得到平均错误个数和平均错误比例。</li>
<li>实验代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RepeatMillRab素性测试与确定性算法相比较，并给出100~10000以内错误的比例。</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt, log10</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Btest</span>(<span class="params">a, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回真说明n是强伪素数或素数&quot;&quot;&quot;</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    t = n - <span class="number">1</span>  <span class="comment"># t开始为偶数</span></span><br><span class="line">    <span class="keyword">while</span> t % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s = s + <span class="number">1</span></span><br><span class="line">        t = t // <span class="number">2</span></span><br><span class="line">    x = a ** t % n</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">or</span> x == n - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s):</span><br><span class="line">        x = x ** <span class="number">2</span> % n</span><br><span class="line">        <span class="keyword">if</span> x == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MillRab</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Miller-Rabin测试:奇n&gt;4 返回真时表示素数 假表示合数&quot;&quot;&quot;</span></span><br><span class="line">    a = randint(<span class="number">2</span>, n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> Btest(a, n)  <span class="comment"># 测试n是否为强伪素数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RepeatMillRab</span>(<span class="params">n, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;重复调用k次之后返回true&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="keyword">if</span> MillRab(n) == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 一定是合数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 高概率为素数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;确定性算法确定是否为素数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = <span class="number">100</span></span><br><span class="line">end = <span class="number">10000</span></span><br><span class="line">REPEAT_COUNT = <span class="number">10</span>  <span class="comment"># 重复次数</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(REPEAT_COUNT):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">            <span class="keyword">if</span> RepeatMillRab(i, k) != is_prime(i):</span><br><span class="line">                error += <span class="number">1</span></span><br><span class="line">    error /= REPEAT_COUNT  <span class="comment"># 平均错误次数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;k = &#123;:&lt;4d&#125; error times = &#123;:&lt;10.2f&#125; error rate = &#123;:&lt;10.6f&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        k, error, error/(end-start)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>实验结果</li>
</ul>
<figure>
<img src="/post/34884d63/image-20221115225306352.png" alt="image-20221115225306352">
<figcaption aria-hidden="true">image-20221115225306352</figcaption>
</figure>
<p>可以看到在k&gt;4以后错误比例基本为0了。</p>
<h1 id="参考链接">参考链接</h1>
<ul>
<li><a href="http://home.ustc.edu.cn/~zzy0929/CSAlg22/">课程主页</a></li>
<li><a href="https://blog.csdn.net/jackzhang11/article/details/109479996">算法作业之概率算法&amp;近似算法（中科大黄刘生总裁版）</a></li>
<li><a href="https://github.com/1970633640/Design-and-Analysis-of-Algorithm">中国科学技术大学算法设计与分析课程作业</a></li>
</ul>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>概率</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统作业2</title>
    <url>/post/12d42946.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——计算机系统作业2的题目解答记录。使用的教材为《深入理解计算机系统》（第3版）。</p>
<span id="more"></span>
<h1 id="题目与解答">题目与解答</h1>
<h2 id="section">3.58</h2>
<p>一个函数的原型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span>;</span><br></pre></td></tr></table></figure>
<p>GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decode2:</span><br><span class="line">	subq 	%rdx, %rsi</span><br><span class="line">	imulq 	%rsi, %rdi</span><br><span class="line">	movq 	%rsi, %rax</span><br><span class="line">	salq 	$63,%rax</span><br><span class="line">	sarq 	$63, %rax</span><br><span class="line">	xorq 	%rdi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>参数x 、y 和z 通过寄存器%rdi、%rsi 和 %rdx
传递。代码将返回值存放在寄存器%rax 中。写出等价于上述汇编代码的decode2
的C代码。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> tmp = y - z;</span><br><span class="line">  <span class="keyword">return</span> (tmp * x) ^ (tmp &lt;&lt; <span class="number">63</span> &gt;&gt; <span class="number">63</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-1">3.60</h2>
<p>考虑下面的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span></span><br><span class="line">x in%rdi, n in%esi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop :</span><br><span class="line">	movl	%esi, %ecx</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	jmp		.L2</span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdi, %r8</span><br><span class="line">	andq	%rdx, %r8</span><br><span class="line">	orq		%r8, %rax</span><br><span class="line">	salq	%cl, %rdx</span><br><span class="line">.L2:</span><br><span class="line">	testq %rdx, %rdx</span><br><span class="line">	jne .L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>以上代码是编译以下整体形式的C 代码产生的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop2</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____________;</span><br><span class="line">    <span class="type">long</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (mask = ____________; mask ____________; mask =____________)&#123;</span><br><span class="line">        result |= ____________;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的任务是填写这个C
代码中缺失的部分，得到一个程序等价于产生的汇编代码。回想一下，这个函数的结果是在寄存器%rax
中返回的。你会发现以下工作很有帮助：检查循环之前、之中和之后的汇编代码，形成一个寄存器和程序变最之间一致的映射。</p>
<p>A. 哪个寄存器保存着程序值x 、n 、result 和mask?</p>
<p>B. result 和mask 的初始值是什么？</p>
<p>C. mask 的测试条件是什么？</p>
<p>D. mask 是如何被修改的？</p>
<p>E. result 是如何被修改的？</p>
<p>F. 填写这段C 代码中所有缺失的部分。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">变量</th>
<th style="text-align: left;">寄存器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">x</td>
<td style="text-align: left;">%rdi</td>
</tr>
<tr class="even">
<td style="text-align: left;">n</td>
<td style="text-align: left;">%esi</td>
</tr>
<tr class="odd">
<td style="text-align: left;">result</td>
<td style="text-align: left;">%rax</td>
</tr>
<tr class="even">
<td style="text-align: left;">mask</td>
<td style="text-align: left;">%rdx</td>
</tr>
</tbody>
</table>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line">mask = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mask != <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="A">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mask = mask &lt;&lt; n</span><br></pre></td></tr></table></figure>
<ol start="5" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop2</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> mask;</span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">1</span>; mask != <span class="number">0</span>; mask &lt;&lt;= n) &#123;</span><br><span class="line">    result |= (x &amp; mask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-2">3.63</h2>
<p>这个程序给你一个机会，从反汇编机器代码逆向工程一个switch
语句。在下面这个过程中，去掉了switch 语句的主体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">    <span class="comment">/* Fill in code here */</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出了这个过程的反汇编机器代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span> <span class="params">(<span class="type">long</span> x,<span class="type">long</span> n)</span></span><br><span class="line">x in%rdi , n in%rsi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400590 &lt;switch_prob&gt;:</span><br><span class="line">400590: 48 83 ee 3c				sub		$0x3c,%rsi</span><br><span class="line">400594: 48 83 fe 05				cmp		$0x5,%rsi</span><br><span class="line">400598: 77 29					ja		4005c3 &lt;switch_prob+0x33&gt;</span><br><span class="line">40059a: ff 24 f5 f8 06 40 00	jmpq	*0x4006f8(,%rsi,8)</span><br><span class="line">4005a1: 48 8d 04 fd 00 00 00	lea		0x0 (,%rdi,8),%rax</span><br><span class="line">4005a8: 00</span><br><span class="line">4005a9: c3						retq	</span><br><span class="line">4005aa: 48 89 f8				mov		%rdi,%rax</span><br><span class="line">4005ad: 48 c1 f8 03				sar		$0x3,%rax</span><br><span class="line">4005b1: c3						retq	</span><br><span class="line">4005b2: 48 89 f8				mov		%rdi,%rax</span><br><span class="line">4005b5: 48 c1 eO 04				shl		$0x4,%rax</span><br><span class="line">4005b9: 48 29 f8				sub		%rdi,%rax</span><br><span class="line">4005bc: 48 89 c7				mov		%rax,%rdi</span><br><span class="line">4005bf: 48 Of af ff				imul	%rdi,%rdi</span><br><span class="line">4005c3: 48 8d 47 4b				lea		Ox4b(%rdi),%rax</span><br><span class="line">4005c7: c3						retq	</span><br></pre></td></tr></table></figure>
<p>跳转表驻留在内存的不同区域中。可以从第5
行的间接跳转看出来，跳转表的起始地址为0x4006f8 。用调试器GDB,
我们可以用命令x/6gx 0x4006f8 来检查组成跳转表的6个8 字节字的内存。GDB
打印出下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/6gx 0x4006f8</span><br><span class="line">0x4006f8: 0x00000000004005a1 	0x00000000004005c3</span><br><span class="line">0x400708: 0x00000000004005a1 	0x00000000004005aa</span><br><span class="line">0x400718: 0x00000000004005b2	0x00000000004005bf</span><br></pre></td></tr></table></figure>
<p>用C 代码填写开关语句的主体，使它的行为与机器代码一致。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            result = <span class="number">8</span>*x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">63</span>:</span><br><span class="line">            result = x&gt;&gt;<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            result= (x&lt;&lt;<span class="number">4</span>)-x;</span><br><span class="line">            x=result;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">            x=x*x;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0x4B</span>+x;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-3">3.69</h2>
<p>你负责维护一个大型的C 程序，遇到下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    a_struct a[CNT];</span><br><span class="line">    <span class="type">int</span> last;</span><br><span class="line">&#125; b_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> i, b_struct *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = bp-&gt;first + bp-&gt;last;</span><br><span class="line">    a_struct *ap = &amp;bp-&gt;a[i];</span><br><span class="line">    ap-&gt;x[ap-&gt;idx] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时常数CNT 和结构a_struct
的声明是在一个你没有访问权限的文件中。幸好，你有代码的'.o'版本，可以用OBJDUMP
程序来反汇编这些文件，得到下面的反汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span> <span class="params">(<span class="type">long</span> i, b_struct *bp)</span></span><br><span class="line">i in %rdi, bp in %rsi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx</span><br><span class="line">	S: 4S Sd 04 bf			lea 	(%rdi,%rdi,4),%rax</span><br><span class="line">	c: 4S Sd 04 c6			lea 	(%rsi,%rax,8),%rax</span><br><span class="line">	10: 4S Sb 50 OS			mov 	Ox8(%rax),%rdx</span><br><span class="line">	14: 4S 63 c9			movslq	%ecx,%rcx</span><br><span class="line">	17: 48 89 4c dO 10		mov		%rcx,0x10(%rax,%rdx,8)</span><br><span class="line">	le: c3					retq</span><br></pre></td></tr></table></figure>
<p>运用你的逆向工程技术，推断出下列内容：</p>
<p>A. CNT 的值。</p>
<p>B. 结构a_struct 的完整声明。假设这个结构中只有字段idx 和x ,
并且这两个字段保存的都是有符号值。</p>
<p><strong>解：</strong></p>
<p>A. 7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx  # Get bp-&gt;last</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx # n = bp-&gt;first</span><br></pre></td></tr></table></figure>
<p>int
类型4字节，还需要进行对齐，所以占8字节，剩下的都是数组<code>a_struct a[CNT];</code>的空间，
<code>CNT*40 + 8 = 288 = 0x120</code>，所以<code>CNT = 7</code>。</p>
<ol start="2" type="A">
<li></li>
</ol>
<p>分析汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx # get n</span><br><span class="line">	S: 4S Sd 04 bf			lea 	(%rdi,%rdi,4),%rax  # compute 5*i</span><br><span class="line">	c: 4S Sd 04 c6			lea 	(%rsi,%rax,8),%rax  # compute bp+40*i</span><br><span class="line">	10: 4S Sb 50 OS			mov 	Ox8(%rax),%rdx # Get bp-&gt;a[i].idx</span><br><span class="line">	14: 4S 63 c9			movslq	%ecx,%rcx # shift n from 32b to 64b</span><br><span class="line">	17: 48 89 4c dO 10		mov		%rcx,0x10(%rax,%rdx,8) # mov n to ap-&gt;x[ap-&gt;idx] </span><br><span class="line">	le: c3					retq</span><br></pre></td></tr></table></figure>
<p>第6行得到idx的值，这里使用的%rdx寄存器，所以应该是long类型；由第一小问可以知道<code>a_struct</code>的大小为40字节，第7行将n从32字节转为64，所以数组x应该是long类型，并且为4个。所以<code>a_struct</code>的完整声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> idx;</span><br><span class="line">  <span class="type">long</span> x[<span class="number">4</span>];</span><br><span class="line">&#125; a_struct;</span><br></pre></td></tr></table></figure>
<h2 id="section-4">3.70</h2>
<p>考虑下面的联合声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">ele</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> *p;</span><br><span class="line">        <span class="type">long</span> y;</span><br><span class="line">    &#125; e1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> x;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">ele</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; e2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个声明说明联合中可以嵌套结构。下面的函数（省略了一些表达式）对一个链表进行操作，链表是以上述联合作为元素的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="keyword">union</span> ele *up)</span>&#123;</span><br><span class="line">    up-&gt;___________= *(___________) - ___________;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 下列字段的偏移址是多少（以字节为单位）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1.p    _____________</span><br><span class="line">e1.y	_____________</span><br><span class="line">e2.x	_____________</span><br><span class="line">e2.next	_____________</span><br></pre></td></tr></table></figure>
<p>B. 这个结构总共需要多少个字节？</p>
<p>C. 编译器为proc 产生下面的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span> <span class="params">(<span class="keyword">union</span> ele *up)</span></span><br><span class="line">up in %rdi</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proc:</span><br><span class="line">	movq	8(%rdi), %rax</span><br><span class="line">	movq	(%rax) , %rdx</span><br><span class="line">	movq	(%rdx), %rdx</span><br><span class="line">	subq	8(%rax), %rdx</span><br><span class="line">	movq	%rdx, (%rd)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>在这些信息的基础上，填写proc
代码中缺失的表达式。提示：有些联合引用的解释可以有歧义，当你清楚引用指引到哪里的时候，就能够澄清这些歧义。只有一个答案，不需要进行强制类型转换，且不违反任何类型限制。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1.p    <span class="number">0</span></span><br><span class="line">e1.y	<span class="number">8</span></span><br><span class="line">e2.x	<span class="number">0</span></span><br><span class="line">e2.next	<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>B. 共需要8字节。</p>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="keyword">union</span> ele *up)</span>&#123;</span><br><span class="line">    up-&gt;e2.x= *((up-&gt;e2.next)-&gt;e1.p) - (up-&gt;e2.next)-&gt;e1.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p><a href="https://dreamanddead.github.io/CSAPP-3e-Solutions/">CSAPP-3E-SOLUTIONS</a></p>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统作业1</title>
    <url>/post/8bdd78fc.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——计算机系统作业1的题目解答记录。使用的教材为《深入理解计算机系统》（第3版）。</p>
<span id="more"></span>
<h1 id="题目与解答">题目与解答</h1>
<h2 id="section">2.58</h2>
<p>编写过程is_little_endian, 当在小端法机器上编译和运行时返回1,
在大端法机器上编译运行时则返回0
。这个程序应该可以运行在任何机器上，无论机器的字长是多少。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer; <span class="comment">// 定义一个字节指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_little_endian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0xff</span>;                          <span class="comment">// 存储在内存中为 0x00 0x00 0x00 0xff</span></span><br><span class="line">    byte_pointer start = (byte_pointer)&amp;num; <span class="comment">// 强制转换为四个字节数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start[<span class="number">0</span>] == <span class="number">0xff</span>) <span class="comment">// 小端模式读取的第一个字节为0xff</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 大端模式读取的第一个字节为0x00</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, is_little_endian());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-1">2.61</h2>
<p>写一个C 表达式，在下列描述的条件下产生1, 而在其他情况下得到0
。假设x是int类型。</p>
<p>A. x的任何位都等于1 。</p>
<p>B. x的任何位都等于0 。</p>
<p>C. x的最低有效字节中的位都等于1 。</p>
<p>D. x的最高有效字节中的位都等于0 。</p>
<p>代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（==）和不相等（!=）测试。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!~x</span><br></pre></td></tr></table></figure>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!x</span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!((~x)&amp;<span class="number">0xff</span>)  或</span><br><span class="line">!~(x|~<span class="number">0xff</span>)</span><br></pre></td></tr></table></figure>
<ol start="4" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!((x &gt;&gt; ((<span class="keyword">sizeof</span>(<span class="type">int</span>)<span class="number">-1</span>) &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure>
<h2 id="section-2">2.77</h2>
<p>假设我们有一个任务：生成一段代码，将整数变量x 乘以不同的常数因子K
。为了提高效率，我们想只使用 + 、-
和&lt;&lt;运算。对于下列K的值，写出执行乘法运算的C表达式，每个表达式中最多使用3个运算。</p>
<p>A. K=17</p>
<p>B. K=-7</p>
<p>C. K=60</p>
<p>D. K=-112</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">4</span>)+x</span><br></pre></td></tr></table></figure>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x-(x&lt;&lt;<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">6</span>)-(x&lt;&lt;<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ol start="4" type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">4</span>)-(x&lt;&lt;<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h2 id="section-3">2.84</h2>
<p>填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数f2u
返回一个无符号32
位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是NaN 。两种0,
+0 和-0 被认为是相等的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">float_le</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> ux = f2u(x);</span><br><span class="line">    <span class="type">unsigned</span> uy = f2u(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Get the sign bits*/</span> </span><br><span class="line">    <span class="type">unsigned</span> sx = ux &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="type">unsigned</span> sy = uy &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="comment">/*Give an expression using only ux, uy, sx, and sy*/</span></span><br><span class="line">    <span class="keyword">return</span>   ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">f2u</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> *)&amp;x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">float_le：测试它的第一个参数是否小于或者等于第二个参数 x&lt;=y 则 true </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">float_le</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将浮点数按照无符号数解释（位不变）</span></span><br><span class="line">    <span class="type">unsigned</span> ux = f2u(x);</span><br><span class="line">    <span class="type">unsigned</span> uy = f2u(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得符号位 0或1</span></span><br><span class="line">    <span class="type">unsigned</span> sx = ux &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">unsigned</span> sy = uy &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四种x&lt;=y的情况返回true</span></span><br><span class="line">    <span class="keyword">return</span> (ux &lt;&lt; <span class="number">1</span> == <span class="number">0</span> &amp;&amp; uy &lt;&lt; <span class="number">1</span> == <span class="number">0</span>) || <span class="comment">// 1. +0或者-0都为0(左移一位去除符号位对0影响)</span></span><br><span class="line">           (sx &amp;&amp; !sy) ||                    <span class="comment">// 2. x为负（符号位sx为1），y为正（符号位sy为0）</span></span><br><span class="line">           (!sx &amp;&amp; !sy &amp;&amp; ux &lt;= uy) ||       <span class="comment">// 3. x,y都为正时，x&lt;=y等价于ux&lt;=uy</span></span><br><span class="line">           (sx &amp;&amp; sy &amp;&amp; ux &gt;= uy);           <span class="comment">// 4. x,y都为负时，x&lt;=y等价于ux&gt;=uy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-4">2.89</h2>
<p>我们在一个int 类型为32
位补码表示的机器上运行程序。float类型的值使用32 位IEEE 格式，而double
类型的值使用64 位IEEE 格式。我们产生随机整数x 、y 和z,
并且把它们转换成double 类型的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Create some arbitrary values*/</span></span><br><span class="line"><span class="type">int</span> x = random();</span><br><span class="line"><span class="type">int</span> y = random();</span><br><span class="line"><span class="type">int</span> z = random();</span><br><span class="line"><span class="comment">/*Convert to double*/</span></span><br><span class="line"><span class="type">double</span> dx = (<span class="type">double</span>)x;</span><br><span class="line"><span class="type">double</span> dy = (<span class="type">double</span>)y;</span><br><span class="line"><span class="type">double</span> dz = (<span class="type">double</span>)z;</span><br></pre></td></tr></table></figure>
<p>对于下列的每个C 表达式，你要指出表达式是否总是为1 。如果它总是为1,
描述其中的数学原理。否则，列举出使它为0的参数的例子。请注意，不能使用IA32
机器运行GCC 来测试你的答案，因为对于float 和double, 它使用的都是80
位的扩展精度表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A. (<span class="type">float</span>)x==(<span class="type">float</span>)dx</span><br><span class="line">B. dx-dy==(<span class="type">double</span>)(x-y)</span><br><span class="line">C. (dx+dy)+dz==dx+(dy+dz)</span><br><span class="line">D. (dx*dy)*dz==dx*(dy*dz)</span><br><span class="line">E. dx/dx==dz/dz</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<p>A. 真。int类型转成double类型不会损失精度，此时，x 和 dx
转成float类型虽然可能会损失精度，但是在舍入原则相同的情况下得到的结果相同。</p>
<p>B.
假。当x-y得到的结果溢出时，转成double类型的结果与真实结果不同，如y=INT_MIN时。</p>
<p>C.
真。两个int类型转成double类型后，相加得到的结果仍然在double类型可表示范围内，且不会因为舍入丢失精度，所以是可以结合的。</p>
<p>D.
假。两个int类型转成double类型后，相乘得到的结果不一定在double类型可表示范围内，可能会发生溢出或者由于舍入导致失去精度，所以不具有结合性。</p>
<p>E. 假。当dx != 0 且 dz ==
0时，左边结果为1，右边结果为无穷大，不相等。</p>
<h2 id="section-5">2.91</h2>
<p>大约公元前250 年，希腊数学家阿基米德证明了<span class="math inline">\(\frac{223}{71}&lt;\pi&lt;\frac{22}{7}\)</span>。如果当时有一台计算机和标准库&lt;math.h&gt;,
他就能够确定<span class="math inline">\(\pi\)</span>的单精度浮点近似值的十六进制表示为
0x40490FDB 。当然，所有的这些都只是近似值，因为<span class="math inline">\(\pi\)</span>不是有理数。</p>
<p>A. 这个浮点值表示的二进制小数是多少？</p>
<p>B. <span class="math inline">\(\frac{22}{7}\)</span>的二进制小数表示是什么？提示：参见家庭作业2.
83 。</p>
<p>C. 这两个<span class="math inline">\(\pi\)</span>的近似值从哪一位（相对于二进制小数点）开始不同的？</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">十六进制：</span><br><span class="line">    <span class="number">0x40490FDB</span></span><br><span class="line">二进制：</span><br><span class="line">    <span class="number">0100</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">1001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1101</span> <span class="number">1011</span></span><br><span class="line">浮点格式：</span><br><span class="line">    <span class="number">0</span> <span class="number">10000000</span> <span class="number">10010010000111111011011</span>    </span><br><span class="line">    s:<span class="number">0</span> e=<span class="number">2</span>^<span class="number">7</span>=<span class="number">128</span> E=<span class="number">128</span><span class="number">-127</span>=<span class="number">1</span> f=<span class="number">0.10010010000111111011011</span> M=<span class="number">1.10010010000111111011011</span></span><br><span class="line">二进制小数：</span><br><span class="line">    <span class="number">11.0010010000111111011011</span></span><br></pre></td></tr></table></figure>
<p>B. <span class="math inline">\(\frac{22}{7}=3+\frac{1}{7}\)</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Y=<span class="number">1</span>，<span class="number">2</span>^k<span class="number">-1</span>=<span class="number">7</span>,k=<span class="number">3</span>,y=<span class="number">001</span></span><br><span class="line">二进制小数：<span class="number">11.001001001</span>...(y=<span class="number">001</span>)</span><br></pre></td></tr></table></figure>
<p>C. 从小数点后第9位开始不同。</p>
<h1 id="参考">参考</h1>
<p><a href="https://dreamanddead.github.io/CSAPP-3e-Solutions/">CSAPP-3E-SOLUTIONS</a></p>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统作业4</title>
    <url>/post/fbb78c73.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——计算机系统作业4的题目解答记录。使用的教材为《深入理解计算机系统》（第3版）。</p>
<span id="more"></span>
<h1 id="题目与解答">题目与解答</h1>
<h2 id="section">7.7</h2>
<p>不改变任何变量名字，修改 7. 6. 1 节中的 bar5.c, 使得 foo5.c 输出 x 和
y 的正确值（也就是整数 15213 和 15212 的十六进制表示）。</p>
<p>7.6.1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* foo5.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = <span class="number">15212</span>;</span><br><span class="line"><span class="type">int</span> X = <span class="number">15213</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	f();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = 0x%x y = 0x%x \n&quot;</span>,x, y);</span><br><span class="line">	<span class="keyword">return</span> O;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bar5.c*/</span></span><br><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong>将bar5.c中的x声明为静态变量，使其链接为内部链接，只在当前文件中起作用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* bar5.c (修改后)*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> x; <span class="comment">// 将bar5.c中的x声明为静态变量，使其链接为内部链接，只在当前文件中起作用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">-0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="section-1">7.8</h2>
<p>在此题中， REF(x.i)----&gt;DEF(x.k) 表示链接器将任意对模块 i 中符号 x
的引用与模块 k 中符号 x
的定义相关联。在下面每个例子中，用这种符号来说明链接器是如何解析在每个模块中有多重定义的引用的。如果出现链接时错误（规则
1) 写"错误（ERROR）"。如果链接器从定义中任意选择一个(规则 3)
那么写"未知（unkown）"。</p>
<p><strong>解：</strong></p>
<p>A. 链接器选择定义在模块 1 中的强符号，而不是定义在模块 2
中的弱符号（规则 2)</p>
<ol type="a">
<li><p>REF(main.1) -&gt; DEF(main.1)</p></li>
<li><p>REF(main.2) -&gt; DEF(main.2)</p></li>
</ol>
<p>B. 模块1，2中的 x
均为弱符号，如果有多个弱符号同名，那么从这些弱符号中任意选择一个（规则
3) 。</p>
<ol type="a">
<li><p>REF(x.1) -&gt; DEF(unkown)</p></li>
<li><p>REF(x.2) -&gt; DEF(unkown)</p></li>
</ol>
<p>C. 这是一个错误，因为每个模块都定义了一个强符号 x ( 规则 1) 。</p>
<ol type="a">
<li><p>REF(x.1) -&gt; DEF(ERROR)</p></li>
<li><p>REF(x.2) -&gt; DEF(ERROR)</p></li>
</ol>
<h2 id="section-2">7.10</h2>
<p>a 和 b 表示当前路径中的目标模块或静态库，而 a---&gt;b 表示 a 依赖于
b, 也就是说 a 引用了一个 b
定义的符号。对于下面的每个场景，给出使得静态链接器能够解析所有符号引用的最小的命令行（即含有最少数量的目标文件和库参数的命令）。</p>
<ol type="A">
<li><p>p.o---&gt;libx.a---&gt;p.o</p></li>
<li><p>p.o---&gt;libx.a---&gt;liby.a 和 liby.a---&gt;libx.a</p></li>
<li><p>p.o---&gt;libx.a---&gt;liby.a---&gt;libz.a 和
liby.a---&gt;linx.a---&gt;libz.a</p></li>
</ol>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc p.o libx.a</span><br></pre></td></tr></table></figure>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc p.o libx.a liby.a libx.a</span><br></pre></td></tr></table></figure>
<ol start="3" type="A">
<li></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc p.o libx.a liby.a libx.a libz.a </span><br></pre></td></tr></table></figure>
<h2 id="section-3">7.12</h2>
<p>考虑目标文件 m.o 中对函数 swap 的调用（作业题 7. 6) 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9: e8 00 00 00 00		callq e &lt;main+0xe&gt; swap()</span><br></pre></td></tr></table></figure>
<p>具有如下重定位条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r.offset = 0xa</span><br><span class="line">r.symbol = swap</span><br><span class="line">r.type = R_X86_64_PC32</span><br><span class="line">r.addend = -4</span><br></pre></td></tr></table></figure>
<p>A. 假设链接器将 m.o 中的 .text 重定位到地址 0x4004e0, 把 swap
重定位到地址 0x4004f8 。那么callq 指令中对 swap
的重定位引用的值应该是什么？</p>
<p>B. 假设链接器将 m.o 中的 .text 重定位到地址 0x4004d0, 把 swap
重定位到地址 0x400500 。那么callq 指令中对 swap
的重定位引用的值应该是什么？</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = 0x4004e0</span><br><span class="line">ADDR(r.symbol) = ADDR(swap) = 0x4004f8 </span><br></pre></td></tr></table></figure>
<p>链接器首先计算引用的运行时地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">		= 0x4004e0 + 0xa</span><br><span class="line">		= 0x4004ea</span><br></pre></td></tr></table></figure>
<p>然后修改此引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">		= (unsigned) (0x4004f8 + (-4) - 0x4004ea)</span><br><span class="line">		= (unsigned) (0xa)</span><br></pre></td></tr></table></figure>
<p>因此，得到的可执行目标文件中，对 swap 的 PC 相对引用的值为 0xa</p>
<ol start="2" type="A">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDR(s) = ADDR(.text) = 0x4004d0</span><br><span class="line">ADDR(r.symbol) = ADDR(swap) = 0x400500 </span><br></pre></td></tr></table></figure>
<p>链接器首先计算引用的运行时地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">		= 0x4004d0 + 0xa</span><br><span class="line">		= 0x4004da</span><br></pre></td></tr></table></figure>
<p>然后修改此引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">		= (unsigned) (0x400500 + (-4) - 0x4004da)</span><br><span class="line">		= (unsigned) (0x22)</span><br></pre></td></tr></table></figure>
<p>因此，得到的可执行目标文件中，对 swap 的 PC 相对引用的值为 0x22</p>
<h2 id="section-4">8.13</h2>
<p>下面程序的一种可能的输出是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* code/ecflforkprob3.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(Fork()!=<span class="number">0</span>) <span class="comment">// Fork() 是 fork() 函数的错误处理包装函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,++x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,--x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<ul>
<li>fork
函数只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，
fork 返回子进程的 PID 。在子进程中，fork 返回 0
。父进程和子进程是并发运行的独立进程，都有自己的私有地址空间。</li>
<li>当 fork 调用在第 6 行返回时，在父进程和子进程中 x 的值都为
3，子进程在第 7 行加一并输出它的 x 的副本。相似地，父进程在第 8
行减一并输出它的 x 的副本。</li>
</ul>
<p>所以最终可能输出：（保证4在3前面）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># case1:</span><br><span class="line">x=<span class="number">4</span>; <span class="comment">// 父进程执行第7行printf语句</span></span><br><span class="line">x=<span class="number">3</span>; <span class="comment">// 父进程执行第8行printf语句</span></span><br><span class="line">x=<span class="number">2</span>; <span class="comment">// 子进程执行第8行printf语句</span></span><br><span class="line"></span><br><span class="line"># case2:</span><br><span class="line">x=<span class="number">4</span>; <span class="comment">// 父进程执行第7行printf语句</span></span><br><span class="line">x=<span class="number">2</span>; <span class="comment">// 子进程执行第8行printf语句</span></span><br><span class="line">x=<span class="number">3</span>; <span class="comment">// 父进程执行第8行printf语句</span></span><br><span class="line"></span><br><span class="line"># case3:</span><br><span class="line">x=<span class="number">2</span>; <span class="comment">// 子进程执行第8行printf语句</span></span><br><span class="line">x=<span class="number">4</span>; <span class="comment">// 父进程执行第7行printf语句</span></span><br><span class="line">x=<span class="number">3</span>; <span class="comment">// 父进程执行第8行printf语句</span></span><br></pre></td></tr></table></figure>
<h2 id="section-5">8.15</h2>
<p>下面这个程序会输出多少个 "hello" 输出行？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* code/ecf/forkprob6.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        Fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    doit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<p><img src="/post/fbb78c73/hw4.svg"></p>
<p>所以共输出5个"hello"行</p>
<h2 id="section-6">8.18</h2>
<p>考虑下面的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* code/ecflforkprob2.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">end</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Fork()==<span class="number">0</span>)</span><br><span class="line">        atexit(end);</span><br><span class="line">    <span class="keyword">if</span>(Fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断下面哪个输出是可能的。注意： atexit
函数以一个指向函数的指针为输入，并将它添加到函数列表中（初始为空），当
exit 函数被调用时，会调用该列表中的函数。</p>
<p>A. 112002 B. 211020 C. 102120 D. 122001 E. 100212</p>
<p><strong>解：</strong></p>
<p><img src="/post/fbb78c73/hw4-2.svg"></p>
<p>构成拓扑排序的只有ACE正确。</p>
<p>B中的第一个不可能是2。D中的第一个1后面不可能有两个2。</p>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>CSAPP</tag>
        <tag>链接</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统实验1&amp;2&amp;3</title>
    <url>/post/ba783922.html</url>
    <content><![CDATA[<p>本文记录中科大研究生课程——计算机系统的相关实验，使用的教材为《深入理解计算机系统》第3版。课程给的实验材料貌似用的是第2版的，额外添加了一些实验要求和说明，但是原理和思想基本都是一样的。</p>
<span id="more"></span>
<h1 id="实验1位操作data-lab">实验1：位操作（Data Lab）</h1>
<h2 id="实验介绍">实验介绍</h2>
<p>本实验考察计算机信息的表示，要求实现简单的位操作、逻辑运算、二进制补码和浮点函数，并且限制了可使用的
C 操作符和数量，有助于理解 C
数据类型的位级表示以及数据操作的位级行为。本实验总共包括位操作的15个编程题。</p>
<h2 id="实验环境">实验环境</h2>
<table>
<thead>
<tr class="header">
<th>CPU</th>
<th>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>操作系统</td>
<td>Ubuntu 20.04.3 (64位)</td>
</tr>
<tr class="even">
<td>C/C++编译器</td>
<td>gcc version 9.4.0</td>
</tr>
</tbody>
</table>
<h2 id="实验要求">实验要求</h2>
<p>"bits.c"文件中包含需要实现的15个函数，文件中规定了实现每个函数需要的逻辑和算术操作符（规定数量）。</p>
<ul>
<li>只能使用规定的操作符
<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>不能使用循环或者条件语句</li>
<li>不能使用超过8位的常数 <code>0xff</code></li>
</ul>
<h2 id="实验思路">实验思路</h2>
<h3 id="bitxor">1. bitXor</h3>
<p>本题要求使用按位与<code>&amp;</code>和按位取反<code>~</code>实现按位异或。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">return</span> ~(~x &amp; ~y) &amp; ~(x &amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异或就是当参与运算的两个二进制数不同时结果才为1，其他情况为0。</p>
<p>根据德摩根定律（参考离散数学集合论知识）：</p>
<p><img src="/post/ba783922/c2f4430bd910acad95a9e1ea734ec185.svg"></p>
<p>推导出：</p>
<p><img src="/post/ba783922/image-20221030174706082.png" alt style="zoom: 50%;"></p>
<p>转换为C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x^y=~(~x&amp;~y)&amp;~(x&amp;y)</span><br></pre></td></tr></table></figure>
<h3 id="tmin">2. tmin</h3>
<p>求int类型的最小值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C 语言中 <code>int</code> 类型是32位，即4字节数 。<code>int</code>
类型的最小值，即最高位符号位为 1，其他位均为 0，所以只需要将 1 左移 31
位。</p>
<h3 id="istmax">3. isTmax</h3>
<p>判断输入值是否为 int 类型的最大值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~(x+<span class="number">1</span>)^x))&amp;!!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑四位的最大值<code>x=0111</code>
，x+1之后就会变成<code>1000</code> ，对<code>1000</code> 取非
<code>0111</code>
就会重新变回x值，自己与自己异或会得到0，所以可以用异或来判断<code>~(x+1)</code>与<code>x</code>是否相等，从而判断是否为x最大值。</p>
<blockquote>
<p>小技巧：等号的操作可以直接利用<code>a == b</code> 等价于
<code>!(a ^b)</code></p>
</blockquote>
<p>这里有一个例外就是<code>x=-1</code> ，由于<code>-1=1111</code>
他利用上面的式子判断也符合，故要特判-1 利用<code>!!(x+1)</code>
这个操作-1和最大值并不相同。</p>
<h3 id="alloddbits">4. allOddBits</h3>
<p>判断所有奇数位是否都为1，这里的奇数指的是位的阶级是2的几次幂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0xAA</span> + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  mask = mask + (mask &lt;&lt; <span class="number">16</span>); <span class="comment">// 迭代两次得到奇数位全1的掩码</span></span><br><span class="line">  <span class="keyword">return</span> !((mask &amp; x) ^ mask); <span class="comment">// 即判断 mask&amp;x == mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要构造掩码，使用移位运算符构造出奇数位全1的数 <code>mask</code>
，然后获取输入 <code>x</code>
值的奇数位，其他位清零（<code>mask&amp;x</code>），然后与
<code>mask</code>
进行异或操作，若相同则最终结果为0，然后返回其值的逻辑非。</p>
<h3 id="negate">5. negate</h3>
<p>不使用 <code>-</code> 操作符，求 <code>-x</code> 值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 补码等于反码加1</span></span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补码实际上是一个阿贝尔群，满足性质公式：<code>A + ~A = -1</code>和<code>A + neg A =0</code>，利用这两个式子我们可以得到
<code>neg A = ~A + 1</code>，对于 <code>x</code>，<code>-x</code>
是其补码，所以 <code>-x</code> 可以通过对 <code>x</code>
取反加1得到。</p>
<h3 id="isasciidigit">6. isAsciiDigit</h3>
<p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值，即计算
<code>x</code> 是否在 0x30 ~ 0x39 范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; <span class="number">0xf0</span>) ^ <span class="number">0x30</span>) &amp; !(((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>) &amp; !(x &amp; (~<span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别对低位和高位字节进行判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 低位第2字节 是否等于0x30 是则返回0</span></span><br><span class="line"><span class="type">int</span> res2 = (x &amp; <span class="number">0xf0</span>)^<span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 低位第1字节 在+6以后是否不进位 不进位说明在0~9之间 是则返回0</span></span><br><span class="line"><span class="type">int</span> res1 = ((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断其他高位字节 是否等于0 是则返回0</span></span><br><span class="line"><span class="type">int</span> res3 = x &amp; (~<span class="number">0xff</span>);s</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后综合在一起</span></span><br><span class="line"><span class="keyword">return</span> !res1 &amp; !res2 &amp; !res3;</span><br></pre></td></tr></table></figure>
<h3 id="conditional">7. conditional</h3>
<p>实现类似<code>x?y:z</code>的条件计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = (!x)<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (y | ~mask) &amp; (z | mask) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>x?y:z</code>表示当x为0时返回y，当x不为0时返回z；</p>
<p>（1）先使用<code>！</code>对<code>x</code>进行判断，得到布尔值0或1，再减1可分别得到<code>0xffffffff</code>和<code>0x0</code></p>
<p>（2）构造<code>y | ~mask</code>，此时当mask=<code>0xffffffff</code>时取y，当mask=<code>0x0</code>时取<code>0xffffffff</code>;对称构造<code>z | mask</code>,此时当mask=<code>0xffffffff</code>时取<code>0xffffffff</code>，当mask=<code>0x0</code>时取z;用<code>&amp;</code>连接即可满足条件。</p>
<h3 id="islessorequal">8. isLessOrEqual</h3>
<p>实现小于等于比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取x和y的符号值 默认是算术右移 负数----1111 正数-----0000</span></span><br><span class="line">  <span class="type">int</span> sx = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sy = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 判断符号是否相同  相同----0000 不同-----1111</span></span><br><span class="line">  <span class="type">int</span> mask = sx ^ sy;</span><br><span class="line">  <span class="comment">// 在符号相同时 判断y-x值的符号 y&lt;x---0000---0 y&gt;=x---1111---1</span></span><br><span class="line">  <span class="type">int</span> sm = (y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 符号不同时 判断sx sx=1111---x&lt;y---1  sx=0000----x&gt;y---0</span></span><br><span class="line">  <span class="keyword">return</span> !!((mask &amp; sx) | (~mask &amp; ~sm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="logicalneg">9. logicalNeg</h3>
<p>实现逻辑非运算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0与其他整数的区别是，0的负数仍然为0，而其他整数求负数后符号改变。这里要考虑一个特例，当x为最小值<code>0x80000000</code>时，x的负数仍然为最小值，最高位虽然不变但是仍为1。综上，除0以外，x和其负数的最高位中必有一个是1。</p>
<p>int类型中负数用补码表示，求补码即反码加一，构造<code>(x | (~x + 1))</code>操作，只有<code>x=0</code>时最高位保持
0，利用这一点，求反后右移保留最高位，检测该位是否为 1
就可以实现逻辑非。</p>
<h3 id="howmanybits">10. howManyBits</h3>
<p>计算最少需要多少位可以用补码表示法来表示数<code>x</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是正数，寻找最高位1出现的位置，然后加上一位符号位即可。如果是负数的话，只需要知道最高位
0
出现的位置，再添加一个符号位。所以负数可以先对其取反，然后按照正数操作。</p>
<p>寻找过程为 2
分法，利用<code>!!(x &gt;&gt; bits)</code>来判断该段是否有
1。有则左移至该段，否则不移动即另一端。注意最后 2
位的情况，<code>11</code>和<code>10</code>都会使<code>ans1 = 1</code>且<code>ans0 = 1</code>，事实上只有全
0（数
0）的情况会使<code>ans0 = 0</code>。最后注意需要加上一个符号位，最终答案把移位结果累加<code>ans16 + ans8 + ans4 + ans2 + ans1 + ans0 + 1</code>。</p>
<h3 id="floatscale2">11. floatScale2</h3>
<p>实现浮点数乘 2。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 分别计算 指数位 符号位 有效位</span></span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="comment">// 分三种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// NaN</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// mult 2</span></span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;</span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// overflow Nan</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | sign | frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IEEE标准32位浮点数格式为：最高位 1
位为<strong>符号位</strong>（sign），8
为为<strong>指数位</strong>（exp），剩下的 23
位为<strong>有效位</strong>（frac）。</p>
<p>根据浮点数范围，浮点数乘2需要分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN ，无穷大，乘2仍然返回原参数；</li>
<li><code>exp == 0x00</code>：非规格数，这时候 frac 无起始 1，乘2即将
frac 部分左移 1
位，同时还需要考虑符号，整体运算等价于<code>(uf &lt;&lt; 1) | sign</code></li>
<li><code>exp == others</code>：
规格化情况，先增加指数位，注意这时候判断是否为 0xff
达到无穷大。按位模式组合成新的浮点数输出即可<code>(exp &lt;&lt; 23) | sign | frac</code>。</li>
</ul>
<h3 id="floatfloat2int">12. floatFloat2Int</h3>
<p>将单精度浮点数转化为int类型整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>)             <span class="comment">// NaN or infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// 非规格化数字都是小于1的数 直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 规格化数字</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> frac1 = <span class="number">0x800000</span> | frac; <span class="comment">// 补充小数部分隐含的1</span></span><br><span class="line">    <span class="type">int</span> exp1 = <span class="built_in">exp</span> - <span class="number">127</span>;        <span class="comment">// 减去偏移值得到真实的移码</span></span><br><span class="line">    <span class="comment">// 超过范围的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">31</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exp1 &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">    <span class="comment">// 在int表示范围内 判断移位方向</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">23</span>)</span><br><span class="line">      frac1 = frac1 &lt;&lt; (exp1 - <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      frac1 = frac1 &gt;&gt; (<span class="number">23</span> - exp1);</span><br><span class="line">    <span class="comment">// 根据符号分别返回</span></span><br><span class="line">    <span class="keyword">if</span> (sign) </span><br><span class="line">      <span class="keyword">return</span> ~frac1 + <span class="number">1</span>; <span class="comment">// 负数则返回其补码</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> frac1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN
或无穷大，直接返回最大值<code>0x80000000</code>；</li>
<li><code>exp == 0x00</code>：非规格化数字，都是小于1的数，直接返回0；</li>
<li><code>exp == others</code>：
规格化情况，先补充隐含的1，frac变为24位，减去偏移值得到真实的移码exp1。
<ul>
<li>exp1大于31或者小于0都超过int表示范围，直接返回0。</li>
<li>frac相当于已经左移了23位，需要再判断exp1与23的大小，大于23则还需要左移（exp1-23）位，小于则需要右移（23-exp1）位。</li>
<li>最后根据uf的符号分别返回，正数直接返回移位后的数，负数则返回其补码。</li>
</ul></li>
</ul>
<h3 id="floatpower2">13. floatPower2</h3>
<p>计算2.0的x次方。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验结果">实验结果</h2>
<p><img src="/post/ba783922/image-20221014201052512.png" alt style="zoom: 67%;"></p>
<h2 id="补充">补充</h2>
<ul>
<li><p>编译时一直有个警告：</p>
<p><img src="/post/ba783922/image-20221014200543586.png"></p>
<p>在"btest.c"文件中对arg_test_range[1]初始化即可解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Sanity check on the number of args */</span></span><br><span class="line"><span class="keyword">if</span> (args &lt; <span class="number">0</span> || args &gt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Configuration error: invalid number of args (%d) for function 	%s\n&quot;</span>, args, t-&gt;name);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line">arg_test_range[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//添加</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Assign range of argument test vals so as to conserve the total</span></span><br><span class="line"><span class="comment">   number of tests, independent of the number of arguments */</span></span><br><span class="line"><span class="keyword">if</span> (args == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = TEST_RANGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = <span class="built_in">pow</span>((<span class="type">double</span>)TEST_RANGE, <span class="number">0.5</span>); <span class="comment">/* sqrt */</span></span><br><span class="line">	arg_test_range[<span class="number">1</span>] = arg_test_range[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试时最后一题一直显示超时，将makefile里的m32改位m64，就可以了。</p></li>
</ul>
<h1 id="实验2二进制炸弹bomb-lab">实验2：二进制炸弹（Bomb Lab）</h1>
<h2 id="实验介绍-1">实验介绍</h2>
<p>二进制炸弹是一个包含一系列阶段的可执行程序，每个阶段需要你在<code>stdin</code>上输入一个特定的字符串。如果你输入的字符串正确，那么这个阶段就被成功拆除，炸弹进入下一阶段。否则，炸弹会爆炸，并输出"BOOM!!!",然后终止。当所有的阶段都被成功拆除后炸弹就被拆除。</p>
<h2 id="实验要求-1">实验要求</h2>
<blockquote>
<p>根据“学号后三位%47”领取自己的代码包</p>
</blockquote>
<h2 id="实验思路-1">实验思路</h2>
<p>准备工作: 得到汇编代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt;&gt; bomb.s</span><br></pre></td></tr></table></figure>
<h3 id="phase-1">Phase 1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048b80 &lt;phase_1&gt;:</span><br><span class="line"> 8048b80:	55                   	push   %ebp</span><br><span class="line"> 8048b81:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048b83:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048b86:	c7 44 24 04 b8 99 04 	movl   $0x80499b8,0x4(%esp)</span><br><span class="line"> 8048b8d:	08 </span><br><span class="line"> 8048b8e:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048b91:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048b94:	e8 66 05 00 00       	call   80490ff &lt;strings_not_equal&gt; </span><br><span class="line"> 8048b99:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048b9b:	74 05                	je     8048ba2 &lt;phase_1+0x22&gt;</span><br><span class="line"> 8048b9d:	e8 24 0b 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ba2:	c9                   	leave  </span><br><span class="line"> 8048ba3:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>这段程序调用了两个函数，根据名字可以猜测函数的作用。<code>strings_not_equal</code>函数，是比较两个字符串是否相等，然后测试函数的返回值，如果不为0则调用<code>explode_bomb</code>程序引爆炸弹。所以问题是怎么找到对比的字符串。可以看到，在第5行，调用<code>strings_not_equal</code>函数前程序为其分配了一个地址空间<code>0x80499b8</code>，猜测该地址可能为函数<code>strings_not_equal</code>的参数地址，也就是有可能是比对字符串的起始地址。打印地址内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x80499b8</span><br><span class="line">0x80499b8:      &quot;The future will be better tomorrow.&quot;</span><br></pre></td></tr></table></figure>
<p>即可得到第一个炸弹的答案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The future will be better tomorrow.</span><br></pre></td></tr></table></figure>
<h3 id="phase-2">Phase 2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048ba4 &lt;phase_2&gt;:</span><br><span class="line"> 8048ba4:	55                   	push   %ebp</span><br><span class="line"> 8048ba5:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048ba7:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048baa:	8d 45 e4             	lea    -0x1c(%ebp),%eax</span><br><span class="line"> 8048bad:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 8048bb1:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048bb4:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048bb7:	e8 b0 04 00 00       	call   804906c &lt;read_six_numbers&gt; # 读6个数字</span><br><span class="line"> 8048bbc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) # i=1</span><br><span class="line"> 8048bc3:	eb 1e                	jmp    8048be3 &lt;phase_2+0x3f&gt;</span><br><span class="line"> 8048bc5:	8b 45 fc             	mov    -0x4(%ebp),%eax  # a=i</span><br><span class="line"> 8048bc8:	8b 54 85 e4          	mov    -0x1c(%ebp,%eax,4),%edx # d=M[base+4*i-28] A[i-7]</span><br><span class="line"> 8048bcc:	8b 45 fc             	mov    -0x4(%ebp),%eax # a=i</span><br><span class="line"> 8048bcf:	48                   	dec    %eax # a=i-1</span><br><span class="line"> 8048bd0:	8b 44 85 e4          	mov    -0x1c(%ebp,%eax,4),%eax # a=M[base+4*(i-1)-4*7] A[i-8]</span><br><span class="line"> 8048bd4:	83 c0 05             	add    $0x5,%eax #a=a+5</span><br><span class="line"> 8048bd7:	39 c2                	cmp    %eax,%edx #cmp A[i-7]:(A[i-8]+5)</span><br><span class="line"> 8048bd9:	74 05                	je     8048be0 &lt;phase_2+0x3c&gt; #if = goto 8048be0</span><br><span class="line"> 8048bdb:	e8 e6 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048be0:	ff 45 fc             	incl   -0x4(%ebp) </span><br><span class="line"> 8048be3:	83 7d fc 05          	cmpl   $0x5,-0x4(%ebp) # comp i:5</span><br><span class="line"> 8048be7:	7e dc                	jle    8048bc5 &lt;phase_2+0x21&gt; # if &lt;= goto 8048bc5</span><br><span class="line"> 8048be9:	c9                   	leave  </span><br><span class="line"> 8048bea:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>有一个<code>read_six_numbers</code>的函数，猜测会从输入中读取六个数字。阅读中间的反汇编代码，判断是比较相邻输入的差是否为
5。所以只要满足+5 的等差数列就是符合条件的正确答案。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5 10 15 20 25 30</span><br></pre></td></tr></table></figure>
<h3 id="phase-3">Phase 3</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048beb &lt;phase_3&gt;:</span><br><span class="line"> 8048beb:	55                   	push   %ebp</span><br><span class="line"> 8048bec:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048bee:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048bf1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)</span><br><span class="line"> 8048bf8:	8d 45 f0             	lea    -0x10(%ebp),%eax</span><br><span class="line"> 8048bfb:	89 44 24 10          	mov    %eax,0x10(%esp)</span><br><span class="line"> 8048bff:	8d 45 ef             	lea    -0x11(%ebp),%eax</span><br><span class="line"> 8048c02:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048c06:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048c09:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048c0d:	c7 44 24 04 dc 99 04 	movl   $0x80499dc,0x4(%esp)</span><br><span class="line"> 8048c14:	08 </span><br><span class="line"> 8048c15:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048c18:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048c1b:	e8 48 fc ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048c20:	89 45 f8             	mov    %eax,-0x8(%ebp)			# 返回参数值</span><br><span class="line"> 8048c23:	83 7d f8 02          	cmpl   $0x2,-0x8(%ebp) 			# cmp x:2</span><br><span class="line"> 8048c27:	7f 05                	jg     8048c2e &lt;phase_3+0x43&gt; 	# 参数大必须大于2</span><br><span class="line"> 8048c29:	e8 98 0a 00 00       	call   80496c6 &lt;explode_bomb&gt; </span><br><span class="line"> 8048c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax </span><br><span class="line"> 8048c31:	89 45 dc             	mov    %eax,-0x24(%ebp)</span><br><span class="line"> 8048c34:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp) # 第一个参数必须小于7</span><br><span class="line"> 8048c38:	0f 87 c2 00 00 00    	ja     8048d00 &lt;phase_3+0x115&gt;</span><br><span class="line"> 8048c3e:	8b 55 dc             	mov    -0x24(%ebp),%edx</span><br><span class="line"> 8048c41:	8b 04 95 e8 99 04 08 	mov    0x80499e8(,%edx,4),%eax # 根据第一个参数计算跳转地址</span><br><span class="line"> 8048c48:	ff e0                	jmp    *%eax</span><br><span class="line"> 8048c4a:	c6 45 ff 74          	movb   $0x74,-0x1(%ebp) # 参数1为0跳转到这里，这里的0x74作为第2个参数对比</span><br><span class="line"> 8048c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax</span><br><span class="line"> 8048c51:	3d 66 03 00 00       	cmp    $0x366,%eax  	# 第三个参数与0x366比较</span><br><span class="line"> 8048c56:	0f 84 ad 00 00 00    	je     8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> 8048c5c:	e8 65 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c61:	e9 a3 00 00 00       	jmp    8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> .......</span><br><span class="line"> 8048d09:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax # 第2个参数与0x74比较，即116</span><br><span class="line"> 8048d0d:	38 45 ff             	cmp    %al,-0x1(%ebp)</span><br><span class="line"> 8048d10:	74 05                	je     8048d17 &lt;phase_3+0x12c&gt;</span><br><span class="line"> 8048d12:	e8 af 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d17:	c9                   	leave  </span><br><span class="line"> 8048d18:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>第16行调用了sscanf函数输入，sscanf函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="comment">//str:数据源</span></span><br><span class="line"><span class="comment">//format:格式化字符串</span></span><br><span class="line"><span class="comment">//sscanf从字符串读取格式化输入，如果成功，该函数返回成功匹配和赋值的个数。    </span></span><br></pre></td></tr></table></figure>
<p>由此猜测第12行的<code>0x80499dc</code>应该是格式化字符串，作为参数传递给sscanf函数，打印该地址的字符串内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x80499dc</span><br><span class="line">0x80499dc:      &quot;%d %c %d&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到要求输入3个参数，且格式为<code>"%d %c %d"</code>。再阅读后面的反汇编代码，可以知道第一个参数必须小于7，且程序依据第一个参数计算跳转地址，为方便起见，直接设置第一个参数为0，直接跳转到第一个判断条件；第一个判断条件比较参数3是否为<code>0x366</code>，即870；同时这里还将<code>0x74</code>保存到了栈<code>-0x1(%ebp)</code>中，是为了与参数2比较。因为参数2为char类型，使用ascii字符，116表示的字符为<code>t</code>；所以最后输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 t 870</span><br></pre></td></tr></table></figure>
<h3 id="phase-4">Phase 4</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d48 &lt;phase_4&gt;:</span><br><span class="line"> 8048d48:	55                   	push   %ebp</span><br><span class="line"> 8048d49:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d4b:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048d4e:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048d51:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d55:	c7 44 24 04 08 9a 04 	movl   $0x8049a08,0x4(%esp)</span><br><span class="line"> 8048d5c:	08 </span><br><span class="line"> 8048d5d:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048d60:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d63:	e8 00 fb ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048d68:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048d6b:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)</span><br><span class="line"> 8048d6f:	75 07                	jne    8048d78 &lt;phase_4+0x30&gt;</span><br><span class="line"> 8048d71:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d74:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048d76:	7f 05                	jg     8048d7d &lt;phase_4+0x35&gt;</span><br><span class="line"> 8048d78:	e8 49 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d7d:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d80:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d83:	e8 91 ff ff ff       	call   8048d19 &lt;func4&gt;</span><br><span class="line"> 8048d88:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048d8b:	81 7d f8 00 5f 37 00 	cmpl   $0x375f00,-0x8(%ebp) </span><br><span class="line"> 8048d92:	74 05                	je     8048d99 &lt;phase_4+0x51&gt;</span><br><span class="line"> 8048d94:	e8 2d 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d99:	c9                   	leave  </span><br><span class="line"> 8048d9a:	c3                   	ret   </span><br></pre></td></tr></table></figure>
<p>与上一题相同，这里页使用了sscanf函数，找到格式字符串地址<code>0x8049a08</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x8049a08</span><br><span class="line">0x8049a08:      &quot;%d&quot;</span><br></pre></td></tr></table></figure>
<p>在判断了匹配参数是否大于1之后，程序在第21行调用了函数func4对输入进行计算，并将返回值与<code>0x375f00</code>比较，如果相等则返回。func4反汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d19 &lt;func4&gt;:</span><br><span class="line"> 8048d19:	55                   	push   %ebp</span><br><span class="line"> 8048d1a:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d1c:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d1f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp) 	# 比较参数x是否大于1</span><br><span class="line"> 8048d23:	7f 09                	jg     8048d2e &lt;func4+0x15&gt; </span><br><span class="line"> 8048d25:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) 	# return 1</span><br><span class="line"> 8048d2c:	eb 15                	jmp    8048d43 &lt;func4+0x2a&gt;</span><br><span class="line"> 8048d2e:	8b 45 08             	mov    0x8(%ebp),%eax 	# Get x</span><br><span class="line"> 8048d31:	48                   	dec    %eax 			# x=x-1;</span><br><span class="line"> 8048d32:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d35:	e8 df ff ff ff       	call   8048d19 &lt;func4&gt; 	# 递归调用func4(x-1)</span><br><span class="line"> 8048d3a:	89 c2                	mov    %eax,%edx 	   	# d=func4(x-1)</span><br><span class="line"> 8048d3c:	0f af 55 08          	imul   0x8(%ebp),%edx 	# d=d*x</span><br><span class="line"> 8048d40:	89 55 fc             	mov    %edx,-0x4(%ebp)</span><br><span class="line"> 8048d43:	8b 45 fc             	mov    -0x4(%ebp),%eax 	# return x*func4(x-1)</span><br><span class="line"> 8048d46:	c9                   	leave  </span><br><span class="line"> 8048d47:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>通过分析func4的反汇编代码可知，该函数为一个递归函数，计算x!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x*func4(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>10!=3628800</code>，即<code>0x375f00</code>，所以答案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="phase-5">Phase 5</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d9b &lt;phase_5&gt;:</span><br><span class="line"> 8048d9b:	55                   	push   %ebp</span><br><span class="line"> 8048d9c:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d9e:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048da1:	8d 45 e8             	lea    -0x18(%ebp),%eax  	# y in M[-0x18(%ebp)]</span><br><span class="line"> 8048da4:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048da8:	8d 45 ec             	lea    -0x14(%ebp),%eax 	# x in M[-0x14(%ebp)]</span><br><span class="line"> 8048dab:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048daf:	c7 44 24 04 0b 9a 04 	movl   $0x8049a0b,0x4(%esp) # format string</span><br><span class="line"> 8048db6:	08 </span><br><span class="line"> 8048db7:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048dba:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048dbd:	e8 a6 fa ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048dc5:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp) 		# 检查输入个数</span><br><span class="line"> 8048dc9:	7f 05                	jg     8048dd0 &lt;phase_5+0x35&gt;</span><br><span class="line"> 8048dcb:	e8 f6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd0:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048dd3:	83 e0 0f             	and    $0xf,%eax </span><br><span class="line"> 8048dd6:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=x&amp;0xf</span><br><span class="line"> 8048dd9:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048ddc:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048ddf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp) 	# i=0</span><br><span class="line"> 8048de6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp) 		# sum=0</span><br><span class="line"> 8048ded:	eb 16                	jmp    8048e05 &lt;phase_5+0x6a&gt;</span><br><span class="line"> 8048def:	ff 45 f0             	incl   -0x10(%ebp) 			# i++;</span><br><span class="line"> 8048df2:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048df5:	8b 04 85 c0 a5 04 08 	mov    0x804a5c0(,%eax,4),%eax </span><br><span class="line"> 8048dfc:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=array[x]</span><br><span class="line"> 8048dff:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048e02:	01 45 f4             	add    %eax,-0xc(%ebp) 		# sum+=x</span><br><span class="line"> 8048e05:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048e08:	83 f8 0f             	cmp    $0xf,%eax 			# cmp x:15</span><br><span class="line"> 8048e0b:	75 e2                	jne    8048def &lt;phase_5+0x54&gt; </span><br><span class="line"> 8048e0d:	83 7d f0 0c          	cmpl   $0xc,-0x10(%ebp) 	# cmp i:12</span><br><span class="line"> 8048e11:	75 08                	jne    8048e1b &lt;phase_5+0x80&gt; </span><br><span class="line"> 8048e13:	8b 45 e8             	mov    -0x18(%ebp),%eax </span><br><span class="line"> 8048e16:	39 45 f4             	cmp    %eax,-0xc(%ebp) 		# cmp sum:y</span><br><span class="line"> 8048e19:	74 05                	je     8048e20 &lt;phase_5+0x85&gt; </span><br><span class="line"> 8048e1b:	e8 a6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e20:	c9                   	leave  </span><br><span class="line"> 8048e21:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>查看输入格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x8049a0b</span><br><span class="line">0x8049a0b:      &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>
<p>通过分析汇编代码可以知道，程序在第28行调用了数组，数组地址为<code>0x804a5c0</code>，且长度为16，因为要x的范围为<code>0&lt;=x&lt;16</code>，x要作为数组索引访问数组；这里最关键的就是打印出数组的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p *0x804a5c0@16</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>根据汇编代码反推出phase_5函数的源程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> n = ssccanf(str,<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        explode_bomb();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    x=x&amp;<span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0xf</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        x=<span class="built_in">array</span>[<span class="number">4</span>*x];</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">12</span>&amp;sum==y)</span><br><span class="line">    	<span class="keyword">return</span> ;</span><br><span class="line">    explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为循环只能进行12次，可以根据数组反推出x变化序列，进而得到序列和：<code>y=sum=93</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">6</span> <span class="number">14</span> <span class="number">2</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">13</span> <span class="number">11</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>答案为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">7 93</span><br></pre></td></tr></table></figure>
<h3 id="phase-6">Phase 6</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048eb6 &lt;phase_6&gt;:</span><br><span class="line"> 8048eb6:	55                   	push   %ebp</span><br><span class="line"> 8048eb7:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048eb9:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> 8048ebc:	c7 45 f8 6c a6 04 08 	movl   $0x804a66c,-0x8(%ebp) # 0x804a66c in M[-0x8(%ebp)]</span><br><span class="line"> 8048ec3:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048ec6:	89 04 24             	mov    %eax,(%esp)			# input_strings:str</span><br><span class="line"> 8048ec9:	e8 8a f9 ff ff       	call   8048858 &lt;atoi@plt&gt; 	# ascii to int</span><br><span class="line"> 8048ece:	89 c2                	mov    %eax,%edx 			# n1 = atoi(str)</span><br><span class="line"> 8048ed0:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed3:	89 10                	mov    %edx,(%eax) 			# n1 in 0x804a66c</span><br><span class="line"> 8048ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed8:	89 04 24             	mov    %eax,(%esp) 			</span><br><span class="line"> 8048edb:	e8 42 ff ff ff       	call   8048e22 &lt;fun6&gt;</span><br><span class="line"> 8048ee0:	89 45 f8             	mov    %eax,-0x8(%ebp) 		# p=fun6(h)</span><br><span class="line"> 8048ee3:	8b 45 f8             	mov    -0x8(%ebp),%eax</span><br><span class="line"> 8048ee6:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p in M[-0x4(%ebp)]</span><br><span class="line"> 8048ee9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp) 		# i=1</span><br><span class="line"> 8048ef0:	eb 0c                	jmp    8048efe &lt;phase_6+0x48&gt;</span><br><span class="line"> 8048ef2:	8b 45 fc             	mov    -0x4(%ebp),%eax 		</span><br><span class="line"> 8048ef5:	8b 40 08             	mov    0x8(%eax),%eax 		</span><br><span class="line"> 8048ef8:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p=p-&gt;next</span><br><span class="line"> 8048efb:	ff 45 f4             	incl   -0xc(%ebp) 			# i++;</span><br><span class="line"> 8048efe:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp) 		# cmp i:8</span><br><span class="line"> 8048f02:	7e ee                	jle    8048ef2 &lt;phase_6+0x3c&gt; </span><br><span class="line"> 8048f04:	8b 45 fc             	mov    -0x4(%ebp),%eax </span><br><span class="line"> 8048f07:	8b 10                	mov    (%eax),%edx			# get n2=p-&gt;val</span><br><span class="line"> 8048f09:	a1 6c a6 04 08       	mov    0x804a66c,%eax 		# get n1</span><br><span class="line"> 8048f0e:	39 c2                	cmp    %eax,%edx 			# cmp n2:n1</span><br><span class="line"> 8048f10:	74 05                	je     8048f17 &lt;phase_6+0x61&gt;</span><br><span class="line"> 8048f12:	e8 af 07 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f17:	c9                   	leave  </span><br><span class="line"> 8048f18:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>phase_6一开始调用了函数atoi，该函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// str -- 要转换为整数的字符串。</span></span><br><span class="line"><span class="comment">// 该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</span></span><br></pre></td></tr></table></figure>
<p>所以猜测需要输入一个可以转换为整数的字符串。运行程序并输入测试字符串<code>"12345"</code>，查看调用atoi函数前栈中的数据，可以看到输入字符串的地址被存放在栈顶，字符串起始地址为<code>0x804aa30</code>。在调用了atoi函数后，程序将返回值存放到了地址<code>0x804a66c</code>中，打印出来显示是刚刚输入的字符串转成的数字：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s <span class="number">0</span>x804aa30</span><br><span class="line"><span class="number">0</span>x804aa30 &lt;input_strings+<span class="number">400</span>&gt;:  <span class="string">&quot;12&quot;</span></span><br><span class="line">...</span><br><span class="line">(gdb) x/d <span class="number">0</span>x804a66c</span><br><span class="line"><span class="number">0</span>x804a66c &lt;node0&gt;:      <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>接下来程序调用了函数fun6，并将返回值放入到<code>-0x4(%ebp)</code>中；其中第18到24行为链表的访问，执行8次后跳出循环。最后终止时比较与
atoi
转换的结果是否一致。通过阅读fun6的反汇编代码可知fun6函数并没有使用到atoi
转换的结果，所以直接运行到第27行查看寄存器<code>%edx</code>的值，该值为fun6得到的结果：149。最终答案为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>
<h2 id="实验结果-1">实验结果</h2>
<p>phase1~6的答案如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">future</span> will be better tomorrow.</span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> t <span class="number">870</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">7</span> <span class="number">93</span></span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>
<p>按照阶段依次输入上面分析的答案，运行结果截图如下：</p>
<p><img src="/post/ba783922/image-20221029143516251.png" alt style="zoom:67%;"></p>
<h1 id="实验3缓冲区溢出buffer-lab">实验3：缓冲区溢出（Buffer Lab）</h1>
<h2 id="实验目标">实验目标</h2>
<ul>
<li><p>掌握函数调用时的栈帧结构</p></li>
<li><p>利用输入缓冲区的溢出漏洞，将攻击代码嵌入当前程序的栈帧中，使得程序执行我们所期望的过程</p></li>
</ul>
<h2 id="实验介绍-2">实验介绍</h2>
<ul>
<li>文件组成
<ul>
<li>makecookie：生成cookie 例：./makecookie SA18225155 生成cookie</li>
<li>Bufbomb：可执行程序-攻击对象</li>
<li>Sendstring: 字符格式转换</li>
</ul></li>
<li>bufbomb程序</li>
</ul>
<p>Bufbomb中包含一个getbuf函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>]; <span class="comment">// 对buf没有越界检查,超过11个字符将溢出</span></span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048fe0 &lt;getbuf&gt;:</span><br><span class="line"> 8048fe0:	55                   	push   %ebp				#压入返回地址</span><br><span class="line"> 8048fe1:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048fe3:	83 ec 18             	sub    $0x18,%esp		#allocate 24B</span><br><span class="line"> 8048fe6:	8d 45 f4             	lea    -0xc(%ebp),%eax	#get string address</span><br><span class="line"> 8048fe9:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048fec:	e8 6f fe ff ff       	call   8048e60 &lt;Gets&gt;</span><br><span class="line"> 8048ff1:	b8 01 00 00 00       	mov    $0x1,%eax		#return 1;</span><br><span class="line"> 8048ff6:	c9                   	leave  </span><br><span class="line"> 8048ff7:	c3                   	ret    </span><br><span class="line"> 8048ff8:	90                   	nop</span><br><span class="line"> 8048ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi</span><br></pre></td></tr></table></figure>
<ul>
<li>溢出</li>
</ul>
<p>溢出的字符将覆盖栈帧上的数据，特别的，会覆盖程序调用的返回地址，赋予我们控制程序流程的能力；通过构造溢出字符串，程序将“返回”至我们想要的代码上。</p>
<ul>
<li>字符构造</li>
</ul>
<p>计算机系统中，字符以ASCII码表示
/存储，例如，输入’1’，存储为’0x31’。本实验也需要扩展的ASCII码（128~255）。为了构造所需要的地址或其他数据，我们需要逆反”字符-&gt;ASCII码”的过程；采用代码包给出的
sendstring工具。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./sendstring &lt; exploit.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p>其中exploit.txt保存目标数据（即空格分隔的ASCII码），exploit-raw.txt为逆向出的字符串。</p>
<ul>
<li>字符串输入</li>
</ul>
<p>前述方法构造出的字符串按如下方式输入：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./bufbomb <span class="literal">-t</span> SA18225155 &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p>从标准输入设备输入：ALT+ASC码的十进制数（小键盘输入）。注意，最后一个数字按下后与ALT键同时放开。例，输入字符“1”为ALT+49。实验完成后提交exploit.txt文件。</p>
<ul>
<li>指令构造方法示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushl $0x89abcdef 	# Push value onto stack </span><br><span class="line">addl $17,%eax 		# Add 17 to %eax </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>保存成example.s，然后输入命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -c example.s </span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<h2 id="实验过程">实验过程</h2>
<h3 id="level-0-candle">Level 0: Candle</h3>
<blockquote>
<p>目标：Bufbomb中一个正常情况下不会被执行的函数smoke，在getbuf返回时跳到smoke函数执行。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">smoke</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">0</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Smoke!: You called smoke()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将smoke函数的地址放入getbuf的返回地址，需要构造合适的输入字符串。通过阅读getbuf的汇编代码可以知道输入字符串首地址被存放在内存栈<code>-0xc(%ebp)</code>中，运行程序，输入测试字符串，并打印出该字符串作验证。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bufbomb</span><br><span class="line">(gdb) b getbuf</span><br><span class="line">(gdb) run -t SAXXXXXXXX</span><br><span class="line">Starting program: /home/ubuntu/桌面/bufferlab/bufbomb -t SAXXXXXXXX</span><br><span class="line">Team: SAXXXXXXXX</span><br><span class="line">Cookie: 0x58932f5a</span><br><span class="line">...</span><br><span class="line">(gdb) x/s $ebp-0xc</span><br><span class="line">0xffffb96c:     &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>所以可以知道字符串首地址<code>0xffffb96c</code>。用smoke函数的地址覆盖getbuf的返回地址，还需要找到函数smoke函数的首地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p/x &amp;smoke</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x8048e20</span></span><br></pre></td></tr></table></figure>
<p>在test的汇编代码中，getbuf的下一行指令的地址为<code>0x804901e</code>，该地址在调用getbuf后被保存在<code>%ebp+0x4</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08049000 &lt;test&gt;:</span><br><span class="line">...</span><br><span class="line"> 8049019:	e8 c2 ff ff ff       	call   8048fe0 &lt;getbuf&gt;</span><br><span class="line"> 804901e:	89 c2                	mov    %eax,%edx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/x $ebp+4</span><br><span class="line">0xffffb97c:     0x0804901e</span><br></pre></td></tr></table></figure>
<p>从<code>0xffffb96c</code>覆盖到<code>0xffffb97c</code>，需要先填充
16字节字符串内容，然后填充smoke函数的地址：<code>20</code>,<code>8e</code>,<code>04</code>,<code>08</code>（小端机器），如果是
64 位机器则需要继续覆盖后面为
0。所以我们需要构造字符串十六进制表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit0.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">20 8e 04 08 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>使用工具生成字符串并运行程序，结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./sendstring &lt; exploit0.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br><span class="line">./bufbomb <span class="literal">-t</span> SAXXXXXXXX &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>
<p><img src="/post/ba783922/image-20221029171139653.png"></p>
<h3 id="level-1-sparkler">Level 1: Sparkler</h3>
<blockquote>
<p>目标：调用 fizz(val) 函数，并将自己的 cookies
传递为参数。（Cookie必须为自己学号生成）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fizz</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">1</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印该函数地址：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/x fizz</span><br><span class="line"><span class="number">0</span>x8048dc0 &lt;fizz&gt;:       <span class="number">0</span>x53e58955</span><br></pre></td></tr></table></figure>
<p>生成cookie：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./makecookie SAXXXXXXXX</span><br><span class="line"><span class="number">0</span>x58932f5a</span><br></pre></td></tr></table></figure>
<p>部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048dc0 &lt;fizz&gt;:</span><br><span class="line">...</span><br><span class="line"> 8048dc4:	83 ec 14             	sub    $0x14,%esp</span><br><span class="line"> 8048dc7:	8b 5d 08             	mov    0x8(%ebp),%ebx	# 传入参数值</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过阅读汇编代码可以知道，0x8(%ebp)是传入的参数的存放地址，即$ebp+8,这里需要将其覆盖为生成的cookie值作为输入，而$ebp+4是原来正常的返回地址，需要覆盖为fizz的地址<code>0x8048dc0</code>。构造输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit1.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">c0 8d 04 08 00 00 00 00 </span><br><span class="line">5a 2f 93 58 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>使用工具生成字符串并运行程序，结果如下：</p>
<p><img src="/post/ba783922/image-20221029190954349.png"></p>
<h3 id="level-2-firecracker">Level 2: Firecracker</h3>
<blockquote>
<p>目标：含有一个 bang 函数，和一个全局变量
global_value，需要注入机器代码，修改 global_value 为 cookies
的值，再调用 bang
函数。具体指令构造方法参加实验说明文档。可通过execstack工具解除栈执行限制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bang</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">2</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bang 汇编语言的前几行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048d60 &lt;bang&gt;:</span><br><span class="line"> 8048d60:	55                   	push   %ebp</span><br><span class="line"> 8048d61:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d63:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d66:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</span><br><span class="line"> 8048d6d:	e8 2e fc ff ff       	call   80489a0 &lt;entry_check&gt;</span><br><span class="line"> 8048d72:	a1 dc a1 04 08       	mov    0x804a1dc,%eax	#get global_value</span><br><span class="line"> 8048d77:	3b 05 cc a1 04 08    	cmp    0x804a1cc,%eax	#cmp global_value:cookie</span><br><span class="line"> 8048d7d:	74 21                	je     8048da0 &lt;bang+0x40&gt;</span><br></pre></td></tr></table></figure>
<p>汇编语言的第7、8行对应源程序的if语句，所以猜测global_value被存储在<code>0x804a1dc</code>中，cookie被存储在<code>0x804a1cc</code>中。检查如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/x <span class="number">0</span>x804a1dc</span><br><span class="line"><span class="number">0</span>x804a1dc &lt;global_value&gt;: <span class="number">0</span>x00000000</span><br><span class="line">(gdb) x/x <span class="number">0</span>x804a1cc</span><br><span class="line"><span class="number">0</span>x804a1cc &lt;cookie&gt;:     <span class="number">0</span>x00000000</span><br></pre></td></tr></table></figure>
<p>思路是将汇编代码注入到char数组的首地址<code>0xffffb96c</code>，让char数组的首地址覆盖$eax+4y原来的返回地址，当发生ret时，就会跳转到char数组首地址执行注入的汇编代码。汇编代码中要先修改global_value的值，然后将
bang 函数的地址 push 进栈中，然后使用 ret
命令。当执行到注入的ret命令时，因为push了bang函数的地址，就会返回到bang函数执行。汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl  $0x58932f5a, 0x804a1dc		# global_value=cookie</span><br><span class="line">pushl $0x08048d60					# 将 bang 函数的首地址压入栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">gcc <span class="literal">-m32</span> <span class="literal">-c</span> example.s </span><br><span class="line">objdump <span class="literal">-d</span> example.o &gt; example.d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	c7 05 dc a1 04 08 5a 	movl   $0x58932f5a,0x804a1dc</span><br><span class="line">   7:	2f 93 58 </span><br><span class="line">   a:	68 60 8d 04 08       	push   $0x8048d60</span><br><span class="line">   f:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>构造注入机器代码，转成字符串并运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit2.txt</span><br><span class="line">c7 05 dc a1 04 08 5a 2f </span><br><span class="line">93 58 68 60 8d 04 08 c3</span><br><span class="line">6c b9 ff ff 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>结果出现段错误，是因为Linux系统默认开启了栈保护机制，用于阻止缓冲区溢出攻击。所以不可以在栈中直接执行指令，需要使用execstack工具解除栈执行限制。即使如此也只能在gdb调试下有效，实际运行仍然会出现段错误。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install execstack 	<span class="comment">#安装execstack</span></span><br><span class="line">execstack <span class="literal">-s</span> bufbomb			<span class="comment">#修改程序堆栈的可执行属性</span></span><br></pre></td></tr></table></figure>
<p><img src="/post/ba783922/image-20221029201251844.png" style="zoom:80%;"></p>
<p><img src="/post/ba783922/image-20221029202121258.png"></p>
<h3 id="level-3-dynamite">Level 3: Dynamite</h3>
<blockquote>
<p>目标：这个 Level 要求我们注入一段能够修改 getbuf
返回值的代码，返回值从 1 改成 cookie
值，此外还需要还原所有破坏，继续运行 test 的剩下部分。函数正常返回时执行
第15行，我们要让函数执行第12行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    entry_check(<span class="number">3</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值保存在%eax中，所以将cookie值放入这个寄存器中，并将原来正确的返回地址（即call
<getbuf>的下一条指令地址<code>0x804901e</code>）压入栈中，构造完成攻击的汇编代码如下:</getbuf></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $0x58932f5a, %eax		#move cookie to %eax, return %eax</span><br><span class="line">push $0x804901e				#push &lt;test&gt; return address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	b8 5a 2f 93 58       	mov    $0x58932f5a,%eax</span><br><span class="line">   5:	68 1e 90 04 08       	push   $0x804901e</span><br><span class="line">   a:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>生成的机器代码一共是11个字节，再加上一个对齐字节凑足12字节，可以看到这时已经填满了char字符串的缓冲区。与上一个问题相同，还要用char字符串首地址<code>0xffffb96c</code>覆盖原来的返回地址，以便于执行注入的指令。但这里还要注意一点，为了保证栈不被破坏，除了必要的修改，我们必须保持其他的栈字保存不变，先打印出原来的数据：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">24</span>xb <span class="number">0</span>xffffb96c</span><br><span class="line"><span class="number">0</span>xffffb96c:     <span class="number">0</span>x31    <span class="number">0</span>x32    <span class="number">0</span>x33    <span class="number">0</span>x34    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br><span class="line"><span class="number">0</span>xffffb974:     <span class="number">0</span>xc0    <span class="number">0</span>xb5    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x98    <span class="number">0</span>xb9    <span class="number">0</span>xff    <span class="number">0</span>xff</span><br><span class="line"><span class="number">0</span>xffffb97c:     <span class="number">0</span>x1e    <span class="number">0</span>x90    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x03    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br></pre></td></tr></table></figure>
<p>构造攻击代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// exploit3.txt</span><br><span class="line">b8 5a 2f 93 58 68 1e 90 </span><br><span class="line">04 08 c3 00 98 b9 ff ff</span><br><span class="line">6c b9 ff ff 03 00 00 00</span><br></pre></td></tr></table></figure>
<p>转成字符串并运行：</p>
<p><img src="/post/ba783922/image-20221029210254503.png"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>中科大计算机系统作业3</title>
    <url>/post/65d319d0.html</url>
    <content><![CDATA[<p>本文为中科大研究生课程——计算机系统作业3的题目解答记录。使用的教材为《深入理解计算机系统》（第3版）。</p>
<span id="more"></span>
<h1 id="题目与解答">题目与解答</h1>
<h2 id="section">5.13</h2>
<p>假设我们想编写一个计算两个向量 u 和 v 内积的过程 。
这个函数的一个抽象版本对整数和浮点数类型，在 x86-64 上 CPE 等 于 14~ 18
。通过进行与我们将抽象程序 combine1 变换为更有效的 combine4
相同类型的变换，我 们得到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Inner product. Accumulate in temporary */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inner4</span><span class="params">(vec_ptr u, vec_ptr v, <span class="type">data_t</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> length = vec_length(u);</span><br><span class="line">    <span class="type">data_t</span> *udata = get_vec_start(u);</span><br><span class="line">    <span class="type">data_t</span> *vdata = get_vec_start(v);</span><br><span class="line">    <span class="type">data_t</span> sum = (<span class="type">data_t</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = O; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + udata[i] * vdata[i];</span><br><span class="line">        *dest = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试显示，对于整数这个函数的 CPE 等于 1. 50, 对于浮点数据 CPE
等于3.00 。对于数据类型 double, 内循环的 x86-64 汇编代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inner loop of inner4 . data_t = double, OP = *</span><br><span class="line">udata in %rbp, vdata in %rax, sum in %xmm0</span><br><span class="line">i in %rcx, limit in %rbx</span><br><span class="line">.L15:                                  loop :</span><br><span class="line">vmovsd  0(%rbp,%rcx,8), %xmm1           Get udata[i]</span><br><span class="line">vmulsd  (%rax,%rcx,8), %xmm1, %xmm1     Mltiply by vdata[i]</span><br><span class="line">vaddsd  %xmm1, %xmm0, %xmm0             Add to sum</span><br><span class="line">addq    $1, %rcx                        Increment i</span><br><span class="line">cmpq    %rbx, %rcx                      Compare i: limit</span><br><span class="line">jne .L15                                If!=, goto loop</span><br></pre></td></tr></table></figure>
<p>假设功能单元的特性如图 5-12 所示。</p>
<p>A. 按照图 5-13 和图 5-14
的风格，画出这个指令序列会如何被译码成操作，并给出它们之间的数据相关如何形成一条操作的关键路径。</p>
<p>B. 对于数据类型 double, 这条关键路径决定的 CPE 的下界是什么？</p>
<p>C. 假设对于整数代码也有类似的指令序列，对于整数数据的关键路径决定的
CPE 的下界是什么？</p>
<p>D. 请解释虽然乘法操作需要 5 个时钟周期，但是为什么两个浮点版本的 CPE
都是 3.00。</p>
<p><strong>解：</strong></p>
<ol type="A">
<li></li>
</ol>
<p>（1）内循环代码的图形化表示</p>
<p><img src="/post/65d319d0/1.svg"></p>
<p>（2）重新排列了操作符， 更清晰地表明了数据相关</p>
<p><img src="/post/65d319d0/2.svg"></p>
<p>（3）操作在一次迭代中使用某些值，产生出在下一次迭代中需要的新值
，得到关键路径</p>
<p><img src="/post/65d319d0/3.svg"></p>
<p>B. double类型，关键路径CPE的下界为浮点数加法的延迟界限：3.00</p>
<p>C. 整数数据的关键路径决定的 CPE 的下界是整数加法的延迟界限：1.00</p>
<p>D.
因为只有浮点加法在关键路径上，当执行这个函数时，浮点加法器成为了制约资源。循环中需要的其他操作，如从内存中读数据以及浮点乘法可以提前并行地进行。所以
CPE 都是 3.00</p>
<h2 id="section-1">5.17</h2>
<p>库函数 memset 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数将从 s 开始的 n 个字节的内存区域都填充为 c
的低位字节。例如，通过将参数 c 设置为0,
可以用这个函数来对一个内存区域清零，不过用其他值也是可以的。下面是
memset 最直接的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Basic implementation of memset */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">basic_memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *schar s;</span><br><span class="line">    <span class="keyword">while</span> (cnt n)</span><br><span class="line">    &#123;</span><br><span class="line">        *schar++ = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现该函数一个更有效的版本，使用数据类型为 unsigned long 的字来装下 8
个 C, 然后用字级的写遍历目标内存区域 。
你可能发现增加额外的循环展开会有所帮助。在我们的参考机上，能够把 CPE
从直接实现的 1. 00 降低到 0.127 。即程序每个周期可以写 8 个字节 。</p>
<p>这里是一些额外的指导原则 。 在此，假设 K 表示你运行程序的机器上的
sizeof (unsigned long) 的值。</p>
<ul>
<li>你不可以调用任何库函数 。</li>
<li>你的代码应该对任意 n 的值都能 工 作，包括当它不是 K 的倍数的时候 。
你可以用类似于使用循环展开时完成最后几次迭代的方法做到这一点。</li>
<li>你写的代码应该无论 K 的值是多少，都能够正确编译和运行 。 使用操作
sizeof 来做到这一点。</li>
<li>在某些机器上，未对齐的写可能比对齐的写慢很多。（在某些非 x86 机器上
，未对齐的写甚至可能会导致段错误。）写出这样的代码，开始时直到目的地址是
K 的倍数时，使用字节级的写，然后进行字级的写，（ 如果需要
）最后采用字节级的写 。</li>
<li>注意 cnt 足够小以至于一些循环上界变成负数的情况 。 对于涉及 sizeof
运算符的表达式，可以用无符号运算来执行测试 。 （ 参见 2 . 2. 8
节和家庭作业 2. 72 。)</li>
</ul>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* basic_memset直接的实现 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">basic_memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *schar = s;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        *schar++ = (<span class="type">unsigned</span> <span class="type">char</span>)c;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * K = sizeof(unsigned long)</span></span><br><span class="line"><span class="comment"> * cs store K chars for memset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">effective_memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">unsigned</span> <span class="type">long</span> cs, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> K = <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *schar = s;</span><br><span class="line">    <span class="comment">// 字节对齐： 进行字级的写 直到目的地址是K的倍数</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>)schar % K == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        *schar++ = (<span class="type">unsigned</span> <span class="type">char</span>)cs; <span class="comment">// 填充为cs的低位字节</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环展开：循环前部分 每次循环写K个字节 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *slong = (<span class="type">unsigned</span> <span class="type">long</span> *)schar;</span><br><span class="line">    <span class="type">size_t</span> rest = n - cnt;</span><br><span class="line">    <span class="type">size_t</span> loop = rest / K;</span><br><span class="line">    <span class="type">size_t</span> tail = rest % K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; loop; i++)</span><br><span class="line">        *slong++ = cs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环展开：处理尾部剩余部分 字节级写入</span></span><br><span class="line">    schar = (<span class="type">unsigned</span> <span class="type">char</span> *)slong;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; tail; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *schar++ = (<span class="type">unsigned</span> <span class="type">char</span>)cs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> space = <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">65537</span>;</span><br><span class="line">    <span class="comment">// careful! malloc SIZE_MAX size memory will make sys slow</span></span><br><span class="line">    <span class="comment">// or crash down</span></span><br><span class="line">    <span class="comment">// size_t space = SIZE_MAX;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *basic_space = <span class="built_in">malloc</span>(space);</span><br><span class="line">    <span class="type">void</span> *effective_space = <span class="built_in">malloc</span>(space);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> basic_fill = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> effective_fill = ~<span class="number">0</span>;</span><br><span class="line">    <span class="type">clock_t</span> start = clock();</span><br><span class="line">    basic_memset(basic_space, basic_fill, space);</span><br><span class="line">    <span class="type">clock_t</span> end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;basic_memset:     %.3lfms\n&quot;</span>,(<span class="type">double</span>)(end-start)*<span class="number">1000</span>/CLOCKS_PER_SEC);</span><br><span class="line">    start = clock();</span><br><span class="line">    effective_memset(effective_space, effective_fill, space);</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;effective_memset: %.3lfms\n&quot;</span>,(<span class="type">double</span>)(end-start)*<span class="number">1000</span>/CLOCKS_PER_SEC);</span><br><span class="line">    <span class="comment">// 检查是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcmp</span>(basic_space, effective_space, space) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(basic_space);</span><br><span class="line">    <span class="built_in">free</span>(effective_space);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basic_memset:     0.244ms</span><br><span class="line">effective_memset: 0.099ms</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>可以看到循环展开版本的 memset 比直接实现快了一个数量级。</p>
<h2 id="section-2">6.25</h2>
<p>下面的表给出了一些不同的高速缓存的参数。对于每个高速缓存，填写出表中缺失的字段。记住
m 是物理地址的位数， C 是高速缓存大小（数据字节数）， B
是以字节为单位的块大小， E 是相联度， S 是高速缓存组数， t 是标记位数，
s 是组索引位数，而 b 是块偏移位数。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 15%">
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>高速缓存</th>
<th>m</th>
<th>C</th>
<th>B</th>
<th>E</th>
<th>S</th>
<th>t</th>
<th>s</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>1.</strong></td>
<td><strong>32</strong></td>
<td><strong>1024</strong></td>
<td><strong>4</strong></td>
<td><strong>4</strong></td>
<td>64</td>
<td>24</td>
<td>6</td>
<td>2</td>
</tr>
<tr class="even">
<td><strong>2.</strong></td>
<td><strong>32</strong></td>
<td><strong>1024</strong></td>
<td><strong>4</strong></td>
<td><strong>256</strong></td>
<td>1</td>
<td>30</td>
<td>0</td>
<td>2</td>
</tr>
<tr class="odd">
<td><strong>3.</strong></td>
<td><strong>32</strong></td>
<td><strong>1024</strong></td>
<td><strong>8</strong></td>
<td><strong>1</strong></td>
<td>128</td>
<td>22</td>
<td>7</td>
<td>3</td>
</tr>
<tr class="even">
<td><strong>4.</strong></td>
<td><strong>32</strong></td>
<td><strong>1024</strong></td>
<td><strong>8</strong></td>
<td><strong>128</strong></td>
<td>1</td>
<td>29</td>
<td>0</td>
<td>3</td>
</tr>
<tr class="odd">
<td><strong>5.</strong></td>
<td><strong>32</strong></td>
<td><strong>1024</strong></td>
<td><strong>32</strong></td>
<td><strong>1</strong></td>
<td>32</td>
<td>22</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="even">
<td><strong>6.</strong></td>
<td><strong>32</strong></td>
<td><strong>1024</strong></td>
<td><strong>32</strong></td>
<td><strong>4</strong></td>
<td>8</td>
<td>24</td>
<td>3</td>
<td>5</td>
</tr>
</tbody>
</table>
<h2 id="section-3">6.34</h2>
<p>考虑下面的矩阵转置函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose2</span><span class="params">(<span class="built_in">array</span> dst, <span class="built_in">array</span> src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">            dst[j][i] = src[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设这段代码运行在一台具有如下属性的机器上：</p>
<ul>
<li><p><code>sizeof(int)==4</code></p></li>
<li><p>数组 src 从地址 0 开始，而数组 dst 从地址 64
开始（十进制）。</p></li>
<li><p>只有一个 L1 数据高速缓存，它是直接映射、直写、写分配的，块大小为
16 字节。</p></li>
<li><p>这个高速缓存总共有 32 个数据字节，初始为空。</p></li>
<li><p>对 src 和 dst 数组的访问分别是读和写不命中的唯一来源。</p></li>
</ul>
<p>对于每个 row 和 col, 指明对 src [row] [col] 和 dst [row ] [col]
的访问是命中(h) 还是不命中(m)。 例如，读 src [0] [0] 会不命中，而写 dst
[0] [0] 也会不命中。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">src : [<span class="number">0</span>]<span class="number">4b</span>yte [<span class="number">4</span>]<span class="number">4b</span>yte [<span class="number">8</span>]<span class="number">4b</span>yte [<span class="number">12</span>]<span class="number">4b</span>yte [<span class="number">16</span>]...</span><br><span class="line">dst : [<span class="number">64</span>]<span class="number">4b</span>yte [<span class="number">68</span>]<span class="number">4b</span>yte [<span class="number">72</span>]<span class="number">4b</span>yte [<span class="number">76</span>]<span class="number">4b</span>yte [<span class="number">80</span>]...    </span><br></pre></td></tr></table></figure>
<p>数据高速缓存总共有 32 个字节，块大小为 16
字节，所以共有2行，直接映射所以分为2组，s=1,b=4。对于写分配的高速缓存，每次写不命中时，需要读取数据到高速缓存中。</p>
<ul>
<li><p>src[0]映射到高速缓存第0行；src[1]映射到第1行，src[2]映射到0行，src[3]映射到1行；</p></li>
<li><p>dst[0]映射到高速缓存第0行；dst[1]映射到第1行，dst[2]映射到0行，dst[3]映射到1行；</p></li>
</ul>
<p>对于相同的i,j，src[i][j]和dst[i][j]对应相同的组。</p>
<ul>
<li>过程：
<ul>
<li>读src[0][0]不命中，读入src[0]到高速缓存第0行；写dst[0][0]不命中，将dst[0]读入高速缓存0行；</li>
<li>读src[0][1]不命中，读入src[0]到高速缓存第0行；写dst[1][0]不命中，将dst[1]读入高速缓存1行；</li>
<li>读src[0][2]命中；写dst[2][0]不命中，将dst[2]读入高速缓存0行；</li>
<li>读src[0][3]不命中，读入src[0]到高速缓存第0行；写dst[3][0]不命中，将dst[3]读入高速缓存1行；</li>
<li>...</li>
</ul></li>
<li>dst 数组</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>列0</th>
<th>列1</th>
<th>列2</th>
<th>列3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>行0</strong></td>
<td><strong>m</strong></td>
<td>m</td>
<td>h</td>
<td>m</td>
</tr>
<tr class="even">
<td><strong>行1</strong></td>
<td>m</td>
<td>h</td>
<td>m</td>
<td>h</td>
</tr>
<tr class="odd">
<td><strong>行2</strong></td>
<td>m</td>
<td>m</td>
<td>h</td>
<td>m</td>
</tr>
<tr class="even">
<td><strong>行3</strong></td>
<td>m</td>
<td>h</td>
<td>m</td>
<td>h</td>
</tr>
</tbody>
</table>
<ul>
<li>src 数组</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>列0</strong></th>
<th><strong>列1</strong></th>
<th><strong>列2</strong></th>
<th><strong>列3</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>行0</strong></td>
<td><strong>m</strong></td>
<td>m</td>
<td>m</td>
<td>m</td>
</tr>
<tr class="even">
<td><strong>行1</strong></td>
<td>m</td>
<td>m</td>
<td>m</td>
<td>m</td>
</tr>
<tr class="odd">
<td><strong>行2</strong></td>
<td>m</td>
<td>m</td>
<td>m</td>
<td>m</td>
</tr>
<tr class="even">
<td><strong>行3</strong></td>
<td>m</td>
<td>m</td>
<td>m</td>
<td>m</td>
</tr>
</tbody>
</table>
<h2 id="section-4">6.38</h2>
<p>3M决定在白纸上印黄方格，做成 Post-lt小贴纸 。 在打印过程中，
他们需要设置方格中每个点的CMYK ( 蓝色 ，红色，黄色，黑色）值。
3M雇佣你判定下面算法在一个具有 2048 字节 、 直接映射、块大小为 32
字节的数据高速缓存上的效率。 有 如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point_color</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point_color</span> <span class="title">square</span>[16][16];</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br></pre></td></tr></table></figure>
<p>有如下假设：</p>
<ul>
<li><code>sizeof(int) == 4</code>。</li>
<li>square 起始于内存地址 0 。</li>
<li>高速缓存初始为空。</li>
<li>唯一的内存访问是对于 square 数组中的元素。变量 i 和 j
存放在寄存器中。</li>
</ul>
<p>确定下列代码的高速缓存性能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">        square[i][j].c = <span class="number">0</span>;</span><br><span class="line">        square[i][j].m = <span class="number">0</span>;</span><br><span class="line">        square[i][j].y = <span class="number">1</span>;</span><br><span class="line">        square[i][j].k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 写总数是多少？</p>
<p>B. 在高速缓存中不命中的写总数是多少？</p>
<p>C. 不命中率是多少？</p>
<p><strong>解：</strong></p>
<p>point_color 结构体大小为16字节，高速缓存块大小为 32 字节，每个 32
字节的高速缓存行包含着2个连续的 point_color 结构 。
每个循环按照内存顺序访问这些结构，每次写一个整数元素 。
所以，每个2次循环的模式就是1次不命中、7次命中，依此类推。</p>
<p>A. 4 * 16 * 16 =1024</p>
<p>B. 4 * 16 * 16 * 1/8=128</p>
<p>C. 12.5%</p>
<h2 id="section-5">6.41</h2>
<p>你正在编写一个新的 3D 游戏，
希望能名利双收。现在正在写一个函数，使得在画下一帧之前先清空屏幕缓冲区。工作的屏幕是
640 × 480 像素数组。工作的机器有一个 64KB 直接映射高速缓存，每行 4
个字节。 使用下面的 C 语言数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pixel</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> r;</span><br><span class="line">    <span class="type">char</span> g;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pixel</span> <span class="title">buffer</span>[480][640];</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">char</span> *cptr;</span><br><span class="line"><span class="type">int</span> *iptr;</span><br></pre></td></tr></table></figure>
<p>有如下假设：</p>
<ul>
<li><p><code>sizeof(char)==1</code> 和 <code>sizecf(int)==4</code>
。</p></li>
<li><p>buffer 起始于内存地址 0 。</p></li>
<li><p>高速缓存初始为空。</p></li>
<li><p>唯一的内存访问是对于 buffer 数组中元素的访间。变量 <em>i 、 j 、
cptr</em> 和 <em>iptr</em> 存放在寄存器中。</p></li>
</ul>
<p>下面代码中百分之多少的写会在高速缓存中不命中？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">640</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">480</span>; j++)&#123;</span><br><span class="line">        buffer[i][j].r = <span class="number">0</span>;</span><br><span class="line">        buffer[i][j].g = <span class="number">0</span>;</span><br><span class="line">        buffer[i][j].b = <span class="number">0</span>;</span><br><span class="line">        buffer[i][j].a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解：</strong></p>
<p>pixel 结构体大小为 4 字节，高速缓存块大小为 4 字节，每个 4
字节的高速缓存行可以存储1个 pixel 结构 。
每个循环按照内存顺序访问这些结构，每次写一个字节 。
所以，每次循环的模式就是1次不命中、4次命中，依此类推，所以命中率为25%。</p>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC计科复试刷题记录/2011</title>
    <url>/post/3a86b2e7.html</url>
    <content><![CDATA[<p>本文为2011年中科大计算机学院复试机试刷题记录，使用C++作为编程语言，并在Linux
平台下使用gcc编译器进行编译以及测试运行。输入输出风格偏向于C，有些题目会用到C++的STL标准函数库。</p>
<span id="more"></span>
<h2 id="题目详解">题目详解</h2>
<h3 id="进制转换">进制转换</h3>
<blockquote>
<p>给两个十进制数，先异或，然后输出其二进制形式。</p>
</blockquote>
<p>C语言中的<code>printf</code>函数可以直接打印十进制，八进制，十六进制，输出控制符分别为%d,
%o, %x, 但是它不能直接输出二进制，所以这里考虑使用位操作输出二进制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给两个十进制数，先异或，然后输出其二进制形式。 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> c = a ^ b;</span><br><span class="line">    <span class="type">int</span> bits[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="comment">// 每次取最低一位 得到逆位输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        bits[i] = c &amp; <span class="number">1</span>;</span><br><span class="line">        c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反向输出即为正确答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bits[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行与测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -o ex1 ex1.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex1</span></span><br><span class="line">1 2</span><br><span class="line">00000000000000000000000000000011</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex1</span></span><br><span class="line">3 5</span><br><span class="line">00000000000000000000000000000110</span><br></pre></td></tr></table></figure>
<h3 id="球的取法">球的取法</h3>
<blockquote>
<p>一共有十二个球，其颜色有红、黄、黑三种，红黄黑分别有 x，y，k
个，现在从其中取出八个球，共有多少种取法，输出到文件中？（x，y，k
从键盘输入，同种颜色的球不区分）</p>
</blockquote>
<p>输出格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  红球， 黄球， 黑球;</span><br><span class="line"><span class="number">2.</span>  红球， 黄球， 黑球;</span><br><span class="line"><span class="number">3.</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>直接用双重循环暴力枚举前两种球被抽到的个数。注意这题要求输出到文件，使用C语言的fprint函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  FILE * fp;</span><br><span class="line">  fp = <span class="built_in">fopen</span> (<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span> &amp;&amp; i &lt;= x; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">8</span> - i &amp;&amp; j &lt;= y; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">8</span> - i - j &lt;= k)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%2d. %d红球，%d黄球，%d黑球\n&quot;</span>, ++cnt, i, j, <span class="number">8</span> - i - j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行与测试</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -o ex2 ex2.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex2  3 4 5</span></span><br><span class="line">// 3.txt</span><br><span class="line"> 1. 0红球，3黄球，5黑球</span><br><span class="line"> 2. 0红球，4黄球，4黑球</span><br><span class="line"> 3. 1红球，2黄球，5黑球</span><br><span class="line"> 4. 1红球，3黄球，4黑球</span><br><span class="line"> 5. 1红球，4黄球，3黑球</span><br><span class="line"> 6. 2红球，1黄球，5黑球</span><br><span class="line"> 7. 2红球，2黄球，4黑球</span><br><span class="line"> 8. 2红球，3黄球，3黑球</span><br><span class="line"> 9. 2红球，4黄球，2黑球</span><br><span class="line">10. 3红球，0黄球，5黑球</span><br><span class="line">11. 3红球，1黄球，4黑球</span><br><span class="line">12. 3红球，2黄球，3黑球</span><br><span class="line">13. 3红球，3黄球，2黑球</span><br><span class="line">14. 3红球，4黄球，1黑球</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配">模式匹配</h3>
<p>在文件<code>3.txt</code>中查看是否有模式<code>abc*d?e</code>。若有，输出<code>找到abc*d?e匹配</code>；若无，则输出<code>没有找到abc*d?e匹配</code>，将结果输出到控制台。其中*代表任意个数（0或1或多个），？代表一个或零个，即正则表达式。</p>
<ul>
<li>思路：本题可以采用《编译原理》里面的确定的有限状态机（DFA）解决。先画出模式的DFA图，然后根据
DFA 列出如下的状态跳转表，之后我们就可以采用 <strong>表驱动法</strong>
进行编程实现了。可以参考力扣题目：<a href="https://leetcode.cn/problems/valid-number/">65.
有效数字</a>，也是有关DFA的，有很详细的解答。</li>
</ul>
<p><img src="/post/3a86b2e7/image-20221102195829040.png" alt="image-20221102195829040" style="zoom:50%;"></p>
<table>
<thead>
<tr class="header">
<th>state</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>1</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(<span class="string">&quot;3.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="type">int</span> move[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, <span class="comment">// 多一行方便一一对应</span></span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((!<span class="built_in">feof</span>(fp)) &amp;&amp; (state != <span class="number">5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="string">&#x27;a&#x27;</span> &lt;= ch) &amp;&amp; (ch &lt;= <span class="string">&#x27;e&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            state = move[state][ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到abc*d?e匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到abc*d?e匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//3.txt</span><br><span class="line">aaaaaabbccddeeabeabccccde</span><br><span class="line">//run ex3</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -o ex3 ex3.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./ex3</span></span><br><span class="line">找到abc*d?e匹配</span><br></pre></td></tr></table></figure>
<h3 id="二叉树后序遍历">二叉树后序遍历</h3>
<p>从文件<code>4.txt</code>中读入一个二叉树，然后后序遍历该二叉树，将结果输出到文件<code>4.out</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入格式：</span><br><span class="line"><span class="comment">// 表示节点个数</span></span><br><span class="line"><span class="comment">// 当前节点编号 左孩子编号 右孩子编号</span></span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>思路</li>
</ul>
<p>这题的得分点其实挺多的，写出来树节点的结构体，创建树等等。读入每行树节点时，可以使用一个数组记录每个子树根节点的指针，方便使用节点编号就可以直接访问节点，从而添加孩子节点，最后从根即可访问到所有节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *in_fp;</span><br><span class="line">FILE *out_fp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    node *lchild, *rchild;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> v) : <span class="built_in">val</span>(v), <span class="built_in">lchild</span>(<span class="literal">NULL</span>), <span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">fprintf</span>(out_fp, <span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 树节点个数</span></span><br><span class="line">    in_fp = <span class="built_in">fopen</span>(<span class="string">&quot;4.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    out_fp = <span class="built_in">fopen</span>(<span class="string">&quot;4.out&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(in_fp, <span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    node *tree[n + <span class="number">1</span>] = &#123;<span class="literal">NULL</span>&#125;; <span class="comment">// 保存节点的指针</span></span><br><span class="line">    <span class="type">int</span> r, a, b;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rootId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(in_fp, <span class="string">&quot;%d %d %d&quot;</span>, &amp;r, &amp;a, &amp;b)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">            rootId = r; <span class="comment">// 记录根节点的位置</span></span><br><span class="line">        <span class="keyword">if</span> (tree[r] == <span class="literal">NULL</span>)</span><br><span class="line">            tree[r] = <span class="keyword">new</span> <span class="built_in">node</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (tree[a] == <span class="literal">NULL</span> &amp;&amp; a != <span class="number">0</span>)</span><br><span class="line">            tree[a] = <span class="keyword">new</span> <span class="built_in">node</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (tree[b] == <span class="literal">NULL</span> &amp;&amp; b != <span class="number">0</span>)</span><br><span class="line">            tree[b] = <span class="keyword">new</span> <span class="built_in">node</span>(b);</span><br><span class="line">        tree[r]-&gt;lchild = tree[a];</span><br><span class="line">        tree[r]-&gt;rchild = tree[b];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">postOrder</span>(tree[rootId]);</span><br><span class="line">    <span class="built_in">fclose</span>(in_fp);</span><br><span class="line">    <span class="built_in">fclose</span>(out_fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 4.txt</span><br><span class="line">4 </span><br><span class="line">1 2 4 </span><br><span class="line">2 0 3</span><br><span class="line">3 0 0</span><br><span class="line">4 0 0</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">g++ -o ex4 ex4.cpp</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./ex4</span></span><br><span class="line">// 4.out</span><br><span class="line">3 2 4 1 </span><br></pre></td></tr></table></figure>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><p><a href="https://zdszero.github.io/posts/ustc-test-2011/">中科大2011年复试机试题详解</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/377692017">中科大计算机考研复试详解</a>
这篇有很详细的复试介绍以及资料，非常推荐！</p></li>
<li><p><a href="http://www.cskaoyan.com/thread-60279-1-10.html">中科大2011计算机考研复试上机(第三题)代码，附回忆版上机试题</a></p></li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>代码</tag>
        <tag>复试</tag>
      </tags>
  </entry>
  <entry>
    <title>USTC计科复试刷题记录/2012</title>
    <url>/post/a38fe35d.html</url>
    <content><![CDATA[<p>本文为2012年中科大计算机学院复试机试刷题记录，使用C++作为编程语言，并在Linux
平台下使用gcc编译器进行编译以及测试运行。输入输出风格偏向于C，有些题目会用到C++的STL标准函数库。</p>
<span id="more"></span>
<h2 id="题目详解">题目详解</h2>
<h3 id="字符串处理">字符串处理</h3>
<blockquote>
<p>字符串处理：从<code>string.in</code>文件里读入两个字符串，字符串除了数字还可能包括<code>'-'、'E'、'e'、'.'</code>，相加之后输出到文件<code>string.out</code>中，如果是浮点型，要求用科学计数法表示（最多保留10个有效数字）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入示例:                       </span><br><span class="line">34.56                                </span><br><span class="line">2.45e2    </span><br><span class="line"></span><br><span class="line">输出示例: </span><br><span class="line">2.7956e2 </span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：可以通过是否有小数点判断输入的是整数还是浮点数，有小数点则利用atof()将字符串转为double型，否则使用atoi()转换为int型。然后就可以用<code>"%.10e"</code>输出科学计数法表示的浮点数。但是这样还有一个问题，就是浮点数输出来结果会有多余的0和加号，<code>2.7956000000e+02</code>。可以先将结果字符串输出到缓冲区，然后消除多余的0以及加号等。</p>
<p>具体代码如下：</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *infile = <span class="built_in">fopen</span>(<span class="string">&quot;string.in&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *outfile = <span class="built_in">fopen</span>(<span class="string">&quot;string.out&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">fscanf</span>(infile, <span class="string">&quot;%s&quot;</span>, str1);</span><br><span class="line">    <span class="built_in">fscanf</span>(infile, <span class="string">&quot;%s&quot;</span>, str2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag_double_str1 = <span class="literal">false</span>, flag_double_str2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (str1[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag_double_str1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str2[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str2[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag_double_str2 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag_double_str1 &amp;&amp; !flag_double_str2) <span class="comment">// 全为整形则直接输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">atoi</span>(str1);</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">atoi</span>(str2);</span><br><span class="line">        <span class="built_in">fprintf</span>(outfile, <span class="string">&quot;%d&quot;</span>, a + b);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若有一个数为浮点数则转为double</span></span><br><span class="line">    <span class="type">double</span> a = <span class="built_in">atof</span>(str1);</span><br><span class="line">    <span class="type">double</span> b = <span class="built_in">atof</span>(str2);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%.10e&quot;</span>, a + b);</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; buf[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; buf[j] == <span class="string">&#x27;0&#x27;</span>; j--)</span><br><span class="line">        ; <span class="comment">// 从e往前找，跳过中间为0的部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++)</span><br><span class="line">        <span class="built_in">fputc</span>(buf[k], outfile);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;e&#x27;</span>, outfile);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">while</span> (buf[i] == <span class="string">&#x27;+&#x27;</span> || buf[i] == <span class="string">&#x27;0&#x27;</span>) <span class="comment">// 消除e后的加号以及0</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">for</span> (j = i; buf[j] != <span class="string">&#x27;\0&#x27;</span>; j++)</span><br><span class="line">        <span class="built_in">fputc</span>(buf[j], outfile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cc -o ex1 ex1.cpp</span></span><br><span class="line">// string.in</span><br><span class="line">34.56                                </span><br><span class="line">2.45e2 </span><br><span class="line">// string.out</span><br><span class="line">2.7956e2</span><br><span class="line">// string.in</span><br><span class="line">34</span><br><span class="line">2</span><br><span class="line">// string.out</span><br><span class="line">36</span><br></pre></td></tr></table></figure>
<h3 id="最大公约数">最大公约数</h3>
<blockquote>
<p>最大公约数：从<code>number.in</code>文件中读入n个数，求出这n个数的最小值、最大值以及它们两的最大公约数，输出到文件<code>number.out</code>中。number.in
中第一行为n，接下来为n个大于零的整数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入示例:</span><br><span class="line">3</span><br><span class="line">4 8 6</span><br><span class="line"></span><br><span class="line">输出示例:</span><br><span class="line">4 8 4</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路：首先遍历数组nums得到最大值与最小值后，再计算两者的最大公约数即可。求最大公约数有三种常用的方法：<strong>辗转相除法</strong>、<strong>更相减损术</strong>
及其基础上进行改进的 <strong>Stein算法</strong>。</p></li>
<li><p>辗转相除法，又称欧几里得算法，对于两个非负整数<span class="math inline">\(x,y(x&gt;y)\)</span>，其计算公式为：</p></li>
</ul>
<p><span class="math display">\[
gcd(x,y)=gcd(y,x\ mod \ y)
\]</span></p>
<ul>
<li><p>更相减损术，出自《九章算术》（原本是为了求约分，修改后可用来求解最大公约数）的一种求最大公约数的算法。主要思路为：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续上述操作，直到所得的减数和差相等为止。</p></li>
<li><p>参考力扣题目：<a href="https://leetcode.cn/problems/find-greatest-common-divisor-of-array/">1979.
找出数组的最大公约数</a></p></li>
</ul>
<p>采用辗转相除法得到的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *in_fp;</span><br><span class="line">    FILE *out_fp;</span><br><span class="line"></span><br><span class="line">    in_fp = <span class="built_in">fopen</span>(<span class="string">&quot;number.in&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    out_fp = <span class="built_in">fopen</span>(<span class="string">&quot;number.out&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">fscanf</span>(in_fp, <span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nums[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(in_fp, <span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min, max;</span><br><span class="line">    min = max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; min)</span><br><span class="line">            min = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">            max = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(out_fp, <span class="string">&quot;%d %d %d&quot;</span>, min, max, <span class="built_in">gcd</span>(max, min));</span><br><span class="line">    <span class="built_in">fclose</span>(in_fp);</span><br><span class="line">    <span class="built_in">fclose</span>(out_fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">cc -o ex2 ex2.cpp</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./ex2</span></span><br><span class="line">//number.in</span><br><span class="line">3</span><br><span class="line">4 8 6</span><br><span class="line">//number.out</span><br><span class="line">4 8 4</span><br><span class="line">//number.in</span><br><span class="line">7</span><br><span class="line">4 8 6 10 9 24 30</span><br><span class="line">//number.out</span><br><span class="line">4 30 2</span><br></pre></td></tr></table></figure>
<h3 id="任务调度">任务调度</h3>
<blockquote>
<p>任务调度：从<code>task.in</code>文件中读入任务调度序列，输出n个任务适合的一种调度方式到<code>task.out</code>中。每行第一个表示前序任务，括号中的任务为后序任务，只有在前序任务完成的情况下，后序任务才能开始。若后序为NULL则表示无后序任务。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入示例:</span><br><span class="line">Task0(Task1,Task2)</span><br><span class="line">Task1(Task3)</span><br><span class="line">Task2(NULL)</span><br><span class="line">Task3(NULL)</span><br><span class="line"></span><br><span class="line">输出示例:</span><br><span class="line">Task0 Task1 Task3 Task2</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：这道题是典型的拓朴排序问题。拓扑排序可以使用深度优先遍历，在DFS实现拓扑排序时，用<strong>栈</strong>来保存拓扑排序的顶点序列；并且保证在某顶点入栈前，其所有邻接点已入栈。</li>
<li>练习题目：<a href="https://www.luogu.com.cn/problem/P1347">P1347
排序</a></li>
<li>一般来说树和图的输入都比较复杂，还有建树，建图这种操作。所以刷树和图的时候，我比较推荐用洛谷上的题目，这上面的题目都是有输入输出要求的，跟考试的要求差不多，而力扣是函数式的编程，无法锻炼处理输入输出的能力。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10           <span class="comment">// 记录最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff <span class="comment">// 定义无穷大</span></span></span><br><span class="line"><span class="type">int</span> graph[N][N];       <span class="comment">// 有向图邻接矩阵</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;             <span class="comment">// 记录顶点个数</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">bool</span> *visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visit[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历找到所有没被访问过的邻接节点进行访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[u][v] == <span class="number">1</span> &amp;&amp; !visit[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(v, visit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S.<span class="built_in">push</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *in_fp = <span class="built_in">fopen</span>(<span class="string">&quot;task.in&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    FILE *out_fp = <span class="built_in">fopen</span>(<span class="string">&quot;task.out&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化图矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            graph[i][j] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入有向图</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(in_fp, <span class="string">&quot;%s&quot;</span>, buf) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        r = <span class="built_in">atoi</span>(&amp;buf[<span class="number">4</span>]);</span><br><span class="line">        graph[r][r] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (buf[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;k&#x27;</span>) <span class="comment">// 转化Task后面的数组</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = <span class="built_in">atoi</span>(&amp;buf[i + <span class="number">1</span>]);</span><br><span class="line">                graph[r][v] = <span class="number">1</span>; <span class="comment">// 记录有向图的一条边</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> visit[n] = &#123;<span class="literal">false</span>&#125;; <span class="comment">// 记录顶点是否访问</span></span><br><span class="line">    <span class="comment">// 深度优先遍历记录拓扑排序 注意可能图不连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(i, visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span> (!S.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(out_fp, <span class="string">&quot;Task%d &quot;</span>, S.<span class="built_in">top</span>());</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(in_fp);</span><br><span class="line">    <span class="built_in">fclose</span>(out_fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">g++ -o ex3 ex3.cpp</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./ex3</span></span><br><span class="line">// task.out</span><br><span class="line">Task0 Task2 Task1 Task3 </span><br></pre></td></tr></table></figure>
<p>拓扑排序的结果可能有多种，这里使用邻接矩阵从最小的序号开始深度优先遍历，所以与题目给的样例不一样。</p>
<h3 id="火车票订购">火车票订购</h3>
<blockquote>
<p>火车票订购：火车经过X站，火车的最大载客人数为m，有n个订票请求，请求订购从a站到b站的k张票，若能满足订购要求则输出1，否则输出0。数据从<code>ticket.in</code>中输入，第一行有两个数字，分别是n，m。接下来有n行，每行三个数分别是a、b、k。结果输出到文件<code>ticket.out</code>中。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入示例:</span><br><span class="line">5 10</span><br><span class="line">4 10 9</span><br><span class="line">8 12 2</span><br><span class="line">8 12 1</span><br><span class="line">14 20 8</span><br><span class="line">30 300 15</span><br><span class="line"></span><br><span class="line">输出示例:</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：用一个大数组来存储每一站的车上人数，在每一次运送乘客时先尝试是否有足够空位，如果有空位则将flag置为1，否则将flag置为0，如果尝试之后flag=1则可以搭载这波乘客。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;input.in&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;output.out&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">//火车的最大载客人数为m，有n个订票请求</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">record</span><span class="params">(<span class="number">1000</span>,<span class="number">0</span>)</span></span>; <span class="comment">// 每站路车上人数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ifs&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,k; <span class="comment">//请求订购从a站到b站的k张票</span></span><br><span class="line">        ifs&gt;&gt;a&gt;&gt;b&gt;&gt;k;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=a; j&lt;b; j++) <span class="comment">// 检查每个路段是否合法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(record[j]+k&gt;m)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j!=b) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检查合法则订购成功 记录本次订购</span></span><br><span class="line">        ans[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=a; j&lt;b; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            record[j]+=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="type">int</span>)ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ofs&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路径">最短路径</h3>
<blockquote>
<p>最短路径：有n个城市和m条道路（n &lt; 1000, m &lt;
10000），每条道路有不同的长度，请找到从起点s到终点t的最短距离，并且输出经过的城市的序号，如果有多条，输出字典序最小的那条；若从s到t没有路径，则输出“can't
arrive”。从文件<code>road.in</code>中读入数据，第一行有四个数，分别为n、m、s、t。接下来有m行，每行三个数，分别为两个城市的序号和相互之间的距离，将结果输出结果到文件<code>road.out</code>中。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入示例:</span><br><span class="line">3 3 1 3</span><br><span class="line">1 3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line"></span><br><span class="line">输出示例:</span><br><span class="line">2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<ul>
<li>思路：这道题考察的是单源最短路径问题，有<code>Dijkstra</code>算法和多源最短路径的<code>floyed-warshall</code>算法，这里使用比较容易编程实现的<code>floyed-warshall</code>算法，三重循环搞定。用road二维数组记录图的信息，用next二维数组记录下一跳。</li>
<li>参考题目：<a href="https://www.luogu.com.cn/problem/P4779">P4779
【模板】单源最短路径（标准版）</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=INT_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;input.in&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;output.out&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifs&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">g</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,INF)); <span class="comment">// 无向图邻接矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">next</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>)); <span class="comment">// next[i][j]表示i到j最短路径的下一个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        ifs&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        g[u][v]=w;      <span class="comment">// 无向图边初始化</span></span><br><span class="line">        g[v][u]=w;</span><br><span class="line">        next[u][v]=v;   <span class="comment">// 将有边连接的顶点下一个顶点初始化</span></span><br><span class="line">        next[v][u]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i][i]=<span class="number">0</span>;</span><br><span class="line">        next[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=n; x++) <span class="comment">// 弗洛伊德算法求多源最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][x]==INF||g[x][j]==INF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> sum=g[i][x]+g[x][j];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;g[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j]=sum; <span class="comment">// 松弛边</span></span><br><span class="line">                    next[i][j]=x; <span class="comment">// 记录最短路径的中间结点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(g[s][t]==INF)</span><br><span class="line">    &#123;</span><br><span class="line">        ofs&lt;&lt;<span class="string">&quot;can&#x27;t arrive.&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ofs&lt;&lt;g[s][t]&lt;&lt;endl;</span><br><span class="line">    ofs&lt;&lt;s;</span><br><span class="line">    <span class="type">int</span> cur=s;</span><br><span class="line">    <span class="keyword">while</span>(cur!=t)&#123;</span><br><span class="line">        cur=next[cur][t];</span><br><span class="line">        ofs&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考链接">参考链接</h1>
<ul>
<li><a href="http://www.cskaoyan.com/thread-87090-1-1.html">2012年中科大考研上机机试试题（回忆版）</a></li>
<li><a href="https://zdszero.github.io/posts/ustc-test-2012/">中科大2012年复试机试题详解</a></li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>代码</tag>
        <tag>复试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT主题配置备份及还原</title>
    <url>/post/3f7b24f8.html</url>
    <content><![CDATA[<p>第三次搭建github pages+hexo+NexT
主题的博客了，之前总是因为各种原因中途放弃，这次一定要坚持！这里记录一下备份及今后还原的流程，方便之后的维护。</p>
<span id="more"></span>
<h1 id="备份说明">备份说明</h1>
<p>由于博客发布的远程仓库的 <code>master</code>
分支是经过编译的静态网页文件，而我们需要保存源文件、更改后的配置等以进行新机器上的还原。我对备份的要求就是：</p>
<ul>
<li>备份站点配置文件</li>
<li>备份主题配置文件</li>
<li>能方便地更新NexT主题（所以最好是能保留原来的.git文件方便拉取官方最近的更新）</li>
</ul>
<p>一般的做法是使用 <code>master</code>
分支展示博客页面，再创建另一个分支用来备份源文件，这样就可以将文件都备份在一个仓库下。</p>
<p>但是实际操作中发现，因为使用的是最新的<a href="https://github.com/theme-next/hexo-theme-next">NexT Release
v7.8.0</a>
版本，theme主题上传到GitHub时，只有主题名，主题文件夹下并没有主题对应文件，所以说这种方式只能备份站点配置文件，主题配置文件无法备份。这部分往往是最重要的，因为包括了很多自己定义的配置。如果直接删除themes/next文件夹下的.git文件，那么任何自定义的修改都会使合并上游的改动变得困难。</p>
<p>对此我找到了一种比较优雅的策略：使用子模块（ submodule
）进行多个仓库的嵌套。</p>
<blockquote>
<p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。
它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
</blockquote>
<h1 id="开始备份">开始备份</h1>
<blockquote>
<p><strong>为防止备份过程中出现失误，请先提前复制一份自己的博客文件作为备用，一旦失败可以删档重来。</strong></p>
</blockquote>
<h2 id="站点仓库公开">站点仓库（公开）</h2>
<p>站点仓库使用两个分支，一个<code>master</code>分支存放博客静态页面文件，另一个<code>source</code>分支用来备份站点配置的源文件。配置步骤如下：</p>
<ol type="1">
<li><p>先把themes目录下自己定义过的主题文件删除，防止后面出现子模块冲突。(这一步非常重要，不然后面还得删掉重来)</p></li>
<li><p>在博客目录下初始化本地 git 并添加远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https://github.com/your_name/your_name.github.io.git</span><br></pre></td></tr></table></figure></li>
<li><p>创建 <code>source</code> 分支并推送源文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b source</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial backup&quot;</span><br><span class="line">git push origin source:source # 这里 source source 会在远端自动创建分支</span><br></pre></td></tr></table></figure></li>
<li><p>查看自己的github仓库是否已经推送成功</p></li>
<li><p>在每次修改博客之后，需要做 deploy 到 <code>master</code> 分支和
push 到 <code>source</code> 分支两件事</p>
<blockquote>
<p>在 github仓库的 settings 中将 source 分支改为默认分支，可以简化为
<code>git push</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;your comment&quot;</span><br><span class="line">git push origin source:source</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题仓库私有">主题仓库（私有）</h2>
<ol type="1">
<li><p>在 github 中创建一个私人仓库
<code>hexo-theme-next</code>，用于存放主题配置文件。私人仓库是为了保存主题中的隐私文件。</p></li>
<li><p>从原来的主题仓库中将代码 clone
下来，初始化远端的私人仓库，这里以NexT仓库为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git</span><br><span class="line">git push --mirror https://github.com/your_name/hexo-theme-next.git #该仓库作为子模块</span><br></pre></td></tr></table></figure></li>
<li><p>将一个已初始化的主题私人仓库添加为站点仓库的子模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/your_name/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure></li>
<li><p>检查子模块是否创建成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">...</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   .gitmodules # 出现.gitmodules 文件即代表创建成功了</span><br><span class="line">	new file:   themes/next</span><br></pre></td></tr></table></figure></li>
<li><p>进入新创建的themes/next主题文件夹，为仓库添加
<code>upstream</code>，用于同步源仓库的更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> themes/next</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add upstream https://github.com/theme-next/hexo-theme-next.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v   <span class="comment"># 查看配置</span></span></span><br><span class="line">origin  https://github.com/your_name/your_name.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/your_name/your_name.github.io.git (push)</span><br><span class="line">upstream        https://github.com/theme-next/hexo-theme-next.git (fetch)</span><br><span class="line">upstream        https://github.com/theme-next/hexo-theme-next.git (push)</span><br></pre></td></tr></table></figure>
<p>这样就可以进入到目录中运行 <code>git fetch</code> 与
<code>git merge</code>来合并上游分支来更新本地代码。同步操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch upstream master</span></span><br><span class="line">From https://github.com/theme-next/hexo-theme-next</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/master</span></span><br></pre></td></tr></table></figure></li>
<li><p>推送更改到站点仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;add submodule&quot;</span><br><span class="line">git push origin source:source</span><br></pre></td></tr></table></figure></li>
</ol>
<p>到此为止我们已经成功创建并配置好了两个备份仓库，但是主题私人仓库中储存的仍然是原始文件，下面还要把自定义的配置备份一下：</p>
<h2 id="备份主题配置">备份主题配置</h2>
<ol type="1">
<li><p>将自己修改后的主题文件覆盖themes/next下的原始文件（注意不要把.git文件复制过来！！！，构建子模块后themes/next目录中已经不存在.git文件了）</p></li>
<li><p>进入themes/next文件夹下，提交更新到远程私人仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;update ...&quot;</span><br><span class="line">git push origin HEAD:master</span><br></pre></td></tr></table></figure>
<p>以后每次对themes/next更新都要从该目录下独立地推送到远程仓库，也就是说对于更新操作，两个仓库是分开的。只在博客根目录的提交并不会同步提交themes/next的更改。</p></li>
</ol>
<h1 id="还原">还原</h1>
<ol type="1">
<li><p>先安装好 git、ssh、node、hexo</p></li>
<li><p>使用 <code>git clone</code> 克隆 <code>source</code>
分支的源文件，<code>--recursive</code> 参数可以同步还原
submodule，相当于我们只用一条命令就克隆了两个仓库。</p>
<blockquote>
<p>如果已将 <code>source</code> 分支设置为默认分支，可省略
<code>-b source</code> 参数；</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b source https://github.com/your_name/your_name.github.io.git --recurse-submodules</span><br></pre></td></tr></table></figure>
<p>如果你已经克隆了项目但忘记了
<code>--recurse-submodules</code>，也可以在下载完仓库后，使用<code>git submodule init</code>
和 <code>git submodule update</code> 进行子模块的还原。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b source https://your_name/your_name.github.io.git</span><br><span class="line">git init</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></li>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://quareia.github.io/blog/6efb1d64/">Github
Pages+hexo+NexT 博客搭建、备份及还原</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git
工具 - 子模块</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>备份</tag>
        <tag>NexT</tag>
        <tag>主题</tag>
      </tags>
  </entry>
</search>
